<!DOCTYPE html>
<html >

<head>

  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>Introduction to Data Science</title>
  <meta name="description" content="Introduction to Data Science">
  <meta name="generator" content="bookdown <!--bookdown:version--> and GitBook 2.6.7">

  <meta property="og:title" content="Introduction to Data Science" />
  <meta property="og:type" content="book" />
  <meta property="og:url" content="http://scientistcafe.com/IDS/" />
  
  <meta property="og:description" content="Introduction to Data Science" />
  <meta name="github-repo" content="happyrabbit/IntroDataScience" />

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="Introduction to Data Science" />
  
  <meta name="twitter:description" content="Introduction to Data Science" />
  

<meta name="author" content="Hui Lin and Ming Li">


<meta name="date" content="2019-08-21">

  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  
  
<!--bookdown:link_prev-->
<!--bookdown:link_next-->
<script src="libs/jquery/jquery.min.js"></script>
<link href="libs/gitbook/css/style.css" rel="stylesheet" />
<link href="libs/gitbook/css/plugin-bookdown.css" rel="stylesheet" />
<link href="libs/gitbook/css/plugin-highlight.css" rel="stylesheet" />
<link href="libs/gitbook/css/plugin-search.css" rel="stylesheet" />
<link href="libs/gitbook/css/plugin-fontsettings.css" rel="stylesheet" />
<script src="libs/gitbook/js/app.min.js"></script>
<script src="libs/gitbook/js/lunr.js"></script>
<script src="libs/gitbook/js/plugin-search.js"></script>
<script src="libs/gitbook/js/plugin-sharing.js"></script>
<script src="libs/gitbook/js/plugin-fontsettings.js"></script>
<script src="libs/gitbook/js/plugin-bookdown.js"></script>
<script src="libs/gitbook/js/jquery.highlight.js"></script>


<style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
</style>

<link rel="stylesheet" href="css/style.css" type="text/css" />
</head>

<body>



<!--bookdown:title:start-->
<div id="header">
<h1 class="title">Introduction to Data Science</h1>
<h4 class="author"><em>Hui Lin and Ming Li</em></h4>
<h4 class="date"><em>2019-08-21</em></h4>
</div>
<!--bookdown:title:end-->

<!--bookdown:toc:start-->
  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">
<!--bookdown:toc2:start-->
<ul>
<li><a href="#preface">Preface</a><ul>
<li><a href="#goal-of-the-book">Goal of the Book</a></li>
<li><a href="#who-this-book-is-for">Who This Book Is For</a></li>
<li><a href="#what-this-book-covers">What This Book Covers</a></li>
<li><a href="#conventions">Conventions</a></li>
<li><a href="#acknowledgements">Acknowledgements</a></li>
</ul></li>
<li><a href="#about-the-authors">About the Authors</a></li>
<li><a href="#introduction"><span class="toc-section-number">1</span> Introduction</a><ul>
<li><a href="#blind-men-and-an-elephant"><span class="toc-section-number">1.1</span> Blind men and an elephant</a><ul>
<li><a href="#data-science-roleskill-tracks"><span class="toc-section-number">1.1.1</span> Data science role/skill tracks</a></li>
</ul></li>
<li><a href="#what-should-data-science-do"><span class="toc-section-number">1.2</span> What should data science do?</a><ul>
<li><a href="#lets-dream-big"><span class="toc-section-number">1.2.1</span> Let’s dream big</a></li>
<li><a href="#what-kind-of-questions-can-data-science-solve"><span class="toc-section-number">1.2.2</span> What kind of questions can data science solve?</a></li>
</ul></li>
<li><a href="#structure-data-science-team"><span class="toc-section-number">1.3</span> Structure data science team</a></li>
</ul></li>
<li><a href="#soft-skills-for-data-scientists"><span class="toc-section-number">2</span> Soft Skills for Data Scientists</a><ul>
<li><a href="#comparison-between-statistician-and-data-scientist"><span class="toc-section-number">2.1</span> Comparison between Statistician and Data Scientist</a></li>
<li><a href="#beyond-data-and-analytics"><span class="toc-section-number">2.2</span> Beyond Data and Analytics</a></li>
<li><a href="#three-pillars-of-knowledge"><span class="toc-section-number">2.3</span> Three Pillars of Knowledge</a></li>
<li><a href="#data-science-project-cycle"><span class="toc-section-number">2.4</span> Data Science Project Cycle</a><ul>
<li><a href="#types-of-data-science-projects"><span class="toc-section-number">2.4.1</span> Types of Data Science Projects</a></li>
<li><a href="#at-the-planning-stage"><span class="toc-section-number">2.4.2</span> At the Planning Stage</a></li>
<li><a href="#at-the-modeling-stage"><span class="toc-section-number">2.4.3</span> At the Modeling Stage</a></li>
<li><a href="#at-the-production-stage"><span class="toc-section-number">2.4.4</span> At the Production Stage</a></li>
<li><a href="#summary"><span class="toc-section-number">2.4.5</span> Summary</a></li>
</ul></li>
<li><a href="#common-mistakes-in-data-science"><span class="toc-section-number">2.5</span> Common Mistakes in Data Science</a><ul>
<li><a href="#problem-formulation-stage"><span class="toc-section-number">2.5.1</span> Problem Formulation Stage</a></li>
<li><a href="#problem-planning-stage"><span class="toc-section-number">2.5.2</span> Problem Planning Stage</a></li>
<li><a href="#modeling-stage"><span class="toc-section-number">2.5.3</span> Modeling Stage</a></li>
<li><a href="#production-stage"><span class="toc-section-number">2.5.4</span> Production Stage</a></li>
<li><a href="#summary-1"><span class="toc-section-number">2.5.5</span> Summary</a></li>
</ul></li>
</ul></li>
<li><a href="#introduction-to-the-data"><span class="toc-section-number">3</span> Introduction to the data</a><ul>
<li><a href="#customer-data-for-clothing-company"><span class="toc-section-number">3.1</span> Customer Data for Clothing Company</a></li>
<li><a href="#customer-satisfaction-survey-data-from-airline-company"><span class="toc-section-number">3.2</span> Customer Satisfaction Survey Data from Airline Company</a></li>
<li><a href="#swine-disease-breakout-data"><span class="toc-section-number">3.3</span> Swine Disease Breakout Data</a></li>
<li><a href="#mnist-dataset"><span class="toc-section-number">3.4</span> MNIST Dataset</a></li>
<li><a href="#imdb-dataset"><span class="toc-section-number">3.5</span> IMDB Dataset</a></li>
</ul></li>
<li><a href="#data-pre-processing"><span class="toc-section-number">4</span> Data Pre-processing</a><ul>
<li><a href="#data-cleaning"><span class="toc-section-number">4.1</span> Data Cleaning</a></li>
<li><a href="#missing-values"><span class="toc-section-number">4.2</span> Missing Values</a><ul>
<li><a href="#impute-missing-values-with-medianmode"><span class="toc-section-number">4.2.1</span> Impute missing values with median/mode</a></li>
<li><a href="#k-nearest-neighbors"><span class="toc-section-number">4.2.2</span> K-nearest neighbors</a></li>
<li><a href="#bagging-tree"><span class="toc-section-number">4.2.3</span> Bagging Tree</a></li>
</ul></li>
<li><a href="#centering-and-scaling"><span class="toc-section-number">4.3</span> Centering and Scaling</a></li>
<li><a href="#resolve-skewness"><span class="toc-section-number">4.4</span> Resolve Skewness</a></li>
<li><a href="#resolve-outliers"><span class="toc-section-number">4.5</span> Resolve Outliers</a></li>
<li><a href="#collinearity"><span class="toc-section-number">4.6</span> Collinearity</a></li>
<li><a href="#sparse-variables"><span class="toc-section-number">4.7</span> Sparse Variables</a></li>
<li><a href="#re-encode-dummy-variables"><span class="toc-section-number">4.8</span> Re-encode Dummy Variables</a></li>
</ul></li>
<li><a href="#data-wrangling"><span class="toc-section-number">5</span> Data Wrangling</a><ul>
<li><a href="#read-and-write-data"><span class="toc-section-number">5.1</span> Read and write data</a><ul>
<li><a href="#readr"><span class="toc-section-number">5.1.1</span> <code>readr</code></a></li>
<li><a href="#data.table-enhanced-data.frame"><span class="toc-section-number">5.1.2</span> <code>data.table</code>— enhanced <code>data.frame</code></a></li>
</ul></li>
<li><a href="#summarize-data"><span class="toc-section-number">5.2</span> Summarize data</a><ul>
<li><a href="#apply-lapply-and-sapply-in-base-r"><span class="toc-section-number">5.2.1</span> <code>apply()</code>, <code>lapply()</code> and <code>sapply()</code> in base R</a></li>
<li><a href="#dplyr-package"><span class="toc-section-number">5.2.2</span> <code>dplyr</code> package</a></li>
</ul></li>
<li><a href="#tidy-and-reshape-data"><span class="toc-section-number">5.3</span> Tidy and Reshape Data</a><ul>
<li><a href="#reshape2-package"><span class="toc-section-number">5.3.1</span> <code>reshape2</code> package</a></li>
<li><a href="#tidyr-package"><span class="toc-section-number">5.3.2</span> <code>tidyr</code> package</a></li>
</ul></li>
</ul></li>
<li><a href="#model-tuning-strategy"><span class="toc-section-number">6</span> Model Tuning Strategy</a><ul>
<li><a href="#systematic-error-and-random-error"><span class="toc-section-number">6.1</span> Systematic Error and Random Error</a><ul>
<li><a href="#measurement-error-in-the-response"><span class="toc-section-number">6.1.1</span> Measurement Error in the Response</a></li>
<li><a href="#measurement-error-in-the-independent-variables"><span class="toc-section-number">6.1.2</span> Measurement Error in the Independent Variables</a></li>
</ul></li>
<li><a href="#data-splitting-and-resampling"><span class="toc-section-number">6.2</span> Data Splitting and Resampling</a><ul>
<li><a href="#data-splitting"><span class="toc-section-number">6.2.1</span> Data Splitting</a></li>
<li><a href="#resampling"><span class="toc-section-number">6.2.2</span> Resampling</a></li>
</ul></li>
</ul></li>
<li><a href="#measuring-performance"><span class="toc-section-number">7</span> Measuring Performance</a><ul>
<li><a href="#regression-model-performance"><span class="toc-section-number">7.1</span> Regression Model Performance</a></li>
<li><a href="#classification-model-performance"><span class="toc-section-number">7.2</span> Classification Model Performance</a></li>
</ul></li>
<li><a href="#feature-engineering"><span class="toc-section-number">8</span> Feature Engineering</a><ul>
<li><a href="#feature-construction"><span class="toc-section-number">8.1</span> Feature Construction</a></li>
<li><a href="#feature-extraction"><span class="toc-section-number">8.2</span> Feature Extraction</a></li>
<li><a href="#feature-selection"><span class="toc-section-number">8.3</span> Feature Selection</a><ul>
<li><a href="#filter-method"><span class="toc-section-number">8.3.1</span> Filter Method</a></li>
<li><a href="#wrapper-method"><span class="toc-section-number">8.3.2</span> Wrapper Method</a></li>
</ul></li>
</ul></li>
<li><a href="#regression-models"><span class="toc-section-number">9</span> Regression Models</a><ul>
<li><a href="#ordinary-least-squares"><span class="toc-section-number">9.1</span> Ordinary Least Squares</a></li>
<li><a href="#multivariate-adaptive-regression-splines"><span class="toc-section-number">9.2</span> Multivariate Adaptive Regression Splines</a></li>
<li><a href="#generalized-linear-model"><span class="toc-section-number">9.3</span> Generalized Linear Model</a></li>
<li><a href="#pcr-and-pls"><span class="toc-section-number">9.4</span> PCR and PLS</a></li>
</ul></li>
<li><a href="#regularization-methods"><span class="toc-section-number">10</span> Regularization Methods</a><ul>
<li><a href="#ridge-regression"><span class="toc-section-number">10.1</span> Ridge Regression</a></li>
<li><a href="#lasso"><span class="toc-section-number">10.2</span> LASSO</a></li>
<li><a href="#elastic-net"><span class="toc-section-number">10.3</span> Elastic Net</a></li>
<li><a href="#lasso-generalized-linear-model"><span class="toc-section-number">10.4</span> LASSO Generalized Linear Model</a></li>
</ul></li>
<li><a href="#tree-based-methods"><span class="toc-section-number">11</span> Tree-Based Methods</a><ul>
<li><a href="#splitting-criteria"><span class="toc-section-number">11.1</span> Splitting Criteria</a></li>
<li><a href="#tree-pruning"><span class="toc-section-number">11.2</span> Tree Pruning</a></li>
<li><a href="#regression-and-decision-tree-basic"><span class="toc-section-number">11.3</span> Regression and Decision Tree Basic</a></li>
<li><a href="#bagging-tree-1"><span class="toc-section-number">11.4</span> Bagging Tree</a></li>
<li><a href="#random-forest"><span class="toc-section-number">11.5</span> Random Forest</a></li>
<li><a href="#gradient-boosted-machine"><span class="toc-section-number">11.6</span> Gradient Boosted Machine</a></li>
</ul></li>
<li><a href="#neural-network"><span class="toc-section-number">12</span> Neural Network</a><ul>
<li><a href="#projection-pursuit-regression"><span class="toc-section-number">12.1</span> Projection Pursuit Regression</a></li>
<li><a href="#standard-neural-network"><span class="toc-section-number">12.2</span> Standard Neural Network</a><ul>
<li><a href="#logistic_reg_as_neural_network"><span class="toc-section-number">12.2.1</span> Logistic Regression as Neural Network</a></li>
<li><a href="#deep-neural-network"><span class="toc-section-number">12.2.2</span> Deep Neural Network</a></li>
<li><a href="#activation-function"><span class="toc-section-number">12.2.3</span> Activation Function</a></li>
</ul></li>
<li><a href="#convolutional-neural-network"><span class="toc-section-number">12.3</span> Convolutional Neural Network</a></li>
<li><a href="#recurrent-neural-network"><span class="toc-section-number">12.4</span> Recurrent Neural Network</a></li>
</ul></li>
<li><a href="#appendix-appendix">(APPENDIX) Appendix</a></li>
<li><a href="#big-data-cloud-platform"><span class="toc-section-number">13</span> Big Data Cloud Platform</a><ul>
<li><a href="#how-data-becomes-science"><span class="toc-section-number">13.1</span> How Data becomes Science?</a></li>
<li><a href="#power-of-cluster-of-computers"><span class="toc-section-number">13.2</span> Power of Cluster of Computers</a><ul>
<li><a href="#evolution-of-clustering-computing"><span class="toc-section-number">13.2.1</span> Evolution of Clustering Computing</a></li>
<li><a href="#hadoop"><span class="toc-section-number">13.2.2</span> Hadoop</a></li>
<li><a href="#spark"><span class="toc-section-number">13.2.3</span> Spark</a></li>
</ul></li>
<li><a href="#introduction-of-cloud-environment"><span class="toc-section-number">13.3</span> Introduction of Cloud Environment</a></li>
</ul></li>
<li><a href="#databases-and-sql"><span class="toc-section-number">14</span> Databases and SQL</a></li>
<li><a href="#r-code-for-data-simulation"><span class="toc-section-number">15</span> R code for data simulation</a><ul>
<li><a href="#customer-data-for-clothing-company-1"><span class="toc-section-number">15.1</span> Customer Data for Clothing Company</a></li>
<li><a href="#customer-satisfaction-survey-data-from-airline-company-1"><span class="toc-section-number">15.2</span> Customer Satisfaction Survey Data from Airline Company</a></li>
<li><a href="#swine-disease-breakout-data-1"><span class="toc-section-number">15.3</span> Swine Disease Breakout Data</a></li>
</ul></li>
<li><a href="#references">References</a></li>
</ul>
<!--bookdown:toc2:end-->
      </nav>
    </div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i><a href="./">Introduction to Data Science</a>
          </h1>
        </div>

        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<!--bookdown:toc:end-->
<!--bookdown:body:start-->
<div id="preface" class="section level1 unnumbered">
<h1>Preface</h1>
<p>During the first couple years of our career as data scientists, we were bewildered by all kinds of data science hype. There is a lack of definition of many basic terminologies such as “Big Data” and “Data Science.” How big is big? If someone ran into you asked what data science was all about, what would you tell them? What is the difference between the sexy role “Data Scientist” and the traditional “Data Analyst”? How suddenly came all kinds of machine algorithms? All those struck us as confusing and vague as real-world data scientists! But we always felt that there was something real there. After applying data science for many years, we explored it more and had a much better idea about data science. And this book is our endeavor to make data science to a more legitimate field.</p>
<div id="goal-of-the-book" class="section level2 unnumbered">
<h2>Goal of the Book</h2>
<p>This is an introductory book to data science with a specific focus on the application. Data Science is a cross-disciplinary subject involving hands-on experience and business problem-solving exposures. The majority of existing introduction books on data science are about the modeling techniques and the implementation of models using R or Python. However, they fail to introduce data science in a context of the industrial environment. Moreover, a crucial part, the art of data science in practice, is often missing. This book intends to fill the gap.</p>
<p>Some key features of this book are as follows:</p>
<ul>
<li><p>It is comprehensive. It covers not only technical skills but also soft skills and big data environment in the industry.</p></li>
<li><p>It is hands-on. We provide the data and repeatable R and Python code. You can repeat the analysis in the book using the data and code provided. We also suggest you perform the analyses with your data whenever possible. You can only learn data science by doing it!</p></li>
<li><p>It is based on context. We put methods in the context of industrial data science questions.</p></li>
<li><p>Where appropriate, we point you to more advanced materials on models to dive deeper</p></li>
</ul>
</div>
<div id="who-this-book-is-for" class="section level2 unnumbered">
<h2>Who This Book Is For</h2>
<p>Non-mathematical readers will appreciate the emphasis on problem-solving with real data across a wide variety of applications and the reproducibility of the companion R and python code.</p>
<p>Readers should know basic statistical ideas, such as correlation and linear regression analysis. While the text is biased against complex equations, a mathematical background is needed for advanced topics.</p>
</div>
<div id="what-this-book-covers" class="section level2 unnumbered">
<h2>What This Book Covers</h2>
<p>Based on industry experience, this book outlines the real world scenario and points out pitfalls data science practitioners should avoid. It also covers big data cloud platform and the art of data science such as soft skills. We use R as the main tool and provide code for both R and Python.</p>
</div>
<div id="conventions" class="section level2 unnumbered">
<h2>Conventions</h2>
</div>
<div id="acknowledgements" class="section level2 unnumbered">
<h2>Acknowledgements</h2>
</div>
</div>
<div id="about-the-authors" class="section level1 unnumbered">
<h1>About the Authors</h1>
<p><strong>Hui Lin</strong> is leading and building data science department at Netlify. Before Netlify, she was a Data Scientist at DuPont. She was a leader in the company of applying advanced data science to enhance Marketing and Sales Effectiveness. She provided data science leadership for a broad range of predictive analytics and market research analysis from 2013 to 2018. She is the co-founder of Central Iowa R User Group, blogger of scientistcafe.com and 2018 Program Chair of ASA Statistics in Marketing Section. She enjoys making analytics accessible to a broad audience and teaches tutorials and workshops for practitioners on data science (<a href="https://course2019.netlify.com/" class="uri">https://course2019.netlify.com/</a>). She holds MS and Ph.D in statistics from Iowa State University.</p>
<p><strong>Ming Li</strong> is currently a Senior Data Scientist at Amazon and an Adjunct Faculty of Department of Marketing and Business Analytics in Texas A&amp;M University - Commerce. He is the Chair of Quality &amp; Productivity Section of ASA for 2017. He was a Data Scientist at Walmart and a Statistical Leader at General Electric Global Research Center. He obtained his Ph.D. in Statistics from Iowa State University at 2010. With deep statistics background and a few years’ experience in data science, he has trained and mentored numerous junior data scientist with different background such as statistician, programmer, software developer, database administrator and business analyst. He is also an Instructor of Amazon’s internal Machine Learning University and was one of the key founding member of Walmart’s Analytics Rotational Program which bridges the skill gaps between new hires and productive data scientists.</p>
<!--chapter:end:index.rmd-->

</div>
<div id="introduction" class="section level1">
<h1><span class="header-section-number">1</span> Introduction</h1>
<p>Interest in data science is at an all-time high and has exploded in popularity in the last couple of years. Data scientists today are from various backgrounds. If someone ran into you ask what data science is all about, what would you tell them? It is not an easy question to answer. Data science is one of the areas that everyone is talking about, but no one can define.</p>
<p>Media has been hyping about “Data Science” “Big Data” and “Artificial Intelligence” over the past few years. I like this amusing statement from the internet:</p>
<blockquote>
<p>“When you’re fundraising, it’s AI. When you’re hiring, it’s ML. When you’re implementing, it’s logistic regression.”</p>
</blockquote>
<p>For outsiders, data science is whatever magic that can get useful information out of data. Everyone should have heard about big data. Data science trainees now need the skills to cope with such big data sets. What are those skills? You may hear about: Hadoop, a system using Map/Reduce to process large data sets distributed across a cluster of computers or about Spark, a system build atop Hadoop for speeding up the same by loading huge datasets into shared memory(RAM) across clusters. The new skills are for dealing with organizational artifacts of large-scale cluster computing but not for better solving the real problem. A lot of data means more tinkering with computers. After all, it isn’t the size of the data that’s important. It’s what you do with it. Your first reaction to all of this might be some combination of skepticism and confusion. We want to address this up front that: we had that exact reaction.</p>
<p>To declutter, let’s start from a brief history of data science. If you hit up the Google Trends website which shows search keyword information over time and check the term “data science,” you will find the history of data science goes back a little further than 2004. From the way media describes it, you may feel machine learning algorithms were just invented last month, and there was never “big” data before Google. That is not true. There are new and exciting developments of data science, but many of the techniques we are using are based on decades of work by statisticians, computer scientists, mathematicians and scientists of all types.</p>
<p>In the early 19th century when Legendre and Gauss came up the least squares method for linear regression, only physicists would use it to fit linear regression. Now, non-technical people can fit linear regressions using excel. In 1936 Fisher came up with linear discriminant analysis. In the 1940s, we had another widely used model – logistic regression. In the 1970s, Nelder and Wedderburn formulated “generalized linear model (GLM)” which:</p>
<blockquote>
<p>“generalized linear regression by allowing the linear model to be related to the response variable via a link function and by allowing the magnitude of the variance of each measurement to be a function of its predicted value.” [from Wikipedia]</p>
</blockquote>
<p>By the end of the 1970s, there was a range of analytical models and most of them were linear because computers were not powerful enough to fit non-linear model until the 1980s.</p>
<p>In 1984 Breiman et al<span class="citation">(al <a href="#ref-Breiman1984">1984</a>)</span>. introduced the classification and regression tree (CART) which is one of the oldest and most utilized classification and regression techniques. After that Ross Quinlan came up with more tree algorithms such as ID3, C4.5, and C5.0. In the 1990s, ensemble techniques (methods that combine many models’ predictions) began to appear. Bagging is a general approach that uses bootstrapping in conjunction with regression or classification model to construct an ensemble. Based on the ensemble idea, Breiman came up with random forest in 2001<span class="citation">(Breiman <a href="#ref-Breiman2001">2001</a><a href="#ref-Breiman2001">a</a>)</span>. In the same year, Leo Breiman published a paper “<a href="http://www2.math.uu.se/~thulin/mm/breiman.pdf">Statistical Modeling: The Two Cultures</a>” <span class="citation">(Breiman <a href="#ref-Breiman2001TwoCulture">2001</a><a href="#ref-Breiman2001TwoCulture">b</a>)</span> where he pointed out two cultures in the use of statistical modeling to get information from data:</p>
<ol style="list-style-type: decimal">
<li>Data is from a given stochastic data model<br />
</li>
<li>Data mechanism is unknown and people approach the data using algorithmic model</li>
</ol>
<p>Most of the classic statistical models are the first type. Black box models, such as random forest, GMB, and today’s buzz work deep learning are algorithmic modeling. As Breiman pointed out, those models can be used both on large complex data as a more accurate and informative alternative to data modeling on smaller data sets. Those algorithms have developed rapidly, however, in fields outside statistics. That is one of the most important reasons that statisticians are not the mainstream of today’s data science, both in theory and practice. Hence Python is catching up R as the most commonly used language in data science. It is due to the data scientists background rather than the language itself. Since 2000, the approaches to get information out of data have been shifting from traditional statistical models to a more diverse toolbox named machine learning.</p>
<p>What is the driving force behind the shifting trend? John Tukey identified four forces driving data analysis (there was no “data science” back to 1962):</p>
<ol style="list-style-type: decimal">
<li>The formal theories of math and statistics</li>
<li>Acceleration of developments in computers and display devices</li>
<li>The challenge, in many fields, of more and ever larger bodies of data</li>
<li>The emphasis on quantification in an ever wider variety of disciplines</li>
</ol>
<p>Tukey’s 1962 list is surprisingly modern. Let’s inspect those points in today’s context. People usually develop theories way before they find the applications. In the past 50 years, statisticians, mathematician, and computer scientists have been laying the theoretical groundwork for constructing “data science” today. The development of computers enables us to apply the algorithmic models (they can be very computationally expensive) and deliver results in a friendly and intuitive way. The striking transition to the internet of things generates vast amounts of commercial data. Industries have also sensed the value of exploiting that data. Data science seems certain to be a major preoccupation of commercial life in coming decades. All the four forces John identified exist today and have been driving data science.</p>
<p>Benefiting from the increasing availability of digitized information, and the possibility to distribute that through the internet, the toolbox and application have been expanding fast. Today, people apply data science in a plethora of areas including business, health, biology, social science, politics, etc. Now data science is everywhere. But what is today’s data science?</p>
<div id="blind-men-and-an-elephant" class="section level2">
<h2><span class="header-section-number">1.1</span> Blind men and an elephant</h2>
<p>There is a widely diffused Chinese parable (depending on where you are from, you may think it is a Japanese parable) which is about a group of blind men conceptualizing what the elephant is like by touching it:</p>
<blockquote>
<p>“…In the case of the first person, whose hand landed on the trunk, said: ‘This being is like a thick snake’. For another one whose hand reached its ear, it seemed like a kind of fan. As for another person, whose hand was upon its leg, said, the elephant is a pillar like a tree-trunk. The blind man who placed his hand upon its side said, ‘elephant is a wall’. Another who felt its tail described it as a rope. The last felt its tusk, stating the elephant is that which is hard, smooth and like a spear.” <a href="https://en.wikipedia.org/wiki/Blind_men_and_an_elephant">wikipedia</a></p>
</blockquote>
<p>Data science is the elephant. With the data science hype picking up stream, many professionals changed their titles to be “Data Scientist” without any of the necessary qualifications. Today’s data scientists have vastly different backgrounds, yet each one conceptualizes what the elephant is based on his/her own professional training and application area. And to make matters worse, most of us are not even fully aware of our own conceptualizations, much less the uniqueness of the experience from which they are derived. Here is a list of somewhat whimsical definitions for a “data scientist”:</p>
<ul>
<li>“A data scientist is a data analyst who lives in California”</li>
<li>“A data scientist is someone who is better at statistics than any software engineer and better at software engineering than any statistician.”</li>
<li>“A data scientist is a statistician who lives in San Francisco.”</li>
<li>“Data Science is statistics on a Mac.”</li>
</ul>
<blockquote>
<p>“We don’t see things as they are, we see them as we are. [by Anais Nin]”</p>
</blockquote>
<p>It is annoying but true. So the answer to the question “what is data science?” depends on who you are talking to. Who you may be talking to then? Data science has three main skill tracks: engineering, analysis, and modeling (and yes, the order matters!).</p>
<p>Here are some representative skills in each track. Different tracks and combinations of tracks will define different roles in data science.<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a></p>
<div id="data-science-roleskill-tracks" class="section level3">
<h3><span class="header-section-number">1.1.1</span> Data science role/skill tracks</h3>
<p>When people talk about all the machine learning and AI algorithms, they often over look the critical data engineering part that makes everything else possible. Data engineering is the unseen iceberg under the water surface. Think your company need a data scientist? You are wrong if you haven’t hired a data engineer yet. You need to have the ability to get data before making sense of it. If you only deal with small datasets, you may be able to get by with entering some numbers into a spreadsheet. As the data increasing in size, data engineering becomes a sophisticated discipline in its own right.</p>
<ul>
<li><strong>Engineering: the process of making everything else possible</strong></li>
</ul>
<p>Data engineering mainly involves in building the data pipeline infrastructure. In the (not that) old day, when data is stored on local servers, computers or other devices, building the data infrastructure can be a humongous IT project which involves not only the software but also the hardware that used to store the data and perform ETL process. As the development of cloud service, data storage and computing on the cloud becomes the new norm. Data engineering today at its core is software engineering. Ensuring maintainability through modular, well-commented code and version control is fundamental.</p>
<ol style="list-style-type: decimal">
<li>Data environment</li>
</ol>
<p>Design and set up the environment to support data science workflow. It may include setting up data storage in the cloud, Kafka platform, Hadoop and Spark cluster etc. Each company has its unique data condition and needs. So the environment will be different depending on size of the data, update frequency, complexity of analytics, compatibility with the backend infrastructure and (of course) budget.</p>
<ol start="2" style="list-style-type: decimal">
<li>Data management</li>
</ol>
<p>Automated data collection is a common task which includes parsing the logs (depending on the stage of the company and the type of industry you are in), web scraping, API queries, and interrogating data streams. Determine and construct data schema to support analytical and modeling need. Use tools, processes, guidelines to ensure data is correct, standardized and documented.</p>
<ol start="3" style="list-style-type: decimal">
<li>Production</li>
</ol>
<p>If you want to integrate the model or analysis into the production system, then you have to automate all data handling steps. It involves the whole pipeline from data access to preprocessing, modeling and final deployment. It is necessary to make the system work smoothly with all existing stacks. So it requires to monitor the system through some sort of robust measures, such as rigorous error handling, fault tolerance, and graceful degradation to make sure the system is running smoothly and the users are happy.</p>
<ul>
<li><strong>Analysis – the process of turning raw information into insights in a fast way</strong></li>
</ul>
<ol style="list-style-type: decimal">
<li>Domain knowledge</li>
</ol>
<p>Domain knowledge is the understanding of the organization or industry where you apply data science. You can’t make sense of data without context, such as what are the important metric for this kind of business, what are the business questions, what type of data they have and what the data represents, how to translate a business need to a data problem, what has been tried before and with what results, what are the accuracy-cost-time trade-offs, how can things fail, what other factors are not accounted, what are the reasonable assumptions and what are faulty. In the end, domain knowledge helps you to deliver the results in an audience-friendly way.</p>
<ol start="2" style="list-style-type: decimal">
<li>Exploratory analysis</li>
</ol>
<p>This type of analysis is about exploration and discovery. Rigor conclusion is not a concern which means the goal is to get insights driven by correlation not causation. The later one requires statistical skills and hence more expensive. Instead this role will help your team look at as much data as possible so that the decision-makers can get a sense of what’s worth further pursuing. It often involves different ways to slice and aggregate data. An important thing to note here is that you should be careful not to get conclusion beyond the data. You don’t need to write gorgeous, robust code to perform well in this role.</p>
<ol start="3" style="list-style-type: decimal">
<li>Story telling</li>
</ol>
<p>Storytelling with data is key to deliver the insights and drive better decision making. It is the art of telling people what the numbers actually signify. It usually requires data summarization, aggregation and visualization. It is important to answer the following questions before you begin down the path of creating a data story: * Who are your audience? * What do you want your audience to know or do? * How can you use data to help make your point?</p>
<ul>
<li><strong>Modeling – the process of diving deeper into the data to discover the pattern we don’t easily see</strong></li>
</ul>
<p>Even fancy machine learning model is the first thing comes to mind when people think about data science, unfortunately, in industry, it occupies the smallest part of data scientist’s time. Nevertheless, it is a powerful set of tools.</p>
<ol style="list-style-type: decimal">
<li>Supervised learning</li>
</ol>
<p>In supervised learning, each observation of the predictor measurement(s) corresponds to a response measurement. There are two flavors of supervised learning: regression and classification. In regression, the response is a real number such as the total net sales in 2017, or the yield of corn next year. The goal is to approximate the response measurement as much as possible. In classification, the response is a class label, such as dichotomous response such as yes/no. The response can also have more than two categories, such as four segments of customers. A supervised learning model is a function that maps some input variables with corresponding parameters to a response y. Modeling tuning is to adjust the value of parameters to make the mapping fit the given response. In other words, it is to minimize the discrepancy between given responses and the model output. When the response y is a real value, it is intuitive to define discrepancy as the squared difference between model output and given the response. When y is categorical, there are other ways to measure the difference, such as AUC or information gain.</p>
<ol start="2" style="list-style-type: decimal">
<li>Unsupervised learning</li>
</ol>
<p>In unsupervised learning, there is no response variable. For a long time, the machine learning community overlooked unsupervised learning except for one called clustering. Moreover, many researchers thought that clustering was the only form of unsupervised learning. One reason is that it is hard to define the goal of unsupervised learning explicitly. Unsupervised learning can be used to do the following: * Identify a good internal representation or pattern of the input that is useful for subsequent supervised or reinforcement learning, such as finding clusters. * It is a dimension reduction tool that is to provide compact, low dimensional representations of the input, such as factor analysis. * Provide a reduced number of uncorrelated learned features from original variables, such as principal component regression.</p>
<ol start="3" style="list-style-type: decimal">
<li>Customized model development</li>
</ol>
<p>In most of the cases, you just need to use the out of the box algorithms to solve the problem. But in some situations, there isn’t enough data to use machine learning model, or the question doesn’t fit neatly in the specifications of existing tools, or the model needs to incorporate some prior domain knowledge . You may need to develop new models to accommodate the subtleties of the problem at hand. For example, people use bayesian models to include domain knowledge as prior distribution.</p>
<p><strong>What others?</strong></p>
<p>There are some common skills to have regardless the role people have in data science.</p>
<ul>
<li><strong>Data Preprocessing: the process nobody wants to go through yet nobody can avoid</strong></li>
</ul>
<p>No matter what role you hold in data science team, you will have to do some data cleaning which tend not to be the favorite part of anyone’s job. Data preprocessing is the process of converting raw data into clean data that is proper for use.</p>
<ol style="list-style-type: decimal">
<li>Data preprocessing for data engineer</li>
</ol>
<p>Getting data together from different sources and dumping them to a Data Lake, a dumping ground of amorphous data, is far from the data schema analyst and scientist would use. A data lake is a storage repository that stores a vast amount of raw data in its native format, including XML, JSON, CSV, Parquet, etc. It is a data cesspool rather than data lake. It is data engineer’s job to get a clean schema out of the data lake by transforming and formatting the data. Some common problems to resolve are:</p>
<ul>
<li>Enforce new tables’ schema to be the desired one</li>
<li>Repair broken records in newly inserted data</li>
<li>Aggregate the data to form the tables with a proper granularity</li>
</ul>
<ol start="2" style="list-style-type: decimal">
<li>Data preprocessing for data analyst and scientist</li>
</ol>
<p>Not just for data engineer, it also occupies a large fraction of data analyst and scientist’s working hours too. A facility and a willingness to do these tasks are a prerequisite for a strong data scientist. If you are lucky as a data scientist, you may end up spending 50% of your time doing this. If you are like most of us, you will spend over 80% of your working hours wrangling data.</p>
<p>The data you get can still be very rough even it is from a nice and clean database that engineers set up. Dates and times are notorious for having many representations and time zone ambiguity. You may also get market survey responds from your clients in an excel file where the table title could be multi-line, or the format does not meet the requirements, such as using 50% to represent the percentage rather than 0.5. So in many cases, you need to set the data to be the right format before moving on to analysis.</p>
<p>Even the data is in the right format, there are other issues to solve before or during analysis. For example, variables can have missing values. Knowledge about the data collection process and what it will be used for is necessary to decide a way to handle the missing. Also, different models have different requirements on the data. For example, some model may require the variables are of consistent scale; some may be susceptible to outliers or collinearity, some may not be able to handle categorical variables and so on. The modeler has to preprocess the data to make it proper for the specific model.</p>
<p>Most of the people in data science today focus on one of the tracks. A small number of people are experts of two tracks. People that are proficient in all three? They are unicorns!</p>
<!--
## Data Pipeline Infrastructure

Data pipeline infrastructure is the ecosystem data science lives in. As someone with math/statistics background, it can be challenging to understand and get used to the infrastructure. 
-->
</div>
</div>
<div id="what-should-data-science-do" class="section level2">
<h2><span class="header-section-number">1.2</span> What should data science do?</h2>
<div id="lets-dream-big" class="section level3">
<h3><span class="header-section-number">1.2.1</span> Let’s dream big</h3>
<p>Here is my two points for the question:</p>
<ul>
<li>Make human better human by alleviating bounded rationality and minimize politics/emotion (rather than make machine more like human)</li>
<li>Strive for the “democratization” of data as legally possible: empower everyone in the organization to acquire, process, and leverage data in a timely and efficient fashion</li>
</ul>
<p>I know it is vague. Behold, I am going to explain more.</p>
<p>It’s easy to pretend that you are data driven. But if you get into the mindset to collect and measure everything you can, and think about what the data you’ve collected means, you’ll be ahead of most of the organizations that claim to be data driven. If you know the difference between “data driven” and “data confirmed”, you’ll be sailing at the right direction. What on earth is the difference?</p>
<p>Imagine that you are buying something online and you need to decide whether or not to trust the product without seeing it physically. You see the average rating is 4.1 out of 5.0. Is this a good score? It depends on your subconscious decision. If you really need the thing, you may happily cheer “It is more than 4.0!”. If you are still not sure whether you need it, you can’t help to check the few low rating reviews and tell yourself “look at those 1-star reviews”. Sounds familiar? Psychologists call it confirmation bias.</p>
<blockquote>
<p>Confirmation bias is the tendency to search for, interpret, favor, and recall information in a way that confirms one’s preexisting beliefs or hypotheses [Wikipedia]</p>
</blockquote>
<p>So if you use data to feel better (confirm) decisions/assumptions that are already made before you analyze the data, that is “data confirmed”. A clear sign of confirmation bias is when you go back to tinker the definition of your metic because the current result is not impressive. However, this bias is not always easy to see. It is not only misleading but also expensive. Because it could take data science team days of toil to boil everything down to that magic number and put the result on the report. Data scientists are not totally immune to the bias either. Good news is that there is antidote to confirmation bias.</p>
<p>Antidote 1: Do the brainstorming of data definition and set the goal in advance and resist temptation to move them later. In other words, the decision makers have to set decision criteria and the boundary up front in your data science project.</p>
<p>Antidote 2: Data democratization. Keep in mind that data isn’t just for the professionals or a small group of people in the organization that are “key decision makers”. Everyone should be able to get access to and look at the data (as much as legally possible). In that way, there will be more eyes on the decision.</p>
<p>The way data science can help is to provide a sound data framework and necessary training for the organization to access data with least amount of pain. Also be clear about the data definition and documentation. Data science holds the responsibility for data stewardship in the organization with high integrity. (there is data science for social good which is data science’s responsibility for outside the organization but we are not going to discuss that here)</p>
<p>That is still very abstract, I hear you. Now, Let’s be more specific…</p>
</div>
<div id="what-kind-of-questions-can-data-science-solve" class="section level3">
<h3><span class="header-section-number">1.2.2</span> What kind of questions can data science solve?</h3>
<div id="prerequisites" class="section level4">
<h4><span class="header-section-number">1.2.2.1</span> Prerequisites</h4>
<p>Data science is not a panacea and there are problems data science can’t help. It is best to make a judgment as early in the analytical cycle as possible. Tell your clients honestly and clearly when you think data analytics can’t give the answer they want. What kind of questions can data science solve?</p>
<ol style="list-style-type: decimal">
<li>Your question needs to be specific enough</li>
</ol>
<p>Look at two examples:</p>
<ul>
<li>Question 1: How can I increase product sales?</li>
<li>Question 2: Is the new promotional tool introduced at the beginning of this year boosting the annual sales of P1197 in Iowa and Wisconsin? (P1197 is an impressive corn seed product from DuPont Pioneer)</li>
</ul>
<p>It is easy to see the difference between the two questions. Question 1 is a grammatically correct question, but it is proper for data analysis to answer. Why? It is too general. What is the response variable here? Product sales? Which product? Is it annual sales or monthly sales? What are the candidate predictors? You nearly can’t get any useful information from the questions. In contrast, question 2 is much more specific. From the analysis point of view, the response variable is clearly “annual sales of P1197 in Iowa and Wisconsin”. Even we don’t know all the predictors, but the variable of interest is “the new promotional tool introduced early this year.” We want to study the impact of the promotion of sales. You can start from there and move on to figure out other variables need to include in the model by further communication.</p>
<p>As a data scientist, you may start with something general and unspecific like question 1 and eventually get to question 2. Effective communication and in-depth domain knowledge about the business problem are essential to convert a general business question into a solvable analytical problem. Domain knowledge helps data scientist communicate with the language the other people can understand and obtain the required information.</p>
<p>However, defining the question and variables involved won’t guarantee that you can answer it. For example, I encountered this situation with a well-defined supply chain problem. My client asked me to estimate the stock needed for a product in a particular area. Why can’t this question be answered? I tried fitting a Multivariate Adaptive Regression Spline (MARS) model and thought I found a reasonable solution. But it turned out later that the data my client gave me was inaccurate. In this case, only estimates rather than actual values of past supply figures were available and there was no way to get accurate data. The lesson lends itself to the next point.</p>
<ol start="2" style="list-style-type: decimal">
<li>You need to have sound and relevant data</li>
</ol>
<p>One cannot make a silk purse out of a sow’s ear. Data scientists need data, sound and relevant data. The supply problem is a case in point. There was relevant data, but not sound. All the later analytics based on that data was a building on sand. Of course, data nearly almost have noise, but it has to be in a certain range. Generally speaking, the accuracy requirement for the independent variables of interest and response variable is higher than others. In question 2, it is data related to the “new promotion” and “sales of P1197”.</p>
<p>The data has to be helpful for the question. If you want to predict which product consumers are most likely to buy in the next three months, you need to have historical purchasing data: the last buying time, the amount of invoice, coupons and so on. Information about customers’ credit card number, ID number, the email address is not going to help.</p>
<p>Often the quality of the data is more important than the quantity, but the quantity cannot be overlooked. In the premise of guaranteeing quality, usually the more data, the better. If you have a specific and reasonable question, also sound and relevant data, then congratulations, you can start playing data science!</p>
</div>
<div id="problem-type" class="section level4">
<h4><span class="header-section-number">1.2.2.2</span> Problem type</h4>
<p>Many of the data science books classify the various models from a technical point of view. Such as supervised vs. unsupervised models, linear vs. nonlinear models, parametric models vs. non-parametric models, and so on. Here we will continue on “problem-oriented” track. We first introduce different groups of real problems and then present which models can be used to answer the corresponding category of questions.</p>
<ol style="list-style-type: decimal">
<li>Description</li>
</ol>
<p>The basic analytic problem is to summarize and explore a data set with descriptive statistics (mean, standard deviation, and so forth) and visualization methods. It is the simplest problem and yet the most crucial and common one. You will need to describe and explore the dataset before moving on to more complex analysis. In the problem such as customer segmentation, after you cluster the sample, the next step is to figure out the profile of each class by comparing the descriptive statistics of the various variables. Questions of this kind are:</p>
<ul>
<li>How does the annual income distribute?</li>
<li>Are there outliers?</li>
<li>What are the mean active days of different accounts?</li>
</ul>
<p>Data description is often used to check data, find the appropriate data preprocessing method, and demonstrate the model results.</p>
<ol start="2" style="list-style-type: decimal">
<li>Comparison</li>
</ol>
<p>The first common problem is to compare different groups. Such as: Is A better in some way than B? Or more comparisons: Is there any difference among A, B, and C in a particular aspect? Here are some examples:</p>
<ul>
<li>Are males more inclined to buy our products than females?</li>
<li>Are there any differences in customer satisfaction in different business districts?</li>
<li>Do soybean carrying a particular gene have higher oil content?</li>
</ul>
<p>For those problems, it is usually to start exploring from the summary statistics and visualization by groups. After a preliminary visualization, you can test the differences between treatment and control group statistically. The commonly used statistical tests are chi-square test, t-test, and ANOVA. There are also methods using Bayesian methods. In biology industry, such as new drug development, crop breeding, mixed effect models are the dominant technique.</p>
<ol start="3" style="list-style-type: decimal">
<li>Clustering</li>
</ol>
<p>Clustering is a widespread problem, which is usually related to classification. Clustering answers questions like:</p>
<ul>
<li>Which customers have similar product preference?</li>
<li>Which printer performs a similar pattern to the broken ones?</li>
<li>How many different themes are there in the corpus?</li>
</ul>
<p>Note that clustering is unsupervised learning. The most common clustering algorithms include K-Means and Hierarchical Clustering.</p>
<ol start="4" style="list-style-type: decimal">
<li>Classification</li>
</ol>
<p>Usually, a labeled sample set is used as a training set to train the classifier. Then the classifier is used to predict the category of a future sample. Here are some example questions:</p>
<ul>
<li>Who is more likely to buy our product?</li>
<li>Is the borrower going to pay back?</li>
<li>Is it spam?</li>
</ul>
<p>There are hundreds of classifiers. In practice, we do not need to try all the models but several models that perform well generally.</p>
<ol start="5" style="list-style-type: decimal">
<li>Regression</li>
</ol>
<p>In general, regression deals with the problem of “how much is it?” and return a numerical answer. In some cases, it is necessary to coerce the model results to be 0, or round the result to the nearest integer. It is the most common problem.</p>
<ul>
<li>What will be the temperature tomorrow?</li>
<li>What is the projected net income for the next season?</li>
<li>How much inventory should we have?</li>
</ul>
</div>
</div>
</div>
<div id="structure-data-science-team" class="section level2">
<h2><span class="header-section-number">1.3</span> Structure data science team</h2>
<p>During the past decade, a huge amount of data has become available and readily accessible for analysis in many companies across different business sectors. The size, complexity, and speed of increment of data suddenly beyond the traditional scope of statistical analysis or BI reporting. To leverage the big data, do you need an internal data science team to be a core competency, or can you outsource it? The answer depends on the problems you want to solve using data. If the problems are critical to the business, you can’t afford to outsource it. Also, each company has its own business context and hence needs new kinds of data or or use the results in novel ways. Being a data driven organization requires cross organization commitments to identify what data each department needs to collect, establish the infrastructure and process for collecting and maintaining that data, and the way to deliver analytical results. Unfortunately, it is unlikely that an off-the-shelf solution will be flexible enough to adapt to the specific business context. So most of the companies establish their own data science team.</p>
<p>Where should data science team fit? Much has been written about different ways data science function fit in the organization. In general, data science team is organized in three ways.</p>
<ol style="list-style-type: decimal">
<li>A standalone team</li>
</ol>
<p>Data science is an autonomous unit that is parallel to the other organizations (such as engineering, product etc.) and the head of data science reports directly to senior leadership, ideally to the CEO or at least to someone who understands data strategy and is willing to invest to give it what it needs. The advantages of this type of data organization are:</p>
<ul>
<li>Data science team has autonomy and is well positioned to tackle whatever problems it deems important to the whole company.</li>
<li>It is advantageous for people in data science team to share knowledge and grow professionally.</li>
<li>It provides a clear career path for data science professionals and shows the company treats data as a first-class asset. So it tends to attract and retain top talent people.</li>
</ul>
<p>The biggest concern of this type of organization is the risk of marginalization. Data science only has value if data drives action which requires collaboration among data scientists, engineers, product managers and other business stakeholders across the organization. If you have a standalone data science team, it is critical to choose a data science leader who is knowledgable about the applications of data science in different areas and also has strong inter-discipline communication skills. The head of data science needs to build strong collaboration with other departments.</p>
<p>Also, as companies grow, each department prefers to be self-sufficient and tries to hire data own analytical personal under different titles even when they can get support from the data science team. This is why it is unlikely for an already mature company to have a standalone data science team. If you start your data science team in the early stage as a startup, it is important that the CEO sets a clear vision from the beginning and sends out strong message to the whole company about accessing data support.</p>
<ol start="2" style="list-style-type: decimal">
<li>An embedded model</li>
</ol>
<p>There is still a head of data science but his/her role is mostly a hiring manager and coach and he/she may report to a senior manager in IT department. The data science team brings in talented people and farms them out to the rest of the company. In other words, it gives up autonomy to ensure utility. The advantages are:</p>
<ul>
<li>Data science is closer to its applications.</li>
<li>There is still a data science group so it is easy to share knowledge.</li>
<li>It has high flexibility to allocate data science resource to the rest of the company.</li>
</ul>
<p>However, there are also concerns.</p>
<ul>
<li>It brings difficulty to the management since the lead of the designated team is not responsible for data science professionals’ growth and happiness while the data science managers are not directly vested in their work.</li>
<li>Data scientists are second-class citizens everywhere and it is hard to attract and retain top talent.</li>
</ul>
<ol start="3" style="list-style-type: decimal">
<li>Integrated team</li>
</ol>
<p>There is no data science team. Each team hires its own data science people. For example, there may be a marketing analytics group consisting of data engineer, data analyst and data scientists. The team leader is a marketing manager who has an analytical mind and deep business knowledge. The advantages are obvious.</p>
<ul>
<li>Data science resource aligns with the organization very well</li>
<li>Data science professionals are first-class members and valued in their own team. The manager is responsible for data science professionals’ growth and happiness.</li>
<li>The insights from data are easily put into actions.</li>
</ul>
<p>It works well in the short term for both the company and the data science hires. However, there are also many concerns.</p>
<ul>
<li>It sacrifices the professional growth of data science hires since they work in silos and specialize in specific application. It is also difficult to share knowledge across different applied areas.</li>
<li>It is harder to move people around since they are highly associated with a specific function in the organization.</li>
<li>There is no career path for data science people and so it is difficult to retain talent.</li>
</ul>
<p>There is not an universal answer for the best way to organize data science team. It depends on the answer of many other questions. How important do you think the data science team is for your company? What is the stage of your company when you start to build data science team? Are you a startup or a relatively mature company? Data science has its own skillset, workflow, tooling, integration process and culture. If it is critical to your organization, it is the best not to bury it under any part of the organization. Otherwise data science will inevitably only serve the need for specific branch of the organization and it also impedes data democratization across the organization. How valuable it is to use data to tell the truth, how dangerous it is to use data to affirm existing opinions. No matter which way you choose, be aware of both sides of the coin. If you are looking for a data science position, it is important to know where the data science team fits in the company.</p>
<!--chapter:end:01-Introduction.Rmd-->
</div>
</div>
<div id="soft-skills-for-data-scientists" class="section level1">
<h1><span class="header-section-number">2</span> Soft Skills for Data Scientists</h1>
<div id="comparison-between-statistician-and-data-scientist" class="section level2">
<h2><span class="header-section-number">2.1</span> Comparison between Statistician and Data Scientist</h2>
<p>Statistics as a scientific area can be traced back to 1749 and statistician as a career has been around for hundreds of years with well-established theory and application. Data Scientist becomes an attractive career for only a few years along with the fact that data size and variety beyond the traditional statistician’s toolbox and the fast-growing of computation power. Statistician and data scientist have a lot of in common, but there are also significant differences.</p>
<center>
<img src="images/softskill1.png" alt="Comparison of Statistician and Data Scientist" />
</center>
<p>Both statistician and data scientist work closely with data. For the traditional statistician, the data is usually well-formatted text files with numbers and labels. The size of the data usually can be fitted in a PC’s memory. Comparing to statisticians, data scientists need to deal with more varieties of data:</p>
<ul>
<li>well-formatted data stored in a database system with size much larger than a PC’s memory or hard-disk;</li>
<li>huge amount of verbatim text, voice, image, and video;</li>
<li>real-time streaming data and other types of records.</li>
</ul>
<p>One unique power of statistics is to make statistical inference based on a small set of data. Statisticians spend most of their time developing models and don’t need to put too much effort on data cleaning. Today, data is relatively abundant, and modeling is only part of the overall effort, often a small part. Due to the active development of some open source communities, fitting models is not too far from button pushing. Data scientists instead spend lot of time preprocessing and wrangling the data before feeding them to the model.</p>
<p>Different from statisticians, data scientists often focus on delivering actionable results and sometimes need to fit model on the cloud. The data can be too large to read in laptop. From the entire problem-solving cycle, statisticians are usually not well integrated with the production system where data is obtained in real time; while data scientists are more embedded in the production system and closer to the data generation procedures.</p>
</div>
<div id="beyond-data-and-analytics" class="section level2">
<h2><span class="header-section-number">2.2</span> Beyond Data and Analytics</h2>
<p>Data scientists usually have a good sense of data and analytics, but data scientist project is more than that. A data science project may involve people with different roles, especially in a big company:</p>
<ul>
<li>a business owner or leader to identify business value;</li>
<li>program manager to ensure the data science project fits into the overall technical program development and coordinate all parties to set periodical tasks so that the project meets the preset milestones and results;</li>
<li>data owner and computation resource and infrastructure owner from the IT department;</li>
<li>dedicated team to make sure the data and model are under model governance and privacy guidelines;</li>
<li>a team to implement, maintain and refresh the model;</li>
<li>multiple rounds of discussion of resource allocation among groups (i.e., who pay for the data science project).</li>
</ul>
<p>Effective communication and in-depth domain knowledge about the business problem are essential requirements for a successful data scientist. A data scientist may interact with people at various levels from senior leaders who set the corporate strategies to front-line employees who do the daily work. A data scientist needs to have the capability to view the problem from 10,000 feet above the ground, as well as down to the detail to the very bottom. To convert a business question into a data problem, a data scientist needs to communicate using the language the other people can understand and obtain the required information.</p>
<p>In the entire process of data science project defining, planning, executing and implementing, every step involves the data scientist to ensure people correctly define the business problem and reasonably evaluate the business value and success. Corporates are investing heavily in data science and machine learning with a very high expectation of return.</p>
<p>However, it is easy to set unrealistic goal and wrongly estimate the business impact. The data scientist lead should navigate the discussions to make sure the goal can be backed by data and analytics. Many data science projects over promise and are too optimistic on the timeline. These projects eventually fail by not delivering the preset business impact within the timeline. As data scientists, we need to identify these issues early in the stage and communicate with the entire team to make sure the project has a realistic deliverable and timeline. The data scientist team also need to work closely with data owners to identify relevant internal and external data source and evaluate the quality of the data; as well as working closely with the infrastructure team to understand the computation resources (i.e. hardware and software) available for the data science project.</p>
</div>
<div id="three-pillars-of-knowledge" class="section level2">
<h2><span class="header-section-number">2.3</span> Three Pillars of Knowledge</h2>
<ol style="list-style-type: decimal">
<li>Analytics knowledge and tool sets</li>
</ol>
<p>A successful data scientist needs to have a strong technical background in data mining, statistics and machine learning. The in-depth understanding of modeling with the insight about data enable a data scientist to convert a business problem to a data science problem.</p>
<ol start="2" style="list-style-type: decimal">
<li>Domain knowledge and collaboration</li>
</ol>
<p>A successful data scientist needs some domain knowledge to understand the business problem. For any data science project, the data scientist need to collaborate with other team members and effective communication and leadership skills are critical, especially when you are the only data person in the room and you need to decide with uncertainty.</p>
<ol start="3" style="list-style-type: decimal">
<li>(Big) data management and (new) IT skills</li>
</ol>
The last pillar is about computation environment and model implementation in a big data platform. This used to be the most difficult one for a data scientist with statistics background (i.e. lack computer science or programming skills). The good news is that with the rise of cloud computation big data platform, it is easier for a statistician to overcome this barrier.
<center>
<img src="images/softskill2.png" alt="Comparison of Statistician and Data Scientist" />
</center>
</div>
<div id="data-science-project-cycle" class="section level2">
<h2><span class="header-section-number">2.4</span> Data Science Project Cycle</h2>
<p>A data science project has various stages. Many textbooks and blogs focus on one or two specific stages and it is rare to see the end-to-end life cycle of data science projects. In fact, to get a good grasp of the end-to-end cycle requires many years of experience of doing real-world data science. We will share our opinions on that in this section. Seeing a holistic picture of the whole cycle helps you to better prepare for real-world applications.</p>
<div id="types-of-data-science-projects" class="section level3">
<h3><span class="header-section-number">2.4.1</span> Types of Data Science Projects</h3>
<p>People often use data science project to describe any project that uses data to solve a business problem, including traditional business analytics or data visualization. Here we limit our discussion of data science projects that involve data and some statistical or machine learning models. The business problem itself gives us the flavor of the project, data is the raw ingredient to start with, and the model makes the dish. Different types of data science projects can be determined by the types of data used and the final model development and implementation.</p>
<div id="offline-and-online-data" class="section level4">
<h4><span class="header-section-number">2.4.1.1</span> Offline and online Data</h4>
<p>There are offline and online data. Offline data are historical archived data stored in databases or data warehouses. With the development of data storage, the cost to store a large amount of data is cheap and offline data are very rich in general (for example website may track and store each individual user’s mouse position, click and typing information while the user is visiting the website). Offline data is usually stored in a distributed system and it can be extracted in batch as raw materials to create features that can be used in model training. Online data are real-time information that can be feed to models to make automatic actions. Real-time information can changes frequently such as the keywords a customer is searching for. Capturing and using real-time online data requires the integration of machine learning to the production infrastructure. It used to be a steep learning curve for data scientists, but the cloud infrastructure makes it much easier.</p>
</div>
<div id="offline-training-and-offline-application" class="section level4">
<h4><span class="header-section-number">2.4.1.2</span> Offline training and offline application</h4>
<p>This type of data science project is for a specific business problem which needs to be solved once or multiple times. But the dynamic nature of the business problem requires substantial work every time. One example of such a project is “whether a new workflow is going to improve efficiency.” In this situation, we often use offline internal and external data, build models, and deliver the final results as a report to answer the specific business question. It is similar to the traditional business intelligence project but with more focus on data and model. Sometimes the data size and model complexity are beyond the capacity of a single computer. So you need to use distributed storage and computation. Since the model is based on the historical data and the output is a report, there is no need for real-time execution. Usually, there is no run-time constraint on the machine learning model unless the model is running beyond a reasonable time frame such as a few hours or a few days. We can call this type of data science project “offline training, offline application” project.</p>
</div>
<div id="offline-training-and-online-application" class="section level4">
<h4><span class="header-section-number">2.4.1.3</span> Offline training and online application</h4>
<p>Another type of data science project is to use offline data for training and apply the trained model to real-time online data in the production environment. One example of such a project is “using historical data to train a personalized advertisement model, and then provides real-time ad recommendation when customers visit the website.” The model is trained based on offline data, and then use a customer’s online real-time data as features to run the model in real time to provide an automatic action. The model training is very similar to the “offline training, offline application” project, but as the trained model will be put to production, there are specific requirements such as features used in the offline training have to be available online in real time, and the online run-time of the model has to be short enough without impacting user experience. In most cases, data science projects in this category create continuous and scalable business value. We will use this type of data science project to describe the project cycle.</p>
</div>
<div id="online-training-and-online-application" class="section level4">
<h4><span class="header-section-number">2.4.1.4</span> Online training and online application</h4>
<p>For some business problems, it is so dynamic that even yesterday’s data is out of date. For such cases, we can use online data to train the model and then applying it in real time. We call this type of data science project “online training, online application.” This type of data science project requires high automation and low latency.</p>
</div>
</div>
<div id="at-the-planning-stage" class="section level3">
<h3><span class="header-section-number">2.4.2</span> At the Planning Stage</h3>
<p>To ensure a successful data science project, a data-driven and fact-based planning stage is essential. With the recent big data and data science hype, there is a high demand for data science projects to create business value across different business sectors. Often times, these data science project proposals are initiated by the leaders of an organization. This top-down style data science projects usually have high visibility with certain human and computation resources pre-allocated. However, it is crucial to understand the business problem first and align the goal across different teams including</p>
<ol style="list-style-type: decimal">
<li><p>the business team which may include members from the business operation team, business analyst, insight and reporting team;</p></li>
<li><p>technology team which may include members from database and data warehouse team, data engineering team, infrastructure team, core machine learning team, and software development team; (3) project management team which may include program management team and product management team depending on the scope of the data science project.</p></li>
</ol>
<p>To start the conversation, we can ask the following questions to everyone in the team:</p>
<ul>
<li>What are the pain points in current business operation?</li>
<li>What data are available and how is the quality and quantity of the data?</li>
<li>What might be the most significant impacts of a data science project?</li>
<li>Are there any negative impact to other teams?</li>
<li>What computation resources are available for model training and model execution?</li>
<li>Can we define key metrics to compare and quantity business value?</li>
<li>Are there any data security, privacy and legal concerns?</li>
<li>What are the desired milestones, check points and timeline?</li>
<li>Is the final application online or offline?</li>
<li>Are the data online or offline?</li>
</ul>
<p>It is likely to have a series of intense meetings and heated discussions to frame the project to a reasonable scope. After the planning stage, we should be able to define a set of key metrics related to the project, identify some offline and online data sources, request needed computation resources, draft tentative timeline and milestones, and form a team of data scientist, data engineer, software developer, project manager and members from business operation. Data scientists should play a major role in these discussions. If data scientist is not leading the data science project formulation, it is very likely the entire project will not reach the timeline and milestones.</p>
</div>
<div id="at-the-modeling-stage" class="section level3">
<h3><span class="header-section-number">2.4.3</span> At the Modeling Stage</h3>
<p>Even though at the planning stage we already set some strategy, milestone, and timeline, data science projects are dynamic in nature and there could be uncertainties along the road. As a data scientist, clearly communicate any newly encountered difficulties during the modeling stage to the entire team is essential to keep the data science project progress. With the available data source identified at the planning stage, data clearing, data wrangling, and exploratory data analysis are great starting points toward modeling. Meanwhile, abstracting the business problem to be a set of statistical and machine learning problems is an iterative process. It is rare that business problems can be solved by using just one statistical or machine learning model. The ability to use a sequence of methods to decompose the business problem is one of the key responsibility for a senior data scientist. The process requires iterative rounds of discussions with the business team and data engineering team based on the new learning from each iteration. Each iteration includes both data related and model related part.</p>
<div id="data-related" class="section level4">
<h4><span class="header-section-number">2.4.3.1</span> Data related</h4>
<p>Data cleaning, data preprocessing and feature engineering are closely related procedures. The goal of these data-related procedures is to create usable variables or features for statistical and machine learning models. One important aspect of data related procedures is to make sure the data source we are using is a good representation of the situation where the final trained model will be applied. The exact same representation is rarely possible, and reasonable approximation is totally fine to start with. A data scientist has to be clear on the assumptions and communicate with the entire team the limitations of biased data and quantify its impact on the application. In data related part, sometimes the available data is not that relevant to the business problem we want to solve, and we have to collect more data.</p>
</div>
<div id="model-related" class="section level4">
<h4><span class="header-section-number">2.4.3.2</span> Model related</h4>
<p>There are different types of statistical and machine learning models, such as supervised learning, unsupervised learning, and causal inference. For each type, there are various algorithms, libraries, or packages readily available. To solve a business problem, you sometimes need to piece together a few methods at the model exploring and developing stage. This stage also includes model training, validation, and testing to make sure the model works well in the production environment; i.e., it is not overfitting and can be generalized. The model selection follows Occam’s razor, which is to choose the simplest among a set of compatible models. Before you try complicated models, it is a good practice to get some benchmark by additional business rules, common sense decision, or standard models (such as random forest for classification).</p>
</div>
</div>
<div id="at-the-production-stage" class="section level3">
<h3><span class="header-section-number">2.4.4</span> At the Production Stage</h3>
<p>For offline application data science projects, the end product is often a detailed report with model result and output. However, for online application projects, a trained model is just halfway from the finish line. The offline data is stored and processed in a totally different environment from the online production environment. Building the online data pipeline and implementing machine learning models in a production environment requires lots of additional work. Even though recent advance in cloud infrastructure lowers the barrier dramatically, it still takes effort to implement an offline model in the online production system. Before you promote the model to production, there are two more steps to go:</p>
<ol style="list-style-type: decimal">
<li>shadow mode</li>
<li>A/B testing</li>
</ol>
<p>A <strong>shadow mode</strong> is like an observation period when the data pipeline and machine learning models run as it is fully functional, but we only record the model output without any actions. Some people call it proof of concept (POC). During POC, people frequently check the data pipeline and model and detect bugs such as a timeout or missing features, version conflict (for example python 2 v.s. python 3), data type mismatch, etc.</p>
<p>Once the online model passes the shadow mode, <strong>A/B testing</strong> is the next stage. During A/B testing, all the incoming observations are randomly separated into two groups: control and treatment. The control group is going to skip the machine learning model, while the treatment group is going through the machine learning model. After that, people monitor a list of pre-defined key metrics during a specific time period to compare the control and treatment groups. The differences in these key metrics determine whether the machine learning model provides business value or not. Real applications can be complicated. For example, there can be multiple treatment groups, or hundreds, even thousands of A/B testing running by different teams at any given time.</p>
<p>Once the A/B testing shows that the model provides significant business value, then you can put it into full production. It is ideal that the model runs as expected and continues to provide scalable values. However, the business can change and a machine learning model works now can break tomorrow, and features available now may not be available tomorrow. You need a monitoring system to automatically notify us when one or multiple features change. When the model performance degrades below a pre-defined a level, you need to fine-tune the parameters and thresholds, re-train the model with more recent data, add or remove features to improve model performance. Eventually, any model will fail or retire at some time.</p>
</div>
<div id="summary" class="section level3">
<h3><span class="header-section-number">2.4.5</span> Summary</h3>
<p>Data science end-to-end project cycle is a complicated process which requires close collaboration among many teams. Data scientist, maybe the only scientist in the team, has to lead the planning discussion and model development based on data available and clearly communicate key assumptions and uncertainties with the entire team. A data science project may fail at any stage, and a clear end-to-end cycle view of the project helps avoid some mistakes.</p>
</div>
</div>
<div id="common-mistakes-in-data-science" class="section level2">
<h2><span class="header-section-number">2.5</span> Common Mistakes in Data Science</h2>
<p>Data science project can go wrong at different stages in many ways. Most textbooks and online blogs focus on technical mistakes about machine learning model, algorithm or theory, such as including outliers and overfitting. It is important to avoid these technical mistakes. However, there are common systematic mistakes across data science projects that are rarely discussed in textbooks. To summarize these mistakes, people need to do real-world data science projects. In this section, we describe these common mistakes in detail so that readers can proactively identify and avoid these systematic mistakes in their own data science projects.</p>
<div id="problem-formulation-stage" class="section level3">
<h3><span class="header-section-number">2.5.1</span> Problem Formulation Stage</h3>
<p>The most challenging part of a data science project is problem formulation. Data science project stems from pain points of the business. The draft version of the goal of the project is relatively vague without much quantification or is the gut feeling of the leadership team. Often there are multiple teams involved in the initial project formulation stage and they have different views. It is easy to have malalignment across different teams such as resource allocation, milestone deliverable, and timeline. At the problem formulation stage, data science team members with technical background sometimes are not even invited to the initial discussion. It sounds ridiculous, but sadly true that a lot of resources are spent on <strong>solving the wrong problem,</strong> the number one systematic common mistake in data science. Formulating a business problem into the right data science project requires an in-depth understanding of the business context, data availability and quality, computation infrastructure, and methodology to leverage the data to quantify business value.</p>
<p>We have seen people over promise about business value all the time, another common mistake that is going to fail the project at the beginning. With the hype of big data and machine learning, leaders across industries often have unrealistic high expectation on data science. It is especially true during enterprise transformation when there is a strong push to adopt new technology to get value out of the data. The unrealistic expectations are based on assumptions that are way off chart without checking the data availability, data quality, computation resource, and current best practices in the field. Even there is some exploratory analysis by the data science team at the problem formulation stage, project leaders sometimes ignore their data-driven voice.</p>
<p>These two systematic mistakes undermine the organization’s data science strategy. The higher the expectation, the bigger the disappointment when the project cannot deliver business value. Data and business context are essential to formulate the business problem and set reachable business value. It helps to avoid the mistakes by having a strong data science leader with a broad technical background and let data scientist coordinate and drive the problem formulation and set realistic goals based data and business context.</p>
</div>
<div id="problem-planning-stage" class="section level3">
<h3><span class="header-section-number">2.5.2</span> Problem Planning Stage</h3>
<p>Now suppose the data science project is formulated correctly with a reasonable expectation on the business value. The next step is to plan the project such as allocating resources, setting up milestones and timeline, and defining deliverable. In most cases, there are project managers to coordinate different teams that are involved in the project and use agile project management tools similar to those in software development. Unfortunately, the project management team may not have experience with data science projects and hence fail to account for the uncertainties at the planning stage. The fundamental difference between data science projects and other projects lead to another common mistake: <strong>too optimistic about the timeline</strong>. For example, data exploratory and preparation may take 60% to 80% of the total time for a given data science project, but people often don’t realize that.</p>
<p>When there are lots of data already collected across the organization, people assume you have enough data for everything. It leads to the mistake: t<strong>oo optimistic about data availability and quality</strong>. What you need is not “big data”, but data that can help you solve the problem. The data available may be low quality and you need to put substantial efforts to clean the data before you can use it. There are “unexpected” efforts to bring the right and relevant data for a specific data science project. To ensure smooth delivery of data science projects, you need to account for the “unexpected” work at the planning stage. We all know data pre-processing and feature engineering is usually the most time-consuming part of a data science project. However, people outside data science are not aware of it and we need to educate other team members and the leadership team.</p>
</div>
<div id="modeling-stage" class="section level3">
<h3><span class="header-section-number">2.5.3</span> Modeling Stage</h3>
<p>Finally, you start to look at the data and fit some models. One common mistake at this stage is unrepresentative data. The model trained using historical data may not generalize to the future. There is always a problem of biased or unrepresentative data. As a data scientist, we need to use data that are closer to the situation where the model is going to apply and quantify the impact of model output in production. Another mistake at this stage is overfitting and obsession for complicated models. Now we can easily get hundreds or even thousands of features and the machine learning models are getting more complicated. People can use open source libraries to try all kinds of models. People are sometimes obsessed with complicated models instead of using the simplest among a set of compatible models.</p>
<p>The data used to build the models is always biased or unrepresentative to some extent, simpler models are better to generalize and it has a higher chance to provide consistent business value once the model passes the test and is finally implemented in the production environment. It is possible that you can not use the existing data and methods to solve the business problem. You can try to collect more data, do feature engineering, or create your own models. However, if there is a fundamental gap between data and the business problem, the data scientist has to make the tough decision to unplug the project. On the other hand, data science projects usually have high visibility and may be initiated by senior leadership. Even the data science team provide enough evidence that they can’t deliver the expected business value, people may not want to stop the project which leads another common mistake at modeling stage: <strong>take too long to fail</strong>. The earlier we can stop a failing project, the better. Because we can put valuable resources to other promising projects. It damages the data science strategy and everyone will be hurt by a long data science project that is doomed to fail.</p>
</div>
<div id="production-stage" class="section level3">
<h3><span class="header-section-number">2.5.4</span> Production Stage</h3>
<p>Now suppose you have found a model that works great for the training and testing data. If it is an online application, you are halfway. The next is to put the model in production, which sounds like alien work for a data scientist. It is true that the data engineering team can help with model production. However, as a data scientist, you need to know the potential mistakes at this stage. One big mistake is <strong>missing A/B testing</strong> and assuming that the model performance at model training/testing stays the same in the production environment. Unfortunately, the model trained and evaluated using historical data nearly never performs the same in the production environment. The data used in the offline training maybe significant different from online data and the business context may have changed. If possible, machine learning models in production should always go through A/B testing to evaluate performance.</p>
<p>In the model training stage, people usually focus on model performance, such as accuracy without paying too much attention to the model execution time. When a model runs online in real time, the total run time for each instance (i.e., model latency) should not impact the customer’s user experience. Nobody wants to wait for even one second to see the results after click the “Search” button. In the production stage, feature availability is crucial to run a real-time model. Engineering resources are essential for model production. However, in traditional companies, it is common that a data science project <strong>fail to scale in real time applications</strong> due to lack of computation capacity, engineering resources, or non-tech culture and environment.</p>
<p>As the business problem evolve rapidly, the data and model in the production environment need to change accordingly or the performance of the model deteriorates over time. The online production environment is more complicated than model training and testing, for example, you pull online features from different resources, and some features may be missing at a specific time; the model may run into time out zone, and there are tons of different software and data exceptions that may happen. We need regular checkup during the entire life of the model cycle from implementation to retirement. Unfortunately, people often don’t set the monitoring system for data science projects, and it is another common mistake: <strong>missing necessary online checkup</strong>. It is essential to set a monitoring dashboard and automatic alarms, create model tuning, re-training, and retirement plans.</p>
</div>
<div id="summary-1" class="section level3">
<h3><span class="header-section-number">2.5.5</span> Summary</h3>
<p>The data science project is a combination of art and engineering. A data science project may fail in different ways. However, if we put data and business context at the center of the project, get familiar with the data science project cycle and proactively identify and avoid these potential mistakes, the data science project can provide significant business value. Here is the summary of the mistakes:</p>
<ul>
<li>Solving the wrong problem</li>
<li>Over promise on business value</li>
<li>Too optimistic about the timeline</li>
<li>Too optimistic about data availability and quality</li>
<li>Unrepresentative data</li>
<li>Overfitting and obsession for complicated models</li>
<li>Take too long to fail</li>
<li>Missing A/B testing</li>
<li>Fail to scale in real-time applications</li>
<li>Missing necessary online checkup</li>
</ul>
<!--chapter:end:02-SoftSkills.Rmd-->
</div>
</div>
</div>
<div id="introduction-to-the-data" class="section level1">
<h1><span class="header-section-number">3</span> Introduction to the data</h1>
<p>Before tackling analytics problem, we start by introducing data to be analyzed in later chapters.</p>
<div id="customer-data-for-clothing-company" class="section level2">
<h2><span class="header-section-number">3.1</span> Customer Data for Clothing Company</h2>
<p>Our first data set represents customers of a clothing company who sells products in physical stores and online. This data is typical of what one might get from a company’s marketing data base (the data base will have more data than the one we show here). This data includes 1000 customers:</p>
<ol style="list-style-type: decimal">
<li>Demography
<ul>
<li><code>age</code>: age of the respondent</li>
<li><code>gender</code>: male/female</li>
<li><code>house</code>: 0/1 variable indicating if the customer owns a house or not</li>
</ul></li>
<li>Sales in the past year
<ul>
<li><code>store_exp</code>: expense in store</li>
<li><code>online_exp</code>: expense online</li>
<li><code>store_trans</code>: times of store purchase</li>
<li><code>online_trans</code>: times of online purchase</li>
</ul></li>
<li>Survey on product preference</li>
</ol>
<p>It is common for companies to survey their customers and draw insights to guide future marketing activities. The survey is as below:</p>
<p>How strongly do you agree or disagree with the following statements:</p>
<ol style="list-style-type: decimal">
<li>Strong disagree</li>
<li>Disagree</li>
<li>Neither agree nor disagree</li>
<li>Agree</li>
<li>Strongly agree</li>
</ol>
<ul>
<li>Q1. I like to buy clothes from different brands</li>
<li>Q2. I buy almost all my clothes from some of my favorite brands</li>
<li>Q3. I like to buy premium brands</li>
<li>Q4. Quality is the most important factor in my purchasing decision</li>
<li>Q5. Style is the most important factor in my purchasing decision</li>
<li>Q6. I prefer to buy clothes in store</li>
<li>Q7. I prefer to buy clothes online</li>
<li>Q8. Price is important</li>
<li>Q9. I like to try different styles</li>
<li>Q10. I like to make decision myself and don’t need too much of others’ suggestions</li>
</ul>
<p>There are 4 segments of customers:</p>
<ol style="list-style-type: decimal">
<li>Price</li>
<li>Conspicuous</li>
<li>Quality</li>
<li>Style</li>
</ol>
<p>Let’s check it:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">str</span>(sim.dat,<span class="dt">vec.len=</span><span class="dv">3</span>)</code></pre></div>
<pre><code>## &#39;data.frame&#39;:    1000 obs. of  19 variables:
##  $ age         : int  57 63 59 60 51 59 57 57 ...
##  $ gender      : Factor w/ 2 levels &quot;Female&quot;,&quot;Male&quot;: 1 1 2 2 2 2 2 2 ...
##  $ income      : num  120963 122008 114202 113616 ...
##  $ house       : Factor w/ 2 levels &quot;No&quot;,&quot;Yes&quot;: 2 2 2 2 2 2 2 2 ...
##  $ store_exp   : num  529 478 491 348 ...
##  $ online_exp  : num  304 110 279 142 ...
##  $ store_trans : int  2 4 7 10 4 4 5 11 ...
##  $ online_trans: int  2 2 2 2 4 5 3 5 ...
##  $ Q1          : int  4 4 5 5 4 4 4 5 ...
##  $ Q2          : int  2 1 2 2 1 2 1 2 ...
##  $ Q3          : int  1 1 1 1 1 1 1 1 ...
##  $ Q4          : int  2 2 2 3 3 2 2 3 ...
##  $ Q5          : int  1 1 1 1 1 1 1 1 ...
##  $ Q6          : int  4 4 4 4 4 4 4 4 ...
##  $ Q7          : int  1 1 1 1 1 1 1 1 ...
##  $ Q8          : int  4 4 4 4 4 4 4 4 ...
##  $ Q9          : int  2 1 1 2 2 1 1 2 ...
##  $ Q10         : int  4 4 4 4 4 4 4 4 ...
##  $ segment     : Factor w/ 4 levels &quot;Conspicuous&quot;,..: 2 2 2 2 2 2 2 2 ...</code></pre>
<p>Refer to Appendix for the simulation code.</p>
</div>
<div id="customer-satisfaction-survey-data-from-airline-company" class="section level2">
<h2><span class="header-section-number">3.2</span> Customer Satisfaction Survey Data from Airline Company</h2>
<p>This data set is from a customer satisfaction survey for three airline companies. There are <code>N=1000</code> respondents and 15 questions. The market researcher asked respondents to recall the experience with different airline companies and assign a score (1-9) to each airline company for all the 15 questions. The higher the score, the more satisfied the customer to the specific item. The 15 questions are of 4 types (the variable names are in the parentheses):</p>
<ul>
<li>How satisfied are you with our______?</li>
</ul>
<ol style="list-style-type: decimal">
<li>Ticketing
<ul>
<li>Ease of making reservation（Easy_Reservation）</li>
<li>Availability of preferred seats（Preferred_Seats）</li>
<li>Variety of flight options（Flight_Options）</li>
<li>Ticket prices（Ticket_Prices）</li>
</ul></li>
<li>Aircraft
<ul>
<li>Seat comfort（Seat_Comfort）</li>
<li>Roominess of seat area（Seat_Roominess）</li>
<li>Availability of Overhead（Overhead_Storage）</li>
<li>Cleanliness of aircraft（Clean_Aircraft）</li>
</ul></li>
<li>Service
<ul>
<li>Courtesy of flight attendant（Courtesy）</li>
<li>Friendliness（Friendliness）</li>
<li>Helpfulness（Helpfulness）</li>
<li>Food and drinks（Service）</li>
</ul></li>
<li>General
<ul>
<li>Overall satisfaction（Satisfaction）</li>
<li>Purchase again（Fly_Again）</li>
<li>Willingness to recommend（Recommend）</li>
</ul></li>
</ol>
<p>Now check the data frame we have:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">str</span>(rating,<span class="dt">vec.len=</span><span class="dv">3</span>)</code></pre></div>
<pre><code>## &#39;data.frame&#39;:    3000 obs. of  17 variables:
##  $ Easy_Reservation: int  6 5 6 5 4 5 6 4 ...
##  $ Preferred_Seats : int  5 7 6 6 5 6 6 6 ...
##  $ Flight_Options  : int  4 7 5 5 3 4 6 3 ...
##  $ Ticket_Prices   : int  5 6 6 5 6 5 5 5 ...
##  $ Seat_Comfort    : int  5 6 7 7 6 6 6 4 ...
##  $ Seat_Roominess  : int  7 8 6 8 7 8 6 5 ...
##  $ Overhead_Storage: int  5 5 7 6 5 4 4 4 ...
##  $ Clean_Aircraft  : int  7 6 7 7 7 7 6 4 ...
##  $ Courtesy        : int  5 6 6 4 2 5 5 4 ...
##  $ Friendliness    : int  4 6 6 6 3 4 5 5 ...
##  $ Helpfulness     : int  6 5 6 4 4 5 5 4 ...
##  $ Service         : int  6 5 6 5 3 5 5 5 ...
##  $ Satisfaction    : int  6 7 7 5 4 6 5 5 ...
##  $ Fly_Again       : int  6 6 6 7 4 5 3 4 ...
##  $ Recommend       : int  3 6 5 5 4 5 6 5 ...
##  $ ID              : int  1 2 3 4 5 6 7 8 ...
##  $ Airline         : Factor w/ 3 levels &quot;AirlineCo.1&quot;,..: 1 1 1 1 1 1 1 1 ...</code></pre>
<p>Refer to Appendix for the simulation code.</p>
</div>
<div id="swine-disease-breakout-data" class="section level2">
<h2><span class="header-section-number">3.3</span> Swine Disease Breakout Data</h2>
<p>The swine disease data includes simulated 120 survey questions from 800 farms. There are three choices for each question. The outbreak status for the <span class="math inline">\(i^{th}\)</span> farm is generated from a <span class="math inline">\(Bernoulli(1, p_i)\)</span> distribution with <span class="math inline">\(p_i\)</span> being a function of the question answers:</p>
<p><span class="math display">\[ln(\frac{p_i}{1-p_i})=\beta_0 + \Sigma_{g=1}^G\mathbf{x_{i,g}^T\beta_{g}}\]</span></p>
<p>where <span class="math inline">\(\beta_0\)</span> is the intercept, <span class="math inline">\(\mathbf{x_{i,g}}\)</span> is a three-dimensional indication vector for question answer and <span class="math inline">\(\mathbf(\beta_g)\)</span> is the parameter vector corresponding to the <span class="math inline">\(g^{th}\)</span> predictor. Three types of questions are considered regarding their effects on the outcome. The first forty survey questions are important questions such that the coefficients of the three answers to these questions are all different:</p>
<p><span class="math display">\[\mathbf{\beta_g}=(1,0,-1)\times \gamma,\ g=1,\dots,40\]</span></p>
<p>The second forty survey questions are also important questions but only one answer has a coefficient that is different from the other two answers:</p>
<p><span class="math display">\[\mathbf{\beta_g}=(1,0,0)\times \gamma,\ g=41,\dots,80\]</span></p>
<p>The last forty survey questions are also unimportant questions such that all three answers have the same coefficients:</p>
<p><span class="math display">\[\mathbf{\beta_g}=(0,0,0)\times \gamma,\ g=81,\dots,120\]</span></p>
<p>The baseline coefficient <span class="math inline">\(\beta_0\)</span> is set to be <span class="math inline">\(-\frac{40}{3}\gamma\)</span> so that on average a farm have 50% of chance to have an outbreak. The parameter <span class="math inline">\(\gamma\)</span> in the above simulation is set to control the strength of the questions’ effect on the outcome. In this simulation study, we consider the situations where <span class="math inline">\(\gamma = 0.1, 0.25, 0.5, 1, 2\)</span>. So the parameter settings are:</p>
<p><span class="math display">\[\mathbf{\beta^{T}}=\left(\underset{question\ 1}{\frac{40}{3},\underbrace{1,0,-1}},...,\underset{question\ 40}{\underbrace{1,0,-1}},\underset{question\ 41}{\underbrace{1,0,0}},...,\underset{question\ 80}{\underbrace{1,0,0}},\underset{question\ 81}{\underbrace{0,0,0}},...,\underset{question\ 120}{\underbrace{0,0,0}}\right)*\gamma\]</span></p>
<p>For each value of <span class="math inline">\(\gamma\)</span>, 20 data sets are simulated. The bigger <span class="math inline">\(\gamma\)</span> is, the larger the corresponding parameter. We provided the data sets with <span class="math inline">\(\gamma = 2\)</span>. Let’s check the data:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">disease_dat&lt;-<span class="kw">read.csv</span>(<span class="st">&quot;http://bit.ly/2KXb1Qi&quot;</span>)
<span class="co"># only show the last 7 columns here</span>
<span class="kw">head</span>(<span class="kw">subset</span>(disease_dat,<span class="dt">select=</span><span class="kw">c</span>(<span class="st">&quot;Q118.A&quot;</span>,<span class="st">&quot;Q118.B&quot;</span>,<span class="st">&quot;Q119.A&quot;</span>,
                                 <span class="st">&quot;Q119.B&quot;</span>,<span class="st">&quot;Q120.A&quot;</span>,<span class="st">&quot;Q120.B&quot;</span>,<span class="st">&quot;y&quot;</span>))) </code></pre></div>
<pre><code>##   Q118.A Q118.B Q119.A Q119.B Q120.A Q120.B y
## 1      1      0      0      0      0      1 1
## 2      0      1      0      1      0      0 1
## 3      1      0      0      0      1      0 1
## 4      1      0      0      0      0      1 1
## 5      1      0      0      0      1      0 0
## 6      1      0      0      1      1      0 1</code></pre>
<p>Here <code>y</code> indicates the outbreak situation of the farms. <code>y=1</code> means there is an outbreak in 5 years after the survey. The rest columns indicate survey responses. For example <code>Q120.A = 1</code> means the respondent chose <code>A</code> in Q120. We consider <code>C</code> as the baseline.</p>
<p>Refer to Appendix for the simulation code.</p>
</div>
<div id="mnist-dataset" class="section level2">
<h2><span class="header-section-number">3.4</span> MNIST Dataset</h2>
<p>The MNIST dataset is a popular dataset for image classification machine learning model tutorials. It is conveniently included in the Keras library and ready to be loaded with build-in functions for analysis. The WIKI page of MNIST provides a detailed description of the dataset: <a href="https://en.wikipedia.org/wiki/MNIST_database" class="uri">https://en.wikipedia.org/wiki/MNIST_database</a>. It contains 70,000 images of handwritten digits from American Census Bureau employees and American high school students. There are 60,000 training images and 10,000 testing images. Each image has a resolution of 28x28, and the numerical pixel values are in greyscale. Each image is represented by a 28x28 matrix with each element of the matrix an integer between 0 and 255. The label of each image is the intended digit of the handwritten image between 0 and 9. We cover the detailed steps to explore the MNIST dataset in the R and Python notebooks. A sample of the dataset is illustrated in the Figure below:</p>
<div class="figure">
<img src="https://upload.wikimedia.org/wikipedia/commons/2/27/MnistExamples.png" alt="Sample of MNIST dataset (https://en.wikipedia.org/wiki/File:MnistExamples.png)" style="width:70.0%" />
<p class="caption">Sample of MNIST dataset (<a href="https://en.wikipedia.org/wiki/File:MnistExamples.png" class="uri">https://en.wikipedia.org/wiki/File:MnistExamples.png</a>)</p>
</div>
</div>
<div id="imdb-dataset" class="section level2">
<h2><span class="header-section-number">3.5</span> IMDB Dataset</h2>
<p>The IMDB dataset (<a href="http://ai.stanford.edu/~amaas/data/sentiment/" class="uri">http://ai.stanford.edu/~amaas/data/sentiment/</a>) is a popular dataset for text and language-related machine learning tutorials. It is also conveniently included in the Keras library, and there are a few build-in functions in Keras for data loading and pre-processing. It contains 50,000 movie reviews (25,000 in training and 25,000 in testing) from IMDB, as well as each movie review’s binary sentiment: positive or negative. The raw data contains the text of each movie review, and it has to be pre-processed before being fitted with any machine learning models. By using Keras’s built-in functions, we can easily get the processed dataset (i.e., a numerical data frame) for machine learning algorithms. Keras’ build-in functions perform the following tasks to convert the raw review text into a data frame:</p>
<ol style="list-style-type: decimal">
<li>Convert text data into numerical data. Machine learning models cannot work with raw text data directly, and we have to convert text into numbers. There are many different ways for the conversion and Keras’ build-in function uses each word’s rank of frequency in the entire training dataset to replace the raw text in both the training and testing dataset. For example, the 10th most frequent word is replaced by integer 10. There are a few additional setups for this process, including: <br />
a.Skip top frequent words. We usually skip a few top frequent words as they are mainly stopwords like “the” “and” or “a,” which usually do not provide much information. There is a parameter in the build-in function to specify how many top words to skip.
<ol start="2" style="list-style-type: lower-alpha">
<li>Set the maximum number of unique words. The entire vocabulary of the unique words in the training dataset may be large, and many of them have very low frequencies such as just appearing once in the entire training dataset. To keep the size of the vocabulary, we can also set up the maximum number of the unique words using Keras’ built-in function such that any words with least frequencies will be replaced with a special index such as “2”. </li>
</ol></li>
<li>Padding or truncation to keep all the reviews to be the same length. For most machine learning models, the algorithms expect to see the same number of features (i.e., same number of input columns in the data frame). There is a parameter in the Keras build-in function to set the maximum number of words in each review (i.e., max_length). For reviews that have less than max_legth words, we pad them with “0”. For reviews that have more than max_length words, we truncate them. </li>
</ol>
<p>After the above pre-processing, each review is represented by one row in the data frame. There is one column for the binary positive/negative sentiment, and max_length columns input features converted from the raw review text. In the corresponding R and Python notebooks, we will go over the details of the data pre-processing using Keras’ built-in functions.</p>
<!--chapter:end:03-Dataset.Rmd-->
</div>
</div>
<div id="data-pre-processing" class="section level1">
<h1><span class="header-section-number">4</span> Data Pre-processing</h1>
<p>Many data analysis related books focus on models, algorithms and statistical inferences. However, in practice, raw data is usually not directly used for modeling. Data preprocessing is the process of converting raw data into clean data that is proper for modeling. A model fails for various reasons. One is that the modeler doesn’t correctly preprocess data before modeling. Data preprocessing can significantly impact model results, such as imputing missing value and handling with outliers. So data preprocessing is a very critical part.</p>
<div class="figure">
<img src="images/DataPre-processing.png" alt="Data Pre-processing Outline" style="width:90.0%" />
<p class="caption">Data Pre-processing Outline</p>
</div>
<p>In real life, depending on the stage of data cleanup, data has the following types:</p>
<ol style="list-style-type: decimal">
<li>Raw data</li>
<li>Technically correct data</li>
<li>Data that is proper for the model</li>
<li>Summarized data</li>
<li>Data with fixed format</li>
</ol>
<p>The raw data is the first-hand data that analysts pull from the database, market survey responds from your clients, the experimental results collected by the R &amp; D department, and so on. These data may be very rough, and R sometimes can’t read them directly. The table title could be multi-line, or the format does not meet the requirements:</p>
<ul>
<li>Use 50% to represent the percentage rather than 0.5, so R will read it as a character;</li>
<li>The missing value of the sales is represented by “-” instead of space so that R will treat the variable as character or factor type;</li>
<li>The data is in a slideshow document, or the spreadsheet is not “.csv” but “.xlsx”</li>
<li>…</li>
</ul>
<p>Most of the time, you need to clean the data so that R can import them. Some data format requires a specific package. Technically correct data is the data, after preliminary cleaning or format conversion, that R (or another tool you use) can successfully import it.</p>
<p>Assume we have loaded the data into R with reasonable column names, variable format and so on. That does not mean the data is entirely correct. There may be some observations that do not make sense, such as age is negative, the discount percentage is greater than 1, or data is missing. Depending on the situation, there may be a variety of problems with the data. It is necessary to clean the data before modeling. Moreover, different models have different requirements on the data. For example, some model may require the variables are of consistent scale; some may be susceptible to outliers or collinearity, some may not be able to handle categorical variables and so on. The modeler has to preprocess the data to make it proper for the specific model.</p>
<p>Sometimes we need to aggregate the data. For example, add up the daily sales to get annual sales of a product at different locations. In customer segmentation, it is common practice to build a profile for each segment. It requires calculating some statistics such as average age, average income, age standard deviation, etc. Data aggregation is also necessary for presentation, or for data visualization.</p>
<p>The final table results for clients need to be in a nicer format than what used in the analysis. Usually, data analysts will take the results from data scientists and adjust the format, such as labels, cell color, highlight. It is important for a data scientist to make sure the results look consistent which makes the next step easier for data analysts.</p>
<p>It is highly recommended to store each step of the data and the R code, making the whole process as repeatable as possible. The R markdown reproducible report will be extremely helpful for that. If the data changes, it is easy to rerun the process. In the remainder of this chapter, we will show the most common data preprocessing methods.</p>
<p>Load the R packages first:</p>
<!--
```r
source("https://raw.githubusercontent.com/happyrabbit/CE_JSM2017/master/Rcode/00-course-setup.R")
```
-->
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># install packages from CRAN</span>
p_needed &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&#39;imputeMissings&#39;</span>,<span class="st">&#39;caret&#39;</span>,<span class="st">&#39;e1071&#39;</span>,<span class="st">&#39;psych&#39;</span>,<span class="st">&#39;car&#39;</span>,<span class="st">&#39;corrplot&#39;</span>)
packages &lt;-<span class="st"> </span><span class="kw">rownames</span>(<span class="kw">installed.packages</span>())
p_to_install &lt;-<span class="st"> </span>p_needed[<span class="op">!</span>(p_needed <span class="op">%in%</span><span class="st"> </span>packages)]
<span class="cf">if</span> (<span class="kw">length</span>(p_to_install) <span class="op">&gt;</span><span class="st"> </span><span class="dv">0</span>) {
    <span class="kw">install.packages</span>(p_to_install)
}

<span class="kw">lapply</span>(p_needed, require, <span class="dt">character.only =</span> <span class="ot">TRUE</span>)</code></pre></div>
<div id="data-cleaning" class="section level2">
<h2><span class="header-section-number">4.1</span> Data Cleaning</h2>
<p>After you load the data, the first thing is to check how many variables are there, the type of variables, the distributions, and data errors. Let’s read and check the data:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">sim.dat &lt;-<span class="st"> </span><span class="kw">read.csv</span>(<span class="st">&quot;http://bit.ly/2P5gTw4&quot;</span>)
<span class="kw">summary</span>(sim.dat)</code></pre></div>
<pre class="pre"><code>      age           gender        income       house       store_exp    
 Min.   : 16.0   Female:554   Min.   : 41776   No :432   Min.   : -500  
 1st Qu.: 25.0   Male  :446   1st Qu.: 85832   Yes:568   1st Qu.:  205  
 Median : 36.0                Median : 93869             Median :  329  
 Mean   : 38.8                Mean   :113543             Mean   : 1357  
 3rd Qu.: 53.0                3rd Qu.:124572             3rd Qu.:  597  
 Max.   :300.0                Max.   :319704             Max.   :50000  
                              NA&#39;s   :184                               
   online_exp    store_trans     online_trans        Q1            Q2      
 Min.   :  69   Min.   : 1.00   Min.   : 1.0   Min.   :1.0   Min.   :1.00  
 1st Qu.: 420   1st Qu.: 3.00   1st Qu.: 6.0   1st Qu.:2.0   1st Qu.:1.00  
 Median :1942   Median : 4.00   Median :14.0   Median :3.0   Median :1.00  
 Mean   :2120   Mean   : 5.35   Mean   :13.6   Mean   :3.1   Mean   :1.82  
 3rd Qu.:2441   3rd Qu.: 7.00   3rd Qu.:20.0   3rd Qu.:4.0   3rd Qu.:2.00  
 Max.   :9479   Max.   :20.00   Max.   :36.0   Max.   :5.0   Max.   :5.00  
                                                                           
       Q3             Q4             Q5             Q6             Q7      
 Min.   :1.00   Min.   :1.00   Min.   :1.00   Min.   :1.00   Min.   :1.00  
 1st Qu.:1.00   1st Qu.:2.00   1st Qu.:1.75   1st Qu.:1.00   1st Qu.:2.50  
 Median :1.00   Median :3.00   Median :4.00   Median :2.00   Median :4.00  
 Mean   :1.99   Mean   :2.76   Mean   :2.94   Mean   :2.45   Mean   :3.43  
 3rd Qu.:3.00   3rd Qu.:4.00   3rd Qu.:4.00   3rd Qu.:4.00   3rd Qu.:4.00  
 Max.   :5.00   Max.   :5.00   Max.   :5.00   Max.   :5.00   Max.   :5.00  
                                                                           
       Q8            Q9            Q10              segment   
 Min.   :1.0   Min.   :1.00   Min.   :1.00   Conspicuous:200  
 1st Qu.:1.0   1st Qu.:2.00   1st Qu.:1.00   Price      :250  
 Median :2.0   Median :4.00   Median :2.00   Quality    :200  
 Mean   :2.4   Mean   :3.08   Mean   :2.32   Style      :350  
 3rd Qu.:3.0   3rd Qu.:4.00   3rd Qu.:3.00                    
 Max.   :5.0   Max.   :5.00   Max.   :5.00                    </code></pre>
<p>Are there any problems? Questionnaire response Q1-Q10 seem reasonable, the minimum is 1 and maximum is 5. Recall that the questionnaire score is 1-5. The number of store transactions (<code>store_trans</code>) and online transactions (<code>online_trans</code>) make sense too. Things to pay attention are:</p>
<ul>
<li>There are some missing values.</li>
<li>There are outliers for store expenses (<code>store_exp</code>). The maximum value is 50000. Who would spend $50000 a year buying clothes? Is it an imputation error?</li>
<li>There is a negative value ( -500) in <code>store_exp</code> which is not logical.</li>
<li>Someone is 300 years old.</li>
</ul>
<p>How to deal with that? Depending on the real situation, if the sample size is large enough, it does not hurt to delete those problematic samples. Here we have 1000 observations. Since marketing survey is usually expensive, it is better to set these values as missing and impute them instead of deleting the rows.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># set problematic values as missings</span>
sim.dat<span class="op">$</span>age[<span class="kw">which</span>(sim.dat<span class="op">$</span>age <span class="op">&gt;</span><span class="st"> </span><span class="dv">100</span>)] &lt;-<span class="st"> </span><span class="ot">NA</span>
sim.dat<span class="op">$</span>store_exp[<span class="kw">which</span>(sim.dat<span class="op">$</span>store_exp <span class="op">&lt;</span><span class="st"> </span><span class="dv">0</span>)] &lt;-<span class="st"> </span><span class="ot">NA</span>
<span class="co"># see the results</span>
<span class="kw">summary</span>(<span class="kw">subset</span>(sim.dat, <span class="dt">select =</span> <span class="kw">c</span>(<span class="st">&quot;age&quot;</span>, <span class="st">&quot;store_exp&quot;</span>)))</code></pre></div>
<pre class="pre"><code>      age          store_exp      
 Min.   :16.00   Min.   :  155.8  
 1st Qu.:25.00   1st Qu.:  205.1  
 Median :36.00   Median :  329.8  
 Mean   :38.58   Mean   : 1358.7  
 3rd Qu.:53.00   3rd Qu.:  597.4  
 Max.   :69.00   Max.   :50000.0  
 NA&#39;s   :1       NA&#39;s   :1        </code></pre>
<p>Now let’s deal with the missing values in the data.</p>
</div>
<div id="missing-values" class="section level2">
<h2><span class="header-section-number">4.2</span> Missing Values</h2>
<p>You can write a whole book about missing value. This section will only show some of the most commonly used methods without getting too deep into the topic. Chapter 7 of the book by De Waal, Pannekoek and Scholtus <span class="citation">(Waal, Pannekoek, and Scholtus <a href="#ref-Ton2011">2011</a>)</span> makes a concise overview of some of the existing imputation methods. The choice of specific method depends on the actual situation. There is no best way.</p>
<p>One question to ask before imputation: Is there any auxiliary information? Being aware of any auxiliary information is critical. For example, if the system set customer who did not purchase as missing, then the real purchasing amount should be 0. Is missing a random occurrence? If so, it may be reasonable to impute with mean or median. If not, is there a potential mechanism for the missing data? For example, older people are more reluctant to disclose their ages in the questionnaire, so that the absence of age is not completely random. In this case, the missing values need to be estimated using the relationship between age and other independent variables. For example, use variables such as whether they have children, income, and other survey questions to build a model to predict age.</p>
<p>Also, the purpose of modeling is important for selecting imputation methods. If the goal is to interpret the parameter estimate or statistical inference, then it is important to study the missing mechanism carefully and to estimate the missing values using non-missing information as much as possible. If the goal is to predict, people usually will not study the absence mechanism rigorously (but sometimes the mechanism is obvious). If the absence mechanism is not clear, treat it as missing at random and use mean, median, or k-nearest neighbor to impute. Since statistical inference is sensitive to missing values, researchers from survey statistics have conducted in-depth studies of various imputation schemes which focus on valid statistical inference. The problem of missing values in the prediction model is different from that in the traditional survey. Therefore, there are not many papers on missing value imputation in the prediction model. Those who want to study further can refer to Saar-Tsechansky and Provost’s comparison of different imputation methods <span class="citation">(M and F 2007b)</span> and De Waal, Pannekoek and Scholtus’ book <span class="citation">(Waal, Pannekoek, and Scholtus <a href="#ref-Ton2011">2011</a>)</span>.</p>
<div id="impute-missing-values-with-medianmode" class="section level3">
<h3><span class="header-section-number">4.2.1</span> Impute missing values with median/mode</h3>
<p>In the case of missing at random, a common method is to impute with the mean (continuous variable) or median (categorical variables). You can use <code>impute()</code> function in <code>imputeMissings</code> package.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># save the result as another object</span>
demo_imp &lt;-<span class="st"> </span><span class="kw">impute</span>(sim.dat, <span class="dt">method =</span> <span class="st">&quot;median/mode&quot;</span>)
<span class="co"># check the first 5 columns, there is no missing values in other columns</span>
<span class="kw">summary</span>(demo_imp[, <span class="dv">1</span><span class="op">:</span><span class="dv">5</span>])</code></pre></div>
<pre class="pre"><code>      age           gender        income       house       store_exp      
 Min.   :16.00   Female:554   Min.   : 41776   No :432   Min.   :  155.8  
 1st Qu.:25.00   Male  :446   1st Qu.: 87896   Yes:568   1st Qu.:  205.1  
 Median :36.00                Median : 93869             Median :  329.8  
 Mean   :38.58                Mean   :109923             Mean   : 1357.7  
 3rd Qu.:53.00                3rd Qu.:119456             3rd Qu.:  597.3  
 Max.   :69.00                Max.   :319704             Max.   :50000.0</code></pre>
<p>After imputation, <code>demo_imp</code> has no missing value. This method is straightforward and widely used. The disadvantage is that it does not take into account the relationship between the variables. When there is a significant proportion of missing, it will distort the data. In this case, it is better to consider the relationship between variables and study the missing mechanism. In the example here, the missing variables are numeric. If the missing variable is a categorical/factor variable, the <code>impute()</code> function will impute with the mode.</p>
<p>You can also use <code>preProcess()</code> in package <code>caret</code>, but it is only for numeric variables, and can not impute categorical variables. Since missing values here are numeric, we can use the <code>preProcess()</code> function. The result is the same as the <code>impute()</code> function. <code>PreProcess()</code> is a powerful function that can link to a variety of data preprocessing methods. We will use the function later for other data preprocessing.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">imp &lt;-<span class="st"> </span><span class="kw">preProcess</span>(sim.dat, <span class="dt">method =</span> <span class="st">&quot;medianImpute&quot;</span>)
demo_imp2 &lt;-<span class="st"> </span><span class="kw">predict</span>(imp, sim.dat)
<span class="kw">summary</span>(demo_imp2[, <span class="dv">1</span><span class="op">:</span><span class="dv">5</span>])</code></pre></div>
<pre class="pre"><code>      age           gender        income       house       store_exp      
 Min.   :16.00   Female:554   Min.   : 41776   No :432   Min.   :  155.8  
 1st Qu.:25.00   Male  :446   1st Qu.: 87896   Yes:568   1st Qu.:  205.1  
 Median :36.00                Median : 93869             Median :  329.8  
 Mean   :38.58                Mean   :109923             Mean   : 1357.7  
 3rd Qu.:53.00                3rd Qu.:119456             3rd Qu.:  597.3  
 Max.   :69.00                Max.   :319704             Max.   :50000.0  </code></pre>
</div>
<div id="k-nearest-neighbors" class="section level3">
<h3><span class="header-section-number">4.2.2</span> K-nearest neighbors</h3>
<p>K-nearest neighbor (KNN) will find the k closest samples (Euclidian distance) in the training set and impute the mean of those “neighbors.”</p>
<p>Use <code>preProcess()</code> to conduct KNN:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">imp &lt;-<span class="st"> </span><span class="kw">preProcess</span>(sim.dat, <span class="dt">method =</span> <span class="st">&quot;knnImpute&quot;</span>, <span class="dt">k =</span> <span class="dv">5</span>)
<span class="co"># need to use predict() to get KNN result</span>
demo_imp &lt;-<span class="st"> </span><span class="kw">predict</span>(imp, sim.dat)
<span class="co"># only show the first three elements</span>
<span class="kw">lapply</span>(sim.dat, class)[<span class="dv">1</span><span class="op">:</span><span class="dv">3</span>]</code></pre></div>
<pre class="pre"><code>      age                gender        income        
 Min.   :-1.5910972   Female:554   Min.   :-1.43989  
 1st Qu.:-0.9568733   Male  :446   1st Qu.:-0.53732  
 Median :-0.1817107                Median :-0.37606  
 Mean   : 0.0000156                Mean   : 0.02389  
 3rd Qu.: 1.0162678                3rd Qu.: 0.21540  
 Max.   : 2.1437770                Max.   : 4.13627 </code></pre>
<p>The <code>preProcess()</code> in the first line will automatically ignore non-numeric columns.</p>
<p>Comparing the KNN result with the previous median imputation, the two are very different. This is because when you tell the <code>preProcess()</code> function to use KNN (the option <code>method =&quot; knnImpute&quot;</code>), it will automatically standardize the data. Another way is to use Bagging tree (in the next section). Note that KNN can not impute samples with the entire row missing. The reason is straightforward. Since the algorithm uses the average of its neighbors if none of them has a value, what does it apply to calculate the mean?</p>
<p>Let’s append a new row with all values missing to the original data frame to get a new object called <code>temp</code>. Then apply KNN to <code>temp</code> and see what happens:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">temp &lt;-<span class="st"> </span><span class="kw">rbind</span>(sim.dat, <span class="kw">rep</span>(<span class="ot">NA</span>, <span class="kw">ncol</span>(sim.dat)))
imp &lt;-<span class="st"> </span><span class="kw">preProcess</span>(sim.dat, <span class="dt">method =</span> <span class="st">&quot;knnImpute&quot;</span>, <span class="dt">k =</span> <span class="dv">5</span>)
demo_imp &lt;-<span class="st"> </span><span class="kw">predict</span>(imp, temp)</code></pre></div>
<pre class="pre"><code>Error in FUN(newX[, i], ...) : 
  cannot impute when all predictors are missing in the new data point</code></pre>
<p>There is an error saying “<code>cannot impute when all predictors are missing in the new data point</code>”. It is easy to fix by finding and removing the problematic row(s):</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">idx &lt;-<span class="st"> </span><span class="kw">apply</span>(temp, <span class="dv">1</span>, <span class="cf">function</span>(x) <span class="kw">sum</span>(<span class="kw">is.na</span>(x)))
<span class="kw">as.vector</span>(<span class="kw">which</span>(idx <span class="op">==</span><span class="st"> </span><span class="kw">ncol</span>(temp)))</code></pre></div>
<p>It shows that row 1001 is problematic. You can go ahead to delete it.</p>
</div>
<div id="bagging-tree" class="section level3">
<h3><span class="header-section-number">4.2.3</span> Bagging Tree</h3>
<p>Bagging (Bootstrap aggregating) was originally proposed by Leo Breiman. It is one of the earliest ensemble methods <span class="citation">(L 1966a)</span>. When used in missing value imputation, it will use the remaining variables as predictors to train a bagging tree and then use the tree to predict the missing values. Although theoretically, the method is powerful, the computation is much more intense than KNN. In practice, there is a trade-off between computation time and the effect. If a median or mean meet the modeling needs, even bagging tree may improve the accuracy a little, but the upgrade is so marginal that it does not deserve the extra time. The bagging tree itself is a model for regression and classification. Here we use <code>preProcess()</code> to impute <code>sim.dat</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">imp &lt;-<span class="st"> </span><span class="kw">preProcess</span>(sim.dat, <span class="dt">method =</span> <span class="st">&quot;bagImpute&quot;</span>)
demo_imp &lt;-<span class="st"> </span><span class="kw">predict</span>(imp, sim.dat)
<span class="kw">summary</span>(demo_imp[, <span class="dv">1</span><span class="op">:</span><span class="dv">5</span>])</code></pre></div>
<pre class="pre"><code>      age           gender        income       house       store_exp      
 Min.   :16.00   Female:554   Min.   : 41776   No :432   Min.   :  155.8  
 1st Qu.:25.00   Male  :446   1st Qu.: 86762   Yes:568   1st Qu.:  205.1  
 Median :36.00                Median : 94739             Median :  329.0  
 Mean   :38.58                Mean   :114665             Mean   : 1357.7  
 3rd Qu.:53.00                3rd Qu.:123726             3rd Qu.:  597.3  
 Max.   :69.00                Max.   :319704             Max.   :50000.0  </code></pre>
</div>
</div>
<div id="centering-and-scaling" class="section level2">
<h2><span class="header-section-number">4.3</span> Centering and Scaling</h2>
<p>It is the most straightforward data transformation. It centers and scales a variable to mean 0 and standard deviation 1. It ensures that the criterion for finding linear combinations of the predictors is based on how much variation they explain and therefore improves the numerical stability. Models involving finding linear combinations of the predictors to explain response/predictors variation need data centering and scaling, such as PCA <span class="citation">(Jolliffe <a href="#ref-pca1">2002</a>)</span>, PLS <span class="citation">(Geladi P <a href="#ref-PLS1">1986</a>)</span> and EFA <span class="citation">(Mulaik <a href="#ref-EFA1">2009</a>)</span>. You can quickly write code yourself to conduct this transformation.</p>
<p>Let’s standardize the variable <code>income</code> from <code>sim.dat</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">income &lt;-<span class="st"> </span>sim.dat<span class="op">$</span>income
<span class="co"># calculate the mean of income</span>
mux &lt;-<span class="st"> </span><span class="kw">mean</span>(income, <span class="dt">na.rm =</span> T)
<span class="co"># calculate the standard deviation of income</span>
sdx &lt;-<span class="st"> </span><span class="kw">sd</span>(income, <span class="dt">na.rm =</span> T)
<span class="co"># centering</span>
tr1 &lt;-<span class="st"> </span>income <span class="op">-</span><span class="st"> </span>mux
<span class="co"># scaling</span>
tr2 &lt;-<span class="st"> </span>tr1<span class="op">/</span>sdx</code></pre></div>
<p>Or the function <code>preProcess()</code> can apply this transformation to a set of predictors.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">sdat &lt;-<span class="st"> </span><span class="kw">subset</span>(sim.dat, <span class="dt">select =</span> <span class="kw">c</span>(<span class="st">&quot;age&quot;</span>, <span class="st">&quot;income&quot;</span>))
<span class="co"># set the &#39;method&#39; option</span>
trans &lt;-<span class="st"> </span><span class="kw">preProcess</span>(sdat, <span class="dt">method =</span> <span class="kw">c</span>(<span class="st">&quot;center&quot;</span>, <span class="st">&quot;scale&quot;</span>))
<span class="co"># use predict() function to get the final result</span>
transformed &lt;-<span class="st"> </span><span class="kw">predict</span>(trans, sdat)</code></pre></div>
<p>Now the two variables are in the same scale. You can check the result using <code>summary(transformed)</code>. Note that there are missing values.</p>
</div>
<div id="resolve-skewness" class="section level2">
<h2><span class="header-section-number">4.4</span> Resolve Skewness</h2>
<p><a href="https://en.wikipedia.org/wiki/Skewness">Skewness</a> is defined to be the third standardized central moment. The formula for the sample skewness statistics is: <span class="math display">\[ skewness=\frac{\sum(x_{i}-\bar{x})^{3}}{(n-1)v^{3/2}}\]</span> <span class="math display">\[v=\frac{\sum(x_{i}-\bar{x})^{2}}{(n-1)}\]</span> Skewness=0 means that the destribution is symmetric, i.e. the probability of falling on either side of the distribution’s mean is equal.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># need skewness() function from e1071 package</span>
<span class="kw">set.seed</span>(<span class="dv">1000</span>)
<span class="kw">par</span>(<span class="dt">mfrow =</span> <span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">2</span>), <span class="dt">oma =</span> <span class="kw">c</span>(<span class="dv">2</span>, <span class="dv">2</span>, <span class="dv">2</span>, <span class="dv">2</span>))
<span class="co"># random sample 1000 chi-square distribution with df=2 right skew</span>
x1 &lt;-<span class="st"> </span><span class="kw">rchisq</span>(<span class="dv">1000</span>, <span class="dv">2</span>, <span class="dt">ncp =</span> <span class="dv">0</span>)
<span class="co"># get left skew variable x2 from x1</span>
x2 &lt;-<span class="st"> </span><span class="kw">max</span>(x1) <span class="op">-</span><span class="st"> </span>x1
<span class="kw">plot</span>(<span class="kw">density</span>(x2), <span class="dt">main =</span> <span class="kw">paste</span>(<span class="st">&quot;left skew, skewnwss =&quot;</span>, <span class="kw">round</span>(<span class="kw">skewness</span>(x2), 
    <span class="dv">2</span>)), <span class="dt">xlab =</span> <span class="st">&quot;X2&quot;</span>)
<span class="kw">plot</span>(<span class="kw">density</span>(x1), <span class="dt">main =</span> <span class="kw">paste</span>(<span class="st">&quot;right skew, skewness =&quot;</span>, <span class="kw">round</span>(<span class="kw">skewness</span>(x1), 
    <span class="dv">2</span>)), <span class="dt">xlab =</span> <span class="st">&quot;X1&quot;</span>)</code></pre></div>
<p><img src="IDS_files/figure-html/unnamed-chunk-16-1.svg" width="672" /></p>
<!--You can easily tell if a distribution is skewed by simple visualization(Figure\@ref(fig:skew)). -->
<p>There are different ways may help to remove skewness such as log, square root or inverse. However, it is often difficult to determine from plots which transformation is most appropriate for correcting skewness. The Box-Cox procedure automatically identified a transformation from the family of power transformations that are indexed by a parameter <span class="math inline">\(\lambda\)</span><span class="citation">(Box G <a href="#ref-BOXCOX1">1964</a>)</span>.</p>
<p><span class="math display">\[
x^{*}=\begin{cases}
\begin{array}{c}
\frac{x^{\lambda}-1}{\lambda}\\
log(x)
\end{array} &amp; \begin{array}{c}
if\ \lambda\neq0\\
if\ \lambda=0
\end{array}\end{cases}
\]</span></p>
<p>It is easy to see that this family includes log transformation (<span class="math inline">\(\lambda=0\)</span>), square transformation (<span class="math inline">\(\lambda=2\)</span>), square root (<span class="math inline">\(\lambda=0.5\)</span>), inverse (<span class="math inline">\(\lambda=-1\)</span>) and others in-between. We can still use function <code>preProcess()</code> in package <code>caret</code> to apply this transformation by chaning the <code>method</code> argument.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">describe</span>(sim.dat)</code></pre></div>
<pre class="pre"><code>             vars    n      mean       sd median   trimmed      mad ...
age             1 1000     38.84    16.42     36     37.69    16.31
gender*         2 1000      1.45     0.50      1      1.43     0.00
income          3  816 113543.07 49842.29  93869 104841.94 28989.47
house*          4 1000      1.57     0.50      2      1.58     0.00
store_exp       5 1000   1356.85  2774.40    329    839.92   196.45
online_exp      6 1000   2120.18  1731.22   1942   1874.51  1015.21
store_trans     7 1000      5.35     3.70      4      4.89     2.97
online_trans    8 1000     13.55     7.96     14     13.42    10.38
...</code></pre>
<p>It is easy to see the skewed variables. If <code>mean</code> and <code>trimmed</code> differ a lot, there is very likely outliers. By default, <code>trimmed</code> reports mean by dropping the top and bottom 10%. It can be adjusted by setting argument <code>trim=</code>. It is clear that <code>store_exp</code> has outliers.</p>
<p>As an example, we will apply Box-Cox transformation on <code>store_trans</code> and <code>online_trans</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># select the two columns and save them as dat_bc</span>
dat_bc &lt;-<span class="st"> </span><span class="kw">subset</span>(sim.dat, <span class="dt">select =</span> <span class="kw">c</span>(<span class="st">&quot;store_trans&quot;</span>, <span class="st">&quot;online_trans&quot;</span>))
(trans &lt;-<span class="st"> </span><span class="kw">preProcess</span>(dat_bc, <span class="dt">method =</span> <span class="kw">c</span>(<span class="st">&quot;BoxCox&quot;</span>)))</code></pre></div>
<pre><code>## Created from 1000 samples and 2 variables
## 
## Pre-processing:
##   - Box-Cox transformation (2)
##   - ignored (0)
## 
## Lambda estimates for Box-Cox transformation:
## 0.1, 0.7</code></pre>
<p>The last line of the output shows the estimates of <span class="math inline">\(\lambda\)</span> for each variable. As before, use <code>predict()</code> to get the transformed result:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">transformed &lt;-<span class="st"> </span><span class="kw">predict</span>(trans, dat_bc)
<span class="kw">par</span>(<span class="dt">mfrow =</span> <span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">2</span>), <span class="dt">oma =</span> <span class="kw">c</span>(<span class="dv">2</span>, <span class="dv">2</span>, <span class="dv">2</span>, <span class="dv">2</span>))
<span class="kw">hist</span>(dat_bc<span class="op">$</span>store_trans, <span class="dt">main =</span> <span class="st">&quot;Before Transformation&quot;</span>, <span class="dt">xlab =</span> <span class="st">&quot;store_trans&quot;</span>)
<span class="kw">hist</span>(transformed<span class="op">$</span>store_trans, <span class="dt">main =</span> <span class="st">&quot;After Transformation&quot;</span>, <span class="dt">xlab =</span> <span class="st">&quot;store_trans&quot;</span>)</code></pre></div>
<p><img src="IDS_files/figure-html/unnamed-chunk-18-1.svg" width="672" /></p>
<p>Before the transformation, the <code>stroe_trans</code> is skewed right. <!--The situation is significantly improved after (figure\@ref(fig:bc)). --> <code>BoxCoxTrans ()</code> can also conduct Box-Cox transform. But note that <code>BoxCoxTrans ()</code> can only be applied to a single variable, and it is not possible to transform difference columns in a data frame at the same time.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">(trans &lt;-<span class="st"> </span><span class="kw">BoxCoxTrans</span>(dat_bc<span class="op">$</span>store_trans))</code></pre></div>
<pre><code>## Box-Cox Transformation
## 
## 1000 data points used to estimate Lambda
## 
## Input data summary:
##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
##    1.00    3.00    4.00    5.35    7.00   20.00 
## 
## Largest/Smallest: 20 
## Sample Skewness: 1.11 
## 
## Estimated Lambda: 0.1 
## With fudge factor, Lambda = 0 will be used for transformations</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">transformed &lt;-<span class="st"> </span><span class="kw">predict</span>(trans, dat_bc<span class="op">$</span>store_trans)
<span class="kw">skewness</span>(transformed)</code></pre></div>
<pre><code>## [1] -0.2155</code></pre>
<p>The estimate of <span class="math inline">\(\lambda\)</span> is the same as before (0.1). The skewness of the original observation is 1.1, and -0.2 after transformation. Although it is not strictly 0, it is greatly improved.</p>
</div>
<div id="resolve-outliers" class="section level2">
<h2><span class="header-section-number">4.5</span> Resolve Outliers</h2>
<p>Even under certain assumptions we can statistically define outliers, it can be hard to define in some situations. Box plot, histogram and some other basic visualizations can be used to initially check whether there are outliers. For example, we can visualize numerical non-survey variables in <code>sim.dat</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># select numerical non-survey data</span>
sdat&lt;-<span class="kw">subset</span>(sim.dat,<span class="dt">select=</span><span class="kw">c</span>(<span class="st">&quot;age&quot;</span>,<span class="st">&quot;income&quot;</span>,<span class="st">&quot;store_exp&quot;</span>,<span class="st">&quot;online_exp&quot;</span>,<span class="st">&quot;store_trans&quot;</span>,<span class="st">&quot;online_trans&quot;</span> ))
<span class="co"># use scatterplotMatrix() function from car package</span>
<span class="kw">par</span>(<span class="dt">oma=</span><span class="kw">c</span>(<span class="dv">2</span>,<span class="dv">2</span>,<span class="dv">1</span>,<span class="dv">2</span>))
<span class="kw">scatterplotMatrix</span>(sdat,<span class="dt">diagonal=</span><span class="st">&quot;boxplot&quot;</span>,<span class="dt">smoother=</span><span class="ot">FALSE</span>)</code></pre></div>
<p><img src="IDS_files/figure-html/unnamed-chunk-21-1.svg" width="672" /></p>
<!--As figure \@ref(fig:scm) shows, `store_exp` has outliers. -->
<p>It is also easy to observe the pair relationship from the plot. <code>age</code> is negatively correlated with <code>online_trans</code> but positively correlated with <code>store_trans</code>. It seems that older people tend to purchase from the local store. The amount of expense is positively correlated with income. Scatterplot matrix like this can reveal lots of information before modeling.</p>
<p>In addition to visualization, there are some statistical methods to define outliers, such as the commonly used Z-score. The Z-score for variable <span class="math inline">\(\mathbf{Y}\)</span> is defined as:</p>
<p><span class="math display">\[Z_{i}=\frac{Y_{i}-\bar{Y}}{s}\]</span></p>
<p>where <span class="math inline">\(\bar{Y}\)</span> and <span class="math inline">\(s\)</span> are mean and standard deviation for <span class="math inline">\(Y\)</span>. Z-score is a measurement of the distance between each observation and the mean. This method may be misleading, especially when the sample size is small. Iglewicz and Hoaglin proposed to use the modified Z-score to determine the outlier<span class="citation">(Iglewicz and Hoaglin <a href="#ref-mad1">1993</a>)</span>：</p>
<p><span class="math display">\[M_{i}=\frac{0.6745(Y_{i}-\bar{Y})}{MAD}\]</span></p>
<p>Where MAD is the median of a series of <span class="math inline">\(|Y_ {i} - \bar{Y}|\)</span>, called the median of the absolute dispersion. Iglewicz and Hoaglin suggest that the points with the Z-score greater than 3.5 corrected above are possible outliers. Let’s apply it to <code>income</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># calculate median of the absolute dispersion for income</span>
ymad &lt;-<span class="st"> </span><span class="kw">mad</span>(<span class="kw">na.omit</span>(sdat<span class="op">$</span>income))
<span class="co"># calculate z-score</span>
zs &lt;-<span class="st"> </span>(sdat<span class="op">$</span>income <span class="op">-</span><span class="st"> </span><span class="kw">mean</span>(<span class="kw">na.omit</span>(sdat<span class="op">$</span>income)))<span class="op">/</span>ymad
<span class="co"># count the number of outliers</span>
<span class="kw">sum</span>(<span class="kw">na.omit</span>(zs <span class="op">&gt;</span><span class="st"> </span><span class="fl">3.5</span>))</code></pre></div>
<pre><code>## [1] 59</code></pre>
<p>According to modified Z-score, variable income has 59 outliers. Refer to <span class="citation">(Iglewicz and Hoaglin <a href="#ref-mad1">1993</a>)</span> for other ways of detecting outliers.</p>
<p>The impact of outliers depends on the model. Some models are sensitive to outliers, such as linear regression, logistic regression. Some are pretty robust to outliers, such as tree models, support vector machine. Also, the outlier is not wrong data. It is real observation so cannot be deleted at will. If a model is sensitive to outliers, we can use <em>spatial sign transformation</em> <span class="citation">(Serneels S <a href="#ref-ssp">2006</a>)</span> to minimize the problem. It projects the original sample points to the surface of a sphere by:</p>
<p><span class="math display">\[x_{ij}^{*}=\frac{x_{ij}}{\sqrt{\sum_{j=1}^{p}x_{ij}^{2}}}\]</span></p>
<p>where <span class="math inline">\(x_{ij}\)</span> represents the <span class="math inline">\(i^{th}\)</span> observation and <span class="math inline">\(j^{th}\)</span> variable. As shown in the equation, every observation for sample <span class="math inline">\(i\)</span> is divided by its square mode. The denominator is the Euclidean distance to the center of the p-dimensional predictor space. Three things to pay attention here:</p>
<ol style="list-style-type: decimal">
<li>It is important to center and scale the predictor data before using this transformation</li>
<li>Unlike centering or scaling, this manipulation of the predictors transforms them as a group</li>
<li>If there are some variables to remove (for example, highly correlated variables), do it before the transformation</li>
</ol>
<p>Function <code>spatialSign()</code> <code>caret</code> package can conduct the transformation. Take <code>income</code> and <code>age</code> as an example:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># KNN imputation</span>
sdat &lt;-<span class="st"> </span>sim.dat[, <span class="kw">c</span>(<span class="st">&quot;income&quot;</span>, <span class="st">&quot;age&quot;</span>)]
imp &lt;-<span class="st"> </span><span class="kw">preProcess</span>(sdat, <span class="dt">method =</span> <span class="kw">c</span>(<span class="st">&quot;knnImpute&quot;</span>), <span class="dt">k =</span> <span class="dv">5</span>)
sdat &lt;-<span class="st"> </span><span class="kw">predict</span>(imp, sdat)
transformed &lt;-<span class="st"> </span><span class="kw">spatialSign</span>(sdat)
transformed &lt;-<span class="st"> </span><span class="kw">as.data.frame</span>(transformed)
<span class="kw">par</span>(<span class="dt">mfrow =</span> <span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">2</span>), <span class="dt">oma =</span> <span class="kw">c</span>(<span class="dv">2</span>, <span class="dv">2</span>, <span class="dv">2</span>, <span class="dv">2</span>))
<span class="kw">plot</span>(income <span class="op">~</span><span class="st"> </span>age, <span class="dt">data =</span> sdat, <span class="dt">col =</span> <span class="st">&quot;blue&quot;</span>, <span class="dt">main =</span> <span class="st">&quot;Before&quot;</span>)
<span class="kw">plot</span>(income <span class="op">~</span><span class="st"> </span>age, <span class="dt">data =</span> transformed, <span class="dt">col =</span> <span class="st">&quot;blue&quot;</span>, <span class="dt">main =</span> <span class="st">&quot;After&quot;</span>)</code></pre></div>
<p><img src="IDS_files/figure-html/unnamed-chunk-23-1.svg" width="672" /></p>
<p>Some readers may have found that the above code does not seem to standardize the data before transformation. Recall the introduction of KNN, <code>preProcess()</code> with <code>method=&quot;knnImpute&quot;</code> by default will standardize data.</p>
</div>
<div id="collinearity" class="section level2">
<h2><span class="header-section-number">4.6</span> Collinearity</h2>
<p>It is probably the technical term known by the most un-technical people. When two predictors are very strongly correlated, including both in a model may lead to confusion or problem with a singular matrix. There is an excellent function in <code>corrplot</code> package with the same name <code>corrplot()</code> that can visualize correlation structure of a set of predictors. The function has the option to reorder the variables in a way that reveals clusters of highly correlated ones.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># select non-survey numerical variables</span>
sdat &lt;-<span class="st"> </span><span class="kw">subset</span>(sim.dat, <span class="dt">select =</span> <span class="kw">c</span>(<span class="st">&quot;age&quot;</span>, <span class="st">&quot;income&quot;</span>, <span class="st">&quot;store_exp&quot;</span>, <span class="st">&quot;online_exp&quot;</span>, 
    <span class="st">&quot;store_trans&quot;</span>, <span class="st">&quot;online_trans&quot;</span>))
<span class="co"># use bagging imputation here</span>
imp &lt;-<span class="st"> </span><span class="kw">preProcess</span>(sdat, <span class="dt">method =</span> <span class="st">&quot;bagImpute&quot;</span>)
sdat &lt;-<span class="st"> </span><span class="kw">predict</span>(imp, sdat)
<span class="co"># get the correlation matrix</span>
correlation &lt;-<span class="st"> </span><span class="kw">cor</span>(sdat)
<span class="co"># plot</span>
<span class="kw">par</span>(<span class="dt">oma =</span> <span class="kw">c</span>(<span class="dv">2</span>, <span class="dv">2</span>, <span class="dv">2</span>, <span class="dv">2</span>))
<span class="kw">corrplot.mixed</span>(correlation, <span class="dt">order =</span> <span class="st">&quot;hclust&quot;</span>, <span class="dt">tl.pos =</span> <span class="st">&quot;lt&quot;</span>, <span class="dt">upper =</span> <span class="st">&quot;ellipse&quot;</span>)</code></pre></div>
<p><img src="IDS_files/figure-html/unnamed-chunk-24-1.svg" width="672" /></p>
<!--Here use `corrplot.mixed()` function to visualize the correlation matrix (figure \@ref(fig:corp)).-->
<p>The closer the correlation is to 0, the lighter the color is and the closer the shape is to a circle. The elliptical means the correlation is not equal to 0 (because we set the <code>upper = &quot;ellipse&quot;</code>), the greater the correlation, the narrower the ellipse. Blue represents a positive correlation; red represents a negative correlation. The direction of the ellipse also changes with the correlation. The correlation coefficient is shown in the lower triangle of the matrix.</p>
<p>The variables relationship from previous scatter matrix are clear here: the negative correlation between age and online shopping, the positive correlation between income and amount of purchasing. Some correlation is very strong ( such as the correlation between <code>online_trans</code> and<code>age</code> is -0.7414) which means the two variables contain duplicate information.</p>
<p>Section 3.5 of “Applied Predictive Modeling” <span class="citation">(Kuhn and Johnston <a href="#ref-APM">2013</a>)</span> presents a heuristic algorithm to remove a minimum number of predictors to ensure all pairwise correlations are below a certain threshold:</p>
<blockquote>
<ol style="list-style-type: decimal">
<li>Calculate the correlation matrix of the predictors.</li>
<li>Determine the two predictors associated with the largest absolute pairwise correlation (call them predictors A and B).</li>
<li>Determine the average correlation between A and the other variables. Do the same for predictor B.</li>
<li>If A has a larger average correlation, remove it; otherwise, remove predictor B.</li>
<li>Repeat Step 2-4 until no absolute correlations are above the threshold.</li>
</ol>
</blockquote>
<p>The <code>findCorrelation()</code> function in package <code>caret</code> will apply the above algorithm.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">(highCorr &lt;-<span class="st"> </span><span class="kw">findCorrelation</span>(<span class="kw">cor</span>(sdat), <span class="dt">cutoff =</span> <span class="fl">0.7</span>))</code></pre></div>
<pre><code>## [1] 2 6</code></pre>
<p>It returns the index of columns need to be deleted. It tells us that we need to remove the first column to make sure the correlations are all below 0.7.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># delete highly correlated columns</span>
sdat &lt;-<span class="st"> </span>sdat[<span class="op">-</span>highCorr]
<span class="co"># check the new correlation matrix</span>
(<span class="kw">cor</span>(sdat))</code></pre></div>
<p>The absolute value of the elements in the correlation matrix after removal are all below 0.7. How strong does a correlation have to get, before you should start worrying about multicollinearity? There is no easy answer to that question. You can treat the threshold as a tuning parameter and pick one that gives you best prediction accuracy.</p>
</div>
<div id="sparse-variables" class="section level2">
<h2><span class="header-section-number">4.7</span> Sparse Variables</h2>
<p>Other than the highly related predictors, predictors with degenerate distributions can cause the problem too. Removing those variables can significantly improve some models’ performance and stability (such as linear regression and logistic regression but the tree based model is impervious to this type of predictors). One extreme example is a variable with a single value which is called zero-variance variable. Variables with very low frequency of unique values are near-zero variance predictors. In general, detecting those variables follows two rules:</p>
<ul>
<li>The fraction of unique values over the sample size</li>
<li>The ratio of the frequency of the most prevalent value to the frequency of the second most prevalent value.</li>
</ul>
<p><code>nearZeroVar()</code> function in the <code>caret</code> package can filter near-zero variance predictors according to the above rules. In order to show the useage of the function, let’s arbitaryly add some problematic variables to the origional data <code>sim.dat</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># make a copy</span>
zero_demo &lt;-<span class="st"> </span>sim.dat
<span class="co"># add two sparse variable zero1 only has one unique value zero2 is a</span>
<span class="co"># vector with the first element 1 and the rest are 0s</span>
zero_demo<span class="op">$</span>zero1 &lt;-<span class="st"> </span><span class="kw">rep</span>(<span class="dv">1</span>, <span class="kw">nrow</span>(zero_demo))
zero_demo<span class="op">$</span>zero2 &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">1</span>, <span class="kw">rep</span>(<span class="dv">0</span>, <span class="kw">nrow</span>(zero_demo) <span class="op">-</span><span class="st"> </span><span class="dv">1</span>))</code></pre></div>
<p>The function will return a vector of integers indicating which columns to remove:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">nearZeroVar</span>(zero_demo,<span class="dt">freqCut =</span> <span class="dv">95</span><span class="op">/</span><span class="dv">5</span>, <span class="dt">uniqueCut =</span> <span class="dv">10</span>)</code></pre></div>
<pre><code>## [1] 20 21</code></pre>
<p>As expected, it returns the two columns we generated. You can go ahead to remove them. Note the two arguments in the function <code>freqCut =</code> and <code>uniqueCut =</code> are corresponding to the previous two rules.</p>
<ul>
<li><code>freqCut</code>: the cutoff for the ratio of the most common value to the second most common value</li>
<li><code>uniqueCut</code>: the cutoff for the percentage of distinct values out of the number of total samples</li>
</ul>
</div>
<div id="re-encode-dummy-variables" class="section level2">
<h2><span class="header-section-number">4.8</span> Re-encode Dummy Variables</h2>
<p>A dummy variable is a binary variable (0/1) to represent subgroups of the sample. Sometimes we need to recode categories to smaller bits of information named “dummy variables.” For example, some questionnaires have five options for each question, A, B, C, D, and E. After you get the data, you will usually convert the corresponding categorical variables for each question into five nominal variables, and then use one of the options as the baseline.</p>
<p>Let’s encode <code>gender</code> and <code>house</code> from <code>sim.dat</code> to dummy variables. There are two ways to implement this. The first is to use <code>class.ind()</code> from <code>nnet</code> package. However, it only works on one variable at a time.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">dumVar &lt;-<span class="st"> </span>nnet<span class="op">::</span><span class="kw">class.ind</span>(sim.dat<span class="op">$</span>gender)
<span class="kw">head</span>(dumVar)</code></pre></div>
<pre><code>##      Female Male
## [1,]      1    0
## [2,]      1    0
## [3,]      0    1
## [4,]      0    1
## [5,]      0    1
## [6,]      0    1</code></pre>
<p>Since it is redundant to keep both, we need to remove one of them when modeling. Another more powerful function is <code>dummyVars()</code> from <code>caret</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># use &quot;origional variable name + level&quot; as new name</span>
dumMod &lt;-<span class="st"> </span><span class="kw">dummyVars</span>(<span class="op">~</span>gender <span class="op">+</span><span class="st"> </span>house <span class="op">+</span><span class="st"> </span>income, 
                    <span class="dt">data =</span> sim.dat, 
                    <span class="dt">levelsOnly =</span> F)
<span class="kw">head</span>(<span class="kw">predict</span>(dumMod, sim.dat))</code></pre></div>
<pre><code>##   gender.Female gender.Male house.No house.Yes income
## 1             1           0        0         1 120963
## 2             1           0        0         1 122008
## 3             0           1        0         1 114202
## 4             0           1        0         1 113616
## 5             0           1        0         1 124253
## 6             0           1        0         1 107661</code></pre>
<p><code>dummyVars()</code> can also use formula format. The variable on the right-hand side can be both categorical and numeric. For a numerical variable, the function will keep the variable unchanged. The advantage is that you can apply the function to a data frame without removing numerical variables. Other than that, the function can create interaction term:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">dumMod &lt;-<span class="st"> </span><span class="kw">dummyVars</span>(<span class="op">~</span>gender <span class="op">+</span><span class="st"> </span>house <span class="op">+</span><span class="st"> </span>income <span class="op">+</span><span class="st"> </span>income<span class="op">:</span>gender, 
                    <span class="dt">data =</span> sim.dat, 
                    <span class="dt">levelsOnly =</span> F)
<span class="kw">head</span>(<span class="kw">predict</span>(dumMod, sim.dat))</code></pre></div>
<pre><code>##   gender.Female gender.Male house.No house.Yes income
## 1             1           0        0         1 120963
## 2             1           0        0         1 122008
## 3             0           1        0         1 114202
## 4             0           1        0         1 113616
## 5             0           1        0         1 124253
## 6             0           1        0         1 107661
##   gender.Female:income gender.Male:income
## 1               120963                  0
## 2               122008                  0
## 3                    0             114202
## 4                    0             113616
## 5                    0             124253
## 6                    0             107661</code></pre>
<p>If you think the impact income levels on purchasing behavior is different for male and female, then you may add the interaction term between <code>income</code> and <code>gender</code>. You can do this by adding <code>income: gender</code> in the formula.</p>
<!--chapter:end:04-DataPreprocessing.Rmd-->
</div>
</div>
<div id="data-wrangling" class="section level1">
<h1><span class="header-section-number">5</span> Data Wrangling</h1>
<p>This chapter focuses on some of the most frequently used data manipulations and shows how to implement them in R and Python. It is critical to explore the data with descriptive statistics (mean, standard deviation, etc.) and data visualization before analysis. Transform data so that the data structure is in line with the requirements of the model. You also need to summarize the results after analysis.</p>
<p>Load the R packages first:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># install packages from CRAN</span>
p_needed &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&#39;readr&#39;</span>,<span class="st">&#39;dplyr&#39;</span>,<span class="st">&#39;data.table&#39;</span>,<span class="st">&#39;reshape2&#39;</span>,<span class="st">&#39;tidyr&#39;</span>)
packages &lt;-<span class="st"> </span><span class="kw">rownames</span>(<span class="kw">installed.packages</span>())
p_to_install &lt;-<span class="st"> </span>p_needed[<span class="op">!</span>(p_needed <span class="op">%in%</span><span class="st"> </span>packages)]
<span class="cf">if</span> (<span class="kw">length</span>(p_to_install) <span class="op">&gt;</span><span class="st"> </span><span class="dv">0</span>) {
    <span class="kw">install.packages</span>(p_to_install)
}

<span class="kw">lapply</span>(p_needed, require, <span class="dt">character.only =</span> <span class="ot">TRUE</span>)</code></pre></div>
<div id="read-and-write-data" class="section level2">
<h2><span class="header-section-number">5.1</span> Read and write data</h2>
<div id="readr" class="section level3">
<h3><span class="header-section-number">5.1.1</span> <code>readr</code></h3>
<p>You must be familiar with <code>read.csv()</code>, <code>read.table()</code> and <code>write.csv()</code> in base R. Here we will introduce a more efficient package from RStudio in 2015 for reading and writing data: <code>readr</code> package. The corresponding functions are <code>read_csv()</code>, <code>read_table()</code> and <code>write_csv()</code>. The commands look quite similar, but <code>readr</code> is different in the following respects:</p>
<ol style="list-style-type: decimal">
<li><p>It is 10x faster. The trick is that <code>readr</code> uses C++ to process the data quickly.</p></li>
<li><p>It doesn’t change the column names. The names can start with a number and “<code>.</code>” will not be substituted to “<code>_</code>”. For example:</p></li>
</ol>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">read_csv</span>(<span class="st">&quot;2015,2016,2017</span>
<span class="st">1,2,3</span>
<span class="st">4,5,6&quot;</span>)</code></pre></div>
<pre><code>## # A tibble: 2 x 3
##   `2015` `2016` `2017`
##    &lt;int&gt;  &lt;int&gt;  &lt;int&gt;
## 1      1      2      3
## 2      4      5      6</code></pre>
<ol style="list-style-type: decimal">
<li><p><code>readr</code> functions do not convert strings to factors by default, are able to parse dates and times and can automatically determine the data types in each column.</p></li>
<li><p>The killing character, in my opinion, is that <code>readr</code> provides <strong>progress bar</strong>. What makes you feel worse than waiting is not knowing how long you have to wait.</p></li>
</ol>
<div class="figure">
<img src="images/prograssbar.png" />

</div>
<p>The major functions of readr is to turn flat files into data frames:</p>
<ul>
<li><code>read_csv()</code>: reads comma delimited files</li>
<li><code>read_csv2()</code>: reads semicolon separated files (common in countries where <code>,</code> is used as the decimal place)</li>
<li><code>read_tsv()</code>: reads tab delimited files</li>
<li><code>read_delim()</code>: reads in files with any delimiter</li>
<li><code>read_fwf()</code>: reads fixed width files. You can specify fields either by their widths with <code>fwf_widths()</code> or their position with <code>fwf_positions()</code><br />
</li>
<li><code>read_table()</code>: reads a common variation of fixed width files where columns are separated by white space</li>
<li><code>read_log()</code>: reads Apache style log files</li>
</ul>
<p>The good thing is that those functions have similar syntax. Once you learn one, the others become easy. Here we will focus on <code>read_csv()</code>.</p>
<p>The most important information for <code>read_csv()</code> is the path to your data:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">sim.dat &lt;-<span class="st"> </span><span class="kw">read_csv</span>(<span class="st">&quot;http://bit.ly/2P5gTw4&quot;</span>)
<span class="kw">head</span>(sim.dat)</code></pre></div>
<pre class="pre"><code># A tibble: 6 x 19
    age gender income house store_exp online_exp store_trans online_trans    Q1
  &lt;int&gt; &lt;chr&gt;   &lt;dbl&gt; &lt;chr&gt;     &lt;dbl&gt;      &lt;dbl&gt;       &lt;int&gt;        &lt;int&gt; &lt;int&gt;
1    57 Female 1.21e5 Yes        529.       304.           2            2     4
2    63 Female 1.22e5 Yes        478.       110.           4            2     4
3    59 Male   1.14e5 Yes        491.       279.           7            2     5
4    60 Male   1.14e5 Yes        348.       142.          10            2     5
5    51 Male   1.24e5 Yes        380.       112.           4            4     4
6    59 Male   1.08e5 Yes        338.       196.           4            5     4
# ... with 10 more variables: Q2 &lt;int&gt;, Q3 &lt;int&gt;, Q4 &lt;int&gt;, Q5 &lt;int&gt;, Q6 &lt;int&gt;,
#   Q7 &lt;int&gt;, Q8 &lt;int&gt;, Q9 &lt;int&gt;, Q10 &lt;int&gt;, segment &lt;chr&gt;</code></pre>
<p>The function reads the file to R as a <code>tibble</code>. You can consider <code>tibble</code> as next iteration of the data frame. They are different with data frame for the following aspects:</p>
<ul>
<li>It never changes an input’s type (i.e., no more <code>stringsAsFactors = FALSE</code>!)</li>
<li>It never adjusts the names of variables</li>
<li>It has a refined print method that shows only the first 10 rows and all the columns that fit on the screen. You can also control the default print behavior by setting options.</li>
</ul>
<p>Refer to <a href="http://r4ds.had.co.nz/tibbles.html" class="uri">http://r4ds.had.co.nz/tibbles.html</a> for more information about ‘tibble’.</p>
<p>When you run <code>read_csv()</code> it prints out a column specification that gives the name and type of each column. To better understanding how <code>readr</code> works, it is helpful to type in some baby data set and check the results:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">dat &lt;-<span class="st"> </span><span class="kw">read_csv</span>(<span class="st">&quot;2015,2016,2017</span>
<span class="st">100,200,300</span>
<span class="st">canola,soybean,corn&quot;</span>)
<span class="kw">print</span>(dat)</code></pre></div>
<pre><code>## # A tibble: 2 x 3
##   `2015` `2016`  `2017`
##   &lt;chr&gt;  &lt;chr&gt;   &lt;chr&gt; 
## 1 100    200     300   
## 2 canola soybean corn</code></pre>
<p>You can also add comments on the top and tell R to skip those lines:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">dat &lt;-<span class="st"> </span><span class="kw">read_csv</span>(<span class="st">&quot;# I will never let you know that</span>
<span class="st">          # my favorite food is carrot</span>
<span class="st">          Date,Food,Mood</span>
<span class="st">          Monday,carrot,happy</span>
<span class="st">          Tuesday,carrot,happy</span>
<span class="st">          Wednesday,carrot,happy</span>
<span class="st">          Thursday,carrot,happy</span>
<span class="st">          Friday,carrot,happy</span>
<span class="st">          Saturday,carrot,extremely happy</span>
<span class="st">          Sunday,carrot,extremely happy&quot;</span>, 
          <span class="dt">skip =</span> <span class="dv">2</span>)
<span class="kw">print</span>(dat)</code></pre></div>
<pre><code>## # A tibble: 7 x 3
##   Date      Food   Mood           
##   &lt;chr&gt;     &lt;chr&gt;  &lt;chr&gt;          
## 1 Monday    carrot happy          
## 2 Tuesday   carrot happy          
## 3 Wednesday carrot happy          
## 4 Thursday  carrot happy          
## 5 Friday    carrot happy          
## 6 Saturday  carrot extremely happy
## 7 Sunday    carrot extremely happy</code></pre>
<p>If you don’t have column names, set <code>col_names = FALSE</code> then R will assign names “<code>X1</code>”,“<code>X2</code>”… to the columns:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">dat &lt;-<span class="st"> </span><span class="kw">read_csv</span>(<span class="st">&quot;Saturday,carrot,extremely happy</span>
<span class="st">          Sunday,carrot,extremely happy&quot;</span>, <span class="dt">col_names =</span> <span class="ot">FALSE</span>)
<span class="kw">print</span>(dat)</code></pre></div>
<pre><code>## # A tibble: 2 x 3
##   X1       X2     X3             
##   &lt;chr&gt;    &lt;chr&gt;  &lt;chr&gt;          
## 1 Saturday carrot extremely happy
## 2 Sunday   carrot extremely happy</code></pre>
<p>You can also pass <code>col_names</code> a character vector which will be used as the column names. Try to replace <code>col_names=FALSE</code> with <code>col_names=c(&quot;Date&quot;,&quot;Food&quot;,&quot;Mood&quot;)</code> and see what happen.</p>
<p>As mentioned before, you can use <code>read_csv2()</code> to read semicolon separated files:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">dat &lt;-<span class="st"> </span><span class="kw">read_csv2</span>(<span class="st">&quot;Saturday; carrot; extremely happy </span><span class="ch">\n</span><span class="st"> Sunday; carrot; extremely happy&quot;</span>, <span class="dt">col_names =</span> <span class="ot">FALSE</span>)</code></pre></div>
<pre><code>## Using &#39;,&#39; as decimal and &#39;.&#39; as grouping mark. Use read_delim() for more control.</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">print</span>(dat)</code></pre></div>
<pre><code>## # A tibble: 2 x 3
##   X1       X2     X3             
##   &lt;chr&gt;    &lt;chr&gt;  &lt;chr&gt;          
## 1 Saturday carrot extremely happy
## 2 Sunday   carrot extremely happy</code></pre>
<p>Here “<code>\n</code>” is a convenient shortcut for adding a new line.</p>
<p>You can use <code>read_tsv()</code> to read tab delimited files：</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">dat &lt;-<span class="st"> </span><span class="kw">read_tsv</span>(<span class="st">&quot;every</span><span class="ch">\t</span><span class="st">man</span><span class="ch">\t</span><span class="st">is</span><span class="ch">\t</span><span class="st">a</span><span class="ch">\t</span><span class="st">poet</span><span class="ch">\t</span><span class="st">when</span><span class="ch">\t</span><span class="st">he</span><span class="ch">\t</span><span class="st">is</span><span class="ch">\t</span><span class="st">in</span><span class="ch">\t</span><span class="st">love</span><span class="ch">\n</span><span class="st">&quot;</span>, 
    <span class="dt">col_names =</span> <span class="ot">FALSE</span>)
<span class="kw">print</span>(dat)</code></pre></div>
<pre><code>## # A tibble: 1 x 10
##   X1    X2    X3    X4    X5    X6    X7    X8   
##   &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;
## 1 every man   is    a     poet  when  he    is   
## # ... with 2 more variables: X9 &lt;chr&gt;, X10 &lt;chr&gt;</code></pre>
<p>Or more generally, you can use <code>read_delim()</code> and assign separating character：</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">dat &lt;-<span class="st"> </span><span class="kw">read_delim</span>(<span class="st">&quot;THE|UNBEARABLE|RANDOMNESS|OF|LIFE</span><span class="ch">\n</span><span class="st">&quot;</span>, 
    <span class="dt">delim =</span> <span class="st">&quot;|&quot;</span>, <span class="dt">col_names =</span> <span class="ot">FALSE</span>)
<span class="kw">print</span>(dat)</code></pre></div>
<pre><code>## # A tibble: 1 x 5
##   X1    X2         X3         X4    X5   
##   &lt;chr&gt; &lt;chr&gt;      &lt;chr&gt;      &lt;chr&gt; &lt;chr&gt;
## 1 THE   UNBEARABLE RANDOMNESS OF    LIFE</code></pre>
<p>Another situation you will often run into is the missing value. In marketing survey, people like to use “99” to represent missing. You can tell R to set all observation with value “99” as missing when you read the data:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">dat &lt;-<span class="st"> </span><span class="kw">read_csv</span>(<span class="st">&quot;Q1,Q2,Q3</span>
<span class="st">               5, 4,99&quot;</span>, 
               <span class="dt">na =</span> <span class="st">&quot;99&quot;</span>)
<span class="kw">print</span>(dat)</code></pre></div>
<pre><code>## # A tibble: 1 x 3
##      Q1    Q2 Q3   
##   &lt;int&gt; &lt;int&gt; &lt;chr&gt;
## 1     5     4 &lt;NA&gt;</code></pre>
<p>For writing data back to disk, you can use <code>write_csv()</code> and <code>write_tsv()</code>. The following two characters of the two functions increase the chances of the output file being read back in correctly:</p>
<ul>
<li>Encode strings in UTF-8</li>
<li>Save dates and date-times in ISO8601 format so they are easily parsed elsewhere</li>
</ul>
<p>For example:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">write_csv</span>(sim.dat, <span class="st">&quot;sim_dat.csv&quot;</span>)</code></pre></div>
<p>For other data types, you can use the following packages:</p>
<ul>
<li><code>Haven</code>: SPSS, Stata and SAS data</li>
<li><code>Readxl</code> and <code>xlsx</code>: excel data(.xls and .xlsx)</li>
<li><code>DBI</code>: given data base, such as RMySQL, RSQLite and RPostgreSQL, read data directly from the database using SQL</li>
</ul>
<p>Some other useful materials:</p>
<ul>
<li>For getting data from the internet, you can refer to the book “XML and Web Technologies for Data Sciences with R”.<br />
</li>
<li><a href="https://cran.r-project.org/doc/manuals/r-release/R-data.html#Acknowledgements">R data import/export manual</a></li>
<li><code>rio</code> package：<a href="https://github.com/leeper/rio" class="uri">https://github.com/leeper/rio</a></li>
</ul>
</div>
<div id="data.table-enhanced-data.frame" class="section level3">
<h3><span class="header-section-number">5.1.2</span> <code>data.table</code>— enhanced <code>data.frame</code></h3>
<p>What is <code>data.table</code>? It is an R package that provides an enhanced version of <code>data.frame</code>. The most used object in R is <code>data frame</code>. Before we move on, let’s briefly review some basic characters and manipulations of data.frame:</p>
<ul>
<li>It is a set of rows and columns.</li>
<li>Each row is of the same length and data type</li>
<li>Every column is of the same length but can be of differing data types</li>
<li>It has characteristics of both a matrix and a list</li>
<li>It uses <code>[]</code> to subset data</li>
</ul>
<p>We will use the clothes customer data to illustrate. There are two dimensions in <code>[]</code>. The first one indicates the row and second one indicates column. It uses a comma to separate them.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># read data</span>
sim.dat &lt;-<span class="st"> </span>readr<span class="op">::</span><span class="kw">read_csv</span>(<span class="st">&quot;http://bit.ly/2P5gTw4&quot;</span>)</code></pre></div>
<pre><code>## Parsed with column specification:
## cols(
##   age = col_integer(),
##   gender = col_character(),
##   income = col_double(),
##   house = col_character(),
##   store_exp = col_double(),
##   online_exp = col_double(),
##   store_trans = col_integer(),
##   online_trans = col_integer(),
##   Q1 = col_integer(),
##   Q2 = col_integer(),
##   Q3 = col_integer(),
##   Q4 = col_integer(),
##   Q5 = col_integer(),
##   Q6 = col_integer(),
##   Q7 = col_integer(),
##   Q8 = col_integer(),
##   Q9 = col_integer(),
##   Q10 = col_integer(),
##   segment = col_character()
## )</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># subset the first two rows</span>
sim.dat[<span class="dv">1</span><span class="op">:</span><span class="dv">2</span>, ]
<span class="co"># subset the first two rows and column 3 and 5</span>
sim.dat[<span class="dv">1</span><span class="op">:</span><span class="dv">2</span>, <span class="kw">c</span>(<span class="dv">3</span>, <span class="dv">5</span>)]
<span class="co"># get all rows with age&gt;70</span>
sim.dat[sim.dat<span class="op">$</span>age <span class="op">&gt;</span><span class="st"> </span><span class="dv">70</span>, ]
<span class="co"># get rows with age&gt; 60 and gender is Male select column 3 and 4</span>
sim.dat[sim.dat<span class="op">$</span>age <span class="op">&gt;</span><span class="st"> </span><span class="dv">68</span> <span class="op">&amp;</span><span class="st"> </span>sim.dat<span class="op">$</span>gender <span class="op">==</span><span class="st"> &quot;Male&quot;</span>, <span class="dv">3</span><span class="op">:</span><span class="dv">4</span>]</code></pre></div>
<p>Remember that there are usually different ways to conduct the same manipulation. For example, the following code presents three ways to calculate an average number of online transactions for male and female:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">tapply</span>(sim.dat<span class="op">$</span>online_trans, sim.dat<span class="op">$</span>gender, mean)

<span class="kw">aggregate</span>(online_trans <span class="op">~</span><span class="st"> </span>gender, <span class="dt">data =</span> sim.dat, mean)

sim.dat <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">group_by</span>(gender) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">summarise</span>(<span class="dt">Avg_online_trans =</span> <span class="kw">mean</span>(online_trans))</code></pre></div>
<p>There is no gold standard to choose a specific function to manipulate data. The goal is to solve the real problem, not the tool itself. So just use whatever tool that is convenient for you.</p>
<p>The way to use <code>[]</code> is straightforward. But the manipulations are limited. If you need more complicated data reshaping or aggregation, there are other packages to use such as <code>dplyr</code>, <code>reshape2</code>, <code>tidyr</code> etc. But the usage of those packages are not as straightforward as <code>[]</code>. You often need to change functions. Keeping related operations together, such as subset, group, update, join etc, will allow for:</p>
<ul>
<li>concise, consistent and readable syntax irrespective of the set of operations you would like to perform to achieve your end goal</li>
<li>performing data manipulation fluidly without the cognitive burden of having to change among different functions</li>
<li>by knowing precisely the data required for each operation, you can automatically optimize operations effectively</li>
</ul>
<p><code>data.table</code> is the package for that. If you are not familiar with other data manipulating packages and are interested in reducing programming time tremendously, then this package is for you.</p>
<p>Other than extending the function of <code>[]</code>, <code>data.table</code> has the following advantages:</p>
<ul>
<li>Offers fast import, subset, grouping, update, and joins for large data files</li>
<li>It is easy to turn data frame to data table</li>
<li>Can behave just like a data frame</li>
</ul>
<p>You need to install and load the package:</p>
<p>Use <code>data.table()</code> to convert the existing data frame <code>sim.dat</code> to data table:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">dt &lt;-<span class="st"> </span><span class="kw">data.table</span>(sim.dat)
<span class="kw">class</span>(dt)</code></pre></div>
<pre><code>## [1] &quot;data.table&quot; &quot;data.frame&quot;</code></pre>
<p>Calculate mean for counts of online transactions:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">dt[, <span class="kw">mean</span>(online_trans)]</code></pre></div>
<pre><code>## [1] 13.55</code></pre>
<p>You can’t do the same thing using data frame:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">sim.dat[,<span class="kw">mean</span>(online_trans)]</code></pre></div>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html">Error in mean(online_trans) : object &#39;online_trans&#39; not found</code></pre></div>
<p>If you want to calculate mean by group as before, set “<code>by =</code>” argument:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">dt[ , <span class="kw">mean</span>(online_trans), by =<span class="st"> </span>gender]</code></pre></div>
<pre><code>##    gender    V1
## 1: Female 15.38
## 2:   Male 11.26</code></pre>
<p>You can group by more than one variables. For example, group by “<code>gender</code>” and “<code>house</code>”:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">dt[ , <span class="kw">mean</span>(online_trans), by =<span class="st"> </span>.(gender, house)]</code></pre></div>
<pre><code>##    gender house     V1
## 1: Female   Yes 11.312
## 2:   Male   Yes  8.772
## 3: Female    No 19.146
## 4:   Male    No 16.486</code></pre>
<p>Assign column names for aggregated variables:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">dt[ , .(<span class="dt">avg =</span> <span class="kw">mean</span>(online_trans)), by =<span class="st"> </span>.(gender, house)]</code></pre></div>
<pre><code>##    gender house    avg
## 1: Female   Yes 11.312
## 2:   Male   Yes  8.772
## 3: Female    No 19.146
## 4:   Male    No 16.486</code></pre>
<p><code>data.table</code> can accomplish all operations that <code>aggregate()</code> and <code>tapply()</code>can do for data frame.</p>
<ul>
<li>General setting of <code>data.table</code></li>
</ul>
<p>Different from data frame, there are three arguments for data table:</p>
<center>
<img src="images/datable1.png" />
</center>
<p>It is analogous to SQL. You don’t have to know SQL to learn data table. But experience with SQL will help you understand data table. In SQL, you select column <code>j</code> (use command <code>SELECT</code>) for row <code>i</code> (using command <code>WHERE</code>). <code>GROUP BY</code> in SQL will assign the variable to group the observations.</p>
<center>
<img src="images/rSQL.png" />
</center>
<p>Let’s review our previous code:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">dt[ , <span class="kw">mean</span>(online_trans), by =<span class="st"> </span>gender]</code></pre></div>
<p>The code above is equal to the following SQL：</p>
<div class="sourceCode"><pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">SELECT</span>  gender, <span class="fu">avg</span>(online_trans) <span class="kw">FROM</span> sim.dat <span class="kw">GROUP</span> <span class="kw">BY</span> gender</code></pre></div>
<p>R code:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">dt[ , .(<span class="dt">avg =</span> <span class="kw">mean</span>(online_trans)), by =<span class="st"> </span>.(gender, house)]</code></pre></div>
<p>is equal to SQL：</p>
<div class="sourceCode"><pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">SELECT</span> gender, house, <span class="fu">avg</span>(online_trans) <span class="kw">AS</span> <span class="fu">avg</span> <span class="kw">FROM</span> sim.dat <span class="kw">GROUP</span> <span class="kw">BY</span> gender, house</code></pre></div>
<p>R code：</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">dt[ age <span class="op">&lt;</span><span class="st"> </span><span class="dv">40</span>, .(<span class="dt">avg =</span> <span class="kw">mean</span>(online_trans)), by =<span class="st"> </span>.(gender, house)]</code></pre></div>
<p>is equal to SQL：</p>
<div class="sourceCode"><pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">SELECT</span> gender, house, <span class="fu">avg</span>(online_trans) <span class="kw">AS</span> <span class="fu">avg</span> <span class="kw">FROM</span> sim.dat <span class="kw">WHERE</span> age &lt; <span class="dv">40</span> <span class="kw">GROUP</span> <span class="kw">BY</span> gender, house</code></pre></div>
<p>You can see the analogy between <code>data.table</code> and <code>SQL</code>. Now let’s focus on operations in data table.</p>
<ul>
<li>select row</li>
</ul>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># select rows with age&lt;20 and income &gt; 80000</span>
dt[age <span class="op">&lt;</span><span class="st"> </span><span class="dv">20</span> <span class="op">&amp;</span><span class="st"> </span>income <span class="op">&gt;</span><span class="st"> </span><span class="dv">80000</span>]</code></pre></div>
<pre><code>##    age gender income house store_exp online_exp
## 1:  19 Female  83535    No     227.7       1491
## 2:  18 Female  89416   Yes     209.5       1926
## 3:  19 Female  92813    No     186.7       1042
##    store_trans online_trans Q1 Q2 Q3 Q4 Q5 Q6 Q7 Q8 Q9
## 1:           1           22  2  1  1  2  4  1  4  2  4
## 2:           3           28  2  1  1  1  4  1  4  2  4
## 3:           2           18  3  1  1  2  4  1  4  3  4
##    Q10 segment
## 1:   1   Style
## 2:   1   Style
## 3:   1   Style</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># select the first two rows</span>
dt[<span class="dv">1</span><span class="op">:</span><span class="dv">2</span>]</code></pre></div>
<pre><code>##    age gender income house store_exp online_exp
## 1:  57 Female 120963   Yes     529.1      303.5
## 2:  63 Female 122008   Yes     478.0      109.5
##    store_trans online_trans Q1 Q2 Q3 Q4 Q5 Q6 Q7 Q8 Q9
## 1:           2            2  4  2  1  2  1  4  1  4  2
## 2:           4            2  4  1  1  2  1  4  1  4  1
##    Q10 segment
## 1:   4   Price
## 2:   4   Price</code></pre>
<ul>
<li>select column</li>
</ul>
<p>Selecting columns in <code>data.table</code> don’t need <code>$</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># select column “age” but return it as a vector</span>
<span class="co"># the argument for row is empty so the result will return all observations</span>
ans &lt;-<span class="st"> </span>dt[, age]
<span class="kw">head</span>(ans)</code></pre></div>
<pre><code>## [1] 57 63 59 60 51 59</code></pre>
<p>To return <code>data.table</code> object, put column names in <code>list()</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Select age and online_exp columns and return as a data.table instead</span>
ans &lt;-<span class="st"> </span>dt[, <span class="kw">list</span>(age, online_exp)]
<span class="kw">head</span>(ans)</code></pre></div>
<p>Or you can also put column names in <code>.()</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">ans &lt;-<span class="st"> </span>dt[, .(age, online_exp)]
<span class="co"># head(ans)</span></code></pre></div>
<p>To select all columns from “<code>age</code>” to “<code>income</code>”:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">ans &lt;-<span class="st"> </span>dt[, age<span class="op">:</span>income, with =<span class="st"> </span><span class="ot">FALSE</span>]
<span class="kw">head</span>(ans,<span class="dv">2</span>)</code></pre></div>
<pre><code>##    age gender income
## 1:  57 Female 120963
## 2:  63 Female 122008</code></pre>
<p>Delete columns using <code>-</code> or <code>!</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># delete columns from  age to online_exp</span>
ans &lt;-<span class="st"> </span>dt[, <span class="op">-</span>(age<span class="op">:</span>online_exp), with =<span class="st"> </span><span class="ot">FALSE</span>]
ans &lt;-<span class="st"> </span>dt[, <span class="op">!</span>(age<span class="op">:</span>online_exp), with =<span class="st"> </span><span class="ot">FALSE</span>]</code></pre></div>
<ul>
<li>tabulation</li>
</ul>
<p>In data table. <code>.N</code> means to count。</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># row count</span>
dt[, .N] </code></pre></div>
<pre><code>## [1] 1000</code></pre>
<p>If you assign the group variable, then it will count by groups:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># counts by gender</span>
dt[, .N, by=<span class="st"> </span>gender]  </code></pre></div>
<pre><code>##    gender   N
## 1: Female 554
## 2:   Male 446</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># for those younger than 30, count by gender</span>
 dt[age <span class="op">&lt;</span><span class="st"> </span><span class="dv">30</span>, .(<span class="dt">count=</span>.N), by=<span class="st"> </span>gender] </code></pre></div>
<pre><code>##    gender count
## 1: Female   292
## 2:   Male    86</code></pre>
<p>Order table:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># get records with the highest 5 online expense:</span>
<span class="kw">head</span>(dt[<span class="kw">order</span>(<span class="op">-</span>online_exp)],<span class="dv">5</span>) </code></pre></div>
<pre class="pre"><code>   age gender   income house store_exp online_exp store_trans ...
1:  40 Female 217599.7    No  7023.684   9479.442          10
2:  41 Female       NA   Yes  3786.740   8638.239          14
3:  36   Male 228550.1   Yes  3279.621   8220.555           8
4:  31 Female 159508.1   Yes  5177.081   8005.932          11
5:  43 Female 190407.4   Yes  4694.922   7875.562           6
...</code></pre>
<p>Since data table keep some characters of data frame, they share some operations:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">dt[<span class="kw">order</span>(<span class="op">-</span>online_exp)][<span class="dv">1</span><span class="op">:</span><span class="dv">5</span>]</code></pre></div>
<p>You can also order the table by more than one variable. The following code will order the table by <code>gender</code>, then order within <code>gender</code> by <code>online_exp</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">dt[<span class="kw">order</span>(gender, <span class="op">-</span>online_exp)][<span class="dv">1</span><span class="op">:</span><span class="dv">5</span>]</code></pre></div>
<ul>
<li>Use <code>fread()</code> to import dat</li>
</ul>
<p>Other than <code>read.csv</code> in base R, we have introduced ‘read_csv’ in ‘readr’. <code>read_csv</code> is much faster and will provide progress bar which makes user feel much better (at least make me feel better). <code>fread()</code> in <code>data.table</code> further increase the efficiency of reading data. The following are three examples of reading the same data file <code>topic.csv</code>. The file includes text data scraped from an agriculture forum with 209670 rows and 6 columns:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">system.time</span>(topic&lt;-<span class="kw">read.csv</span>(<span class="st">&quot;http://bit.ly/2zam5ny&quot;</span>))</code></pre></div>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html">   user  system elapsed 
  3.561   0.051   4.888 </code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">system.time</span>(topic&lt;-readr<span class="op">::</span><span class="kw">read_csv</span>(<span class="st">&quot;http://bit.ly/2zam5ny&quot;</span>))</code></pre></div>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html">   user  system elapsed 
  0.409   0.032   2.233 </code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">system.time</span>(topic&lt;-data.table<span class="op">::</span><span class="kw">fread</span>(<span class="st">&quot;http://bit.ly/2zam5ny&quot;</span>))</code></pre></div>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html">   user  system elapsed 
  0.276   0.096   1.117 </code></pre></div>
<p>It is clear that <code>read_csv()</code> is much faster than <code>read.csv()</code>. <code>fread()</code> is a little faster than <code>read_csv()</code>. As the size increasing, the difference will become for significant. Note that <code>fread()</code> will read file as <code>data.table</code> by default.</p>
</div>
</div>
<div id="summarize-data" class="section level2">
<h2><span class="header-section-number">5.2</span> Summarize data</h2>
<div id="apply-lapply-and-sapply-in-base-r" class="section level3">
<h3><span class="header-section-number">5.2.1</span> <code>apply()</code>, <code>lapply()</code> and <code>sapply()</code> in base R</h3>
<p>There are some powerful functions to summarize data in base R, such as <code>apply()</code>, <code>lapply()</code> and <code>sapply()</code>. They do the same basic things and are all from “apply” family: apply functions over parts of data. They differ in two important respects:</p>
<ol style="list-style-type: decimal">
<li>the type of object they apply to</li>
<li>the type of result they will return</li>
</ol>
<p>When do we use <code>apply()</code>? When we want to apply a function to margins of an array or matrix. That means our data need to be structured. The operations can be very flexible. It returns a vector or array or list of values obtained by applying a function to margins of an array or matrix.</p>
<p>For example you can compute row and column sums for a matrix:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">## simulate a matrix
x &lt;-<span class="st"> </span><span class="kw">cbind</span>(<span class="dt">x1 =</span><span class="dv">1</span><span class="op">:</span><span class="dv">8</span>, <span class="dt">x2 =</span> <span class="kw">c</span>(<span class="dv">4</span><span class="op">:</span><span class="dv">1</span>, <span class="dv">2</span><span class="op">:</span><span class="dv">5</span>))
<span class="kw">dimnames</span>(x)[[<span class="dv">1</span>]] &lt;-<span class="st"> </span>letters[<span class="dv">1</span><span class="op">:</span><span class="dv">8</span>]
<span class="kw">apply</span>(x, <span class="dv">2</span>, mean)</code></pre></div>
<pre><code>##  x1  x2 
## 4.5 3.0</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">col.sums &lt;-<span class="st"> </span><span class="kw">apply</span>(x, <span class="dv">2</span>, sum)
row.sums &lt;-<span class="st"> </span><span class="kw">apply</span>(x, <span class="dv">1</span>, sum)</code></pre></div>
<p>You can also apply other functions:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">ma &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="kw">c</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">4</span>, <span class="dv">1</span>, <span class="dv">6</span><span class="op">:</span><span class="dv">8</span>), <span class="dt">nrow =</span> <span class="dv">2</span>)
ma</code></pre></div>
<pre><code>##      [,1] [,2] [,3] [,4]
## [1,]    1    3    1    7
## [2,]    2    4    6    8</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">apply</span>(ma, <span class="dv">1</span>, table)  <span class="co">#--&gt; a list of length 2</span></code></pre></div>
<pre><code>## [[1]]
## 
## 1 3 7 
## 2 1 1 
## 
## [[2]]
## 
## 2 4 6 8 
## 1 1 1 1</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">apply</span>(ma, <span class="dv">1</span>, stats<span class="op">::</span>quantile) <span class="co"># 5 x n matrix with rownames</span></code></pre></div>
<pre><code>##      [,1] [,2]
## 0%      1  2.0
## 25%     1  3.5
## 50%     2  5.0
## 75%     4  6.5
## 100%    7  8.0</code></pre>
<p>Results can have different lengths for each call. This is a trickier example. What will you get?</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">## Example with different lengths for each call
z &lt;-<span class="st"> </span><span class="kw">array</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">24</span>, <span class="dt">dim =</span> <span class="dv">2</span><span class="op">:</span><span class="dv">4</span>)
zseq &lt;-<span class="st"> </span><span class="kw">apply</span>(z, <span class="dv">1</span><span class="op">:</span><span class="dv">2</span>, <span class="cf">function</span>(x) <span class="kw">seq_len</span>(<span class="kw">max</span>(x)))
zseq         ## a 2 x 3 matrix
<span class="kw">typeof</span>(zseq) ## list
<span class="kw">dim</span>(zseq) ## 2 3
zseq[<span class="dv">1</span>,]
<span class="kw">apply</span>(z, <span class="dv">3</span>, <span class="cf">function</span>(x) <span class="kw">seq_len</span>(<span class="kw">max</span>(x)))</code></pre></div>
<ul>
<li><code>lapply()</code> applies a function over a list, data.frame or vector and returns a list of the same length.</li>
<li><code>sapply()</code> is a user-friendly version and wrapper of <code>lapply()</code>. By default it returns a vector, matrix or if <code>simplify = &quot;array&quot;</code>, an array if appropriate. <code>apply(x, f, simplify = FALSE, USE.NAMES = FALSE)</code> is the same as <code>lapply(x, f)</code>. If <code>simplify=TRUE</code>, then it will return a <code>data.frame</code> instead of <code>list</code>.</li>
</ul>
<p>Let’s use some data with context to help you better understand the functions.</p>
<ul>
<li>Get the mean and standard deviation of all numerical variables in the dataset.</li>
</ul>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Read data</span>
sim.dat &lt;-<span class="st"> </span><span class="kw">read.csv</span>(<span class="st">&quot;http://bit.ly/2P5gTw4&quot;</span>)
<span class="co"># Get numerical variables</span>
sdat &lt;-<span class="st"> </span>sim.dat[, <span class="op">!</span><span class="kw">lapply</span>(sim.dat, class) <span class="op">==</span><span class="st"> &quot;factor&quot;</span>]
## Try the following code with apply() function apply(sim.dat,2,class)
## What is the problem?</code></pre></div>
<p>The data frame <code>sdat</code> only includes numeric columns. Now we can go head and use <code>apply()</code> to get mean and standard deviation for each column:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">apply</span>(sdat, <span class="dt">MARGIN=</span><span class="dv">2</span>,<span class="cf">function</span>(x) <span class="kw">mean</span>(<span class="kw">na.omit</span>(x)))</code></pre></div>
<pre><code>##          age       income    store_exp   online_exp 
##    3.884e+01    1.135e+05    1.357e+03    2.120e+03 
##  store_trans online_trans           Q1           Q2 
##    5.350e+00    1.355e+01    3.101e+00    1.823e+00 
##           Q3           Q4           Q5           Q6 
##    1.992e+00    2.763e+00    2.945e+00    2.448e+00 
##           Q7           Q8           Q9          Q10 
##    3.434e+00    2.396e+00    3.085e+00    2.320e+00</code></pre>
<p>Here we defined a function using <code>function(x) mean(na.omit(x))</code>. It is a very simple function. It tells R to ignore the missing value when calculating the mean. <code>MARGIN=2</code> tells R to apply the function to each column. It is not hard to guess what <code>MARGIN=1</code> mean. The result show that the average online expense is much higher than store expense. You can also compare the average scores across different questions. The command to calculate standard deviation is very similar. The only difference is to change <code>mean()</code> to <code>sd()</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">apply</span>(sdat, <span class="dt">MARGIN=</span><span class="dv">2</span>,<span class="cf">function</span>(x) <span class="kw">sd</span>(<span class="kw">na.omit</span>(x)))</code></pre></div>
<pre><code>##          age       income    store_exp   online_exp 
##       16.417    49842.287     2774.400     1731.224 
##  store_trans online_trans           Q1           Q2 
##        3.696        7.957        1.450        1.168 
##           Q3           Q4           Q5           Q6 
##        1.402        1.155        1.284        1.439 
##           Q7           Q8           Q9          Q10 
##        1.456        1.154        1.118        1.136</code></pre>
<p>Even the average online expense is higher than store expense, the standard deviation for store expense is much higher than online expense which indicates there is very likely some big/small purchase in store. We can check it quickly:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">summary</span>(sdat<span class="op">$</span>store_exp)</code></pre></div>
<pre><code>##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
##    -500     205     329    1357     597   50000</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">summary</span>(sdat<span class="op">$</span>online_exp)</code></pre></div>
<pre><code>##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
##      69     420    1942    2120    2441    9479</code></pre>
<p>There are some odd values in store expense. The minimum value is -500 which indicates that you should preprocess data before analyzing it. Checking those simple statistics will help you better understand your data. It then gives you some idea how to preprocess and analyze them. How about using <code>lapply()</code> and <code>sapply()</code>?</p>
<p>Run the following code and compare the results:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">lapply</span>(sdat, <span class="cf">function</span>(x) <span class="kw">sd</span>(<span class="kw">na.omit</span>(x)))
<span class="kw">sapply</span>(sdat, <span class="cf">function</span>(x) <span class="kw">sd</span>(<span class="kw">na.omit</span>(x)))
<span class="kw">sapply</span>(sdat, <span class="cf">function</span>(x) <span class="kw">sd</span>(<span class="kw">na.omit</span>(x)), <span class="dt">simplify =</span> <span class="ot">FALSE</span>)</code></pre></div>
</div>
<div id="dplyr-package" class="section level3">
<h3><span class="header-section-number">5.2.2</span> <code>dplyr</code> package</h3>
<p><code>dplyr</code> provides a flexible grammar of data manipulation focusing on tools for working with data frames (hence the <code>d</code> in the name). It is faster and more friendly:</p>
<ul>
<li>It identifies the most important data manipulations and make they easy to use from R</li>
<li>It performs faster for in-memory data by writing key pieces in C++ using <code>Rcpp</code></li>
<li>The interface is the same for data frame, data table or database.</li>
</ul>
<p>We will illustrate the following functions in order:</p>
<ol style="list-style-type: decimal">
<li>Display</li>
<li>Subset</li>
<li>Summarize</li>
<li>Create new variable</li>
<li>Merge</li>
</ol>
<p><strong>Display</strong></p>
<ul>
<li><code>tbl_df()</code>: Convert the data to <code>tibble</code> which offers better checking and printing capabilities than traditional data frames. It will adjust output width according to fit the current window.</li>
</ul>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">tbl_df</span>(sim.dat)</code></pre></div>
<ul>
<li><code>glimpse()</code>: This is like a transposed version of <code>tbl_df()</code></li>
</ul>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">glimpse</span>(sim.dat)</code></pre></div>
<p><strong>Subset</strong></p>
<p>Get rows with <code>income</code> more than 300000:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">filter</span>(sim.dat, income <span class="op">&gt;</span><span class="dv">300000</span>) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">tbl_df</span>()</code></pre></div>
<p>Here we meet a new operator <code>%&gt;%</code>. It is called “Pipe operator” which pipes a value forward into an expression or function call. What you get in the left operation will be the first argument or the only argument in the right operation.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">f</span>(y) =<span class="st"> </span><span class="kw">f</span>(x, y)
y <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">f</span>(x, ., z) =<span class="st"> </span><span class="kw">f</span>(x, y, z )</code></pre></div>
<p>It is an operator from <code>magrittr</code> which can be really beneficial. Look at the following code. Can you tell me what it does?</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">ave_exp &lt;-<span class="st"> </span><span class="kw">filter</span>( 
  <span class="kw">summarise</span>(
    <span class="kw">group_by</span>( 
      <span class="kw">filter</span>(
        sim.dat, 
        <span class="op">!</span><span class="kw">is.na</span>(income)
      ), 
      segment
    ), 
    <span class="dt">ave_online_exp =</span> <span class="kw">mean</span>(online_exp), 
    <span class="dt">n =</span> <span class="kw">n</span>()
  ), 
  n <span class="op">&gt;</span><span class="st"> </span><span class="dv">200</span>
) </code></pre></div>
<p>Now look at the identical code using “<code>%&gt;%</code>”:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">ave_exp &lt;-<span class="st"> </span>sim.dat <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st"> </span><span class="kw">filter</span>(<span class="op">!</span><span class="kw">is.na</span>(income)) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st"> </span><span class="kw">group_by</span>(segment) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st"> </span><span class="kw">summarise</span>( 
   <span class="dt">ave_online_exp =</span> <span class="kw">mean</span>(online_exp), 
   <span class="dt">n =</span> <span class="kw">n</span>() ) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">filter</span>(n <span class="op">&gt;</span><span class="st"> </span><span class="dv">200</span>)</code></pre></div>
<p>Isn’t it much more straightforward now? Let’s read it:</p>
<ol style="list-style-type: decimal">
<li>Delete observations from <code>sim.dat</code> with missing income values</li>
<li>Group the data from step 1 by variable <code>segment</code></li>
<li>Calculate mean of online expense for each segment and save the result as a new variable named <code>ave_online_exp</code></li>
<li>Calculate the size of each segment and saved it as a new variable named <code>n</code></li>
<li>Get segments with size larger than 200</li>
</ol>
<p>You can use <code>distinct()</code> to delete duplicated rows.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">dplyr<span class="op">::</span><span class="kw">distinct</span>(sim.dat)</code></pre></div>
<p><code>sample_frac()</code> will randomly select some rows with a specified percentage. <code>sample_n()</code> can randomly select rows with a specified number.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">dplyr<span class="op">::</span><span class="kw">sample_frac</span>(sim.dat, <span class="fl">0.5</span>, <span class="dt">replace =</span> <span class="ot">TRUE</span>) 
dplyr<span class="op">::</span><span class="kw">sample_n</span>(sim.dat, <span class="dv">10</span>, <span class="dt">replace =</span> <span class="ot">TRUE</span>) </code></pre></div>
<p><code>slice()</code> will select rows by position:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">dplyr<span class="op">::</span><span class="kw">slice</span>(sim.dat, <span class="dv">10</span><span class="op">:</span><span class="dv">15</span>) </code></pre></div>
<p>It is equivalent to <code>sim.dat[10:15,]</code>.</p>
<p><code>top_n()</code> will select the order top n entries:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">dplyr<span class="op">::</span><span class="kw">top_n</span>(sim.dat,<span class="dv">2</span>,income)</code></pre></div>
<p>If you want to select columns instead of rows, you can use <code>select()</code>. The following are some sample codes:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># select by column name</span>
dplyr<span class="op">::</span><span class="kw">select</span>(sim.dat,income,age,store_exp)

<span class="co"># select columns whose name contains a character string</span>
dplyr<span class="op">::</span><span class="kw">select</span>(sim.dat, <span class="kw">contains</span>(<span class="st">&quot;_&quot;</span>))

<span class="co"># select columns whose name ends with a character string</span>
<span class="co"># similar there is &quot;starts_with&quot;</span>
dplyr<span class="op">::</span><span class="kw">select</span>(sim.dat, <span class="kw">ends_with</span>(<span class="st">&quot;e&quot;</span>))

<span class="co"># select columns Q1,Q2,Q3,Q4 and Q5</span>
<span class="kw">select</span>(sim.dat, <span class="kw">num_range</span>(<span class="st">&quot;Q&quot;</span>, <span class="dv">1</span><span class="op">:</span><span class="dv">5</span>)) 

<span class="co"># select columns whose names are in a group of names</span>
dplyr<span class="op">::</span><span class="kw">select</span>(sim.dat, <span class="kw">one_of</span>(<span class="kw">c</span>(<span class="st">&quot;age&quot;</span>, <span class="st">&quot;income&quot;</span>)))

<span class="co"># select columns between age and online_exp</span>
dplyr<span class="op">::</span><span class="kw">select</span>(sim.dat, age<span class="op">:</span>online_exp)

<span class="co"># select all columns except for age</span>
dplyr<span class="op">::</span><span class="kw">select</span>(sim.dat, <span class="op">-</span>age)</code></pre></div>
<p><strong>Summarize</strong></p>
<p>A standard marketing problem is customer segmentation. It usually starts with designing survey and collecting data. Then run a cluster analysis on the data to get customer segments. Once we have different segments, the next is to understand how each group of customer look like by summarizing some key metrics. For example, we can do the following data aggregation for different segments of clothes customers.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">sim.dat <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">group_by</span>(segment) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">summarise</span>(<span class="dt">Age =</span> <span class="kw">round</span>(<span class="kw">mean</span>(<span class="kw">na.omit</span>(age)), <span class="dv">0</span>), 
            <span class="dt">FemalePct =</span> <span class="kw">round</span>(<span class="kw">mean</span>(gender <span class="op">==</span><span class="st"> &quot;Female&quot;</span>), <span class="dv">2</span>), 
            <span class="dt">HouseYes =</span> <span class="kw">round</span>(<span class="kw">mean</span>(house <span class="op">==</span><span class="st"> &quot;Yes&quot;</span>), <span class="dv">2</span>), 
            <span class="dt">store_exp =</span> <span class="kw">round</span>(<span class="kw">mean</span>(<span class="kw">na.omit</span>(store_exp), <span class="dt">trim =</span> <span class="fl">0.1</span>), <span class="dv">0</span>),
            <span class="dt">online_exp =</span> <span class="kw">round</span>(<span class="kw">mean</span>(online_exp), <span class="dv">0</span>), 
            <span class="dt">store_trans =</span> <span class="kw">round</span>(<span class="kw">mean</span>(store_trans), <span class="dv">1</span>), 
            <span class="dt">online_trans =</span> <span class="kw">round</span>(<span class="kw">mean</span>(online_trans), <span class="dv">1</span>))</code></pre></div>
<pre><code>##   Age FemalePct HouseYes store_exp online_exp
## 1  39      0.55     0.57       840       2120
##   store_trans online_trans
## 1         5.3         13.5</code></pre>
<p>Now, let’s peel the onion.</p>
<p>The first line <code>sim.dat</code> is easy. It is the data you want to work on. The second line <code>group_by(segment)</code> tells R that in the following steps you want to summarise by variable <code>segment</code>. Here we only summarize data by one categorical variable, but you can group by multiple variables, such as <code>group_by(segment, house)</code>. The third argument <code>summarise</code> tells R the manipulation(s) to do. Then list the exact actions inside <code>summarise()</code> . For example, <code>Age=round(mean(na.omit(age)),0)</code> tell R the following things:</p>
<ol style="list-style-type: decimal">
<li>Calculate the mean of column <code>age</code> ignoring missing value for each customer segment</li>
<li>Round the result to the specified number of decimal places</li>
<li>Store the result in a new variable named <code>Age</code></li>
</ol>
<p>The rest of the command above is similar. In the end, we calculate the following for each segment:</p>
<ol style="list-style-type: decimal">
<li><code>Age</code>: average age for each segment</li>
<li><code>FemalePct</code>: percentage for each segment</li>
<li><code>HouseYes</code>: percentage of people who own a house</li>
<li><code>stroe_exp</code>: average expense in store</li>
<li><code>online_exp</code>: average expense online</li>
<li><code>store_trans</code>: average times of transactions in the store</li>
<li><code>online_trans</code>: average times of online transactions</li>
</ol>
<p>There is a lot of information you can extract from those simple averages.</p>
<ul>
<li><p>Conspicuous: average age is about 40. It is a group of middle-age wealthy people. 1/3 of them are female, and 2/3 are male. They buy regardless the price. Almost all of them own house (0.86). It makes us wonder what is wrong with the rest 14%?</p></li>
<li><p>Price: They are older people with average age 60. Nearly all of them own a house(0.94). They are less likely to purchase online (store_trans=6 while online_trans=3). It is the only group that is less likely to buy online.</p></li>
<li><p>Quality: The average age is 35. They are not way different with Conspicuous regarding age. But they spend much less. The percentages of male and female are similar. They prefer online shopping. More than half of them don’t own a house (0.66).</p></li>
<li><p>Style: They are young people with average age 24. The majority of them are female (0.81). Most of them don’t own a house (0.73). They are very likely to be digital natives and prefer online shopping.</p></li>
</ul>
<p>You may notice that Style group purchase more frequently online (<code>online_trans</code>) but the expense (<code>online_exp</code>) is not higher. It makes us wonder what is the average expense each time, so you have a better idea about the price range of the group.</p>
<p>The analytical process is aggregated instead of independent steps. The current step will shed new light on what to do next. Sometimes you need to go back to fix something in the previous steps. Let’s check average one-time online and instore purchase amounts:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">sim.dat <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">group_by</span>(segment) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">summarise</span>(<span class="dt">avg_online =</span> <span class="kw">round</span>(<span class="kw">sum</span>(online_exp)<span class="op">/</span><span class="kw">sum</span>(online_trans), <span class="dv">2</span>),
            <span class="dt">avg_store =</span> <span class="kw">round</span>(<span class="kw">sum</span>(store_exp)<span class="op">/</span><span class="kw">sum</span>(store_trans), <span class="dv">2</span>))</code></pre></div>
<pre><code>##   avg_online avg_store
## 1      156.5     253.6</code></pre>
<p>Price group has the lowest averaged one-time purchase. The Conspicuous group will pay the highest price. When we build customer profile in real life, we will also need to look at the survey summarization. You may be surprised how much information simple data manipulations can provide.</p>
<p>Another comman task is to check which column has missing values. It requires the program to look at each column in the data. In this case you can use <code>summarise_all</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># apply function anyNA() to each column</span>
<span class="co"># you can also assign a function vector such as: c(&quot;anyNA&quot;,&quot;is.factor&quot;)</span>
dplyr<span class="op">::</span><span class="kw">summarise_all</span>(sim.dat, <span class="kw">funs_</span>(<span class="kw">c</span>(<span class="st">&quot;anyNA&quot;</span>)))</code></pre></div>
<pre><code>##     age gender income house store_exp online_exp
## 1 FALSE  FALSE   TRUE FALSE     FALSE      FALSE
##   store_trans online_trans    Q1    Q2    Q3    Q4
## 1       FALSE        FALSE FALSE FALSE FALSE FALSE
##      Q5    Q6    Q7    Q8    Q9   Q10 segment
## 1 FALSE FALSE FALSE FALSE FALSE FALSE   FALSE</code></pre>
<p>The above code returns a vector indicating if there is any value missing in each column.</p>
<p><strong>Create new variable</strong></p>
<p>There are often situations where you need to create new variables. For example, adding online and store expense to get total expense. In this case, you will apply <strong>window function</strong> to the columns and return a column with the same length. <code>mutate()</code> can do it for you and append one or more new columns:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">dplyr<span class="op">::</span><span class="kw">mutate</span>(sim.dat, <span class="dt">total_exp =</span> store_exp <span class="op">+</span><span class="st"> </span>online_exp)</code></pre></div>
<p>The above code sums up two columns and appends the result (<code>total_exp</code>) to <code>sim.dat</code>. Another similar function is <code>transmute()</code>. The difference is that <code>transmute()</code> will delete the original columns and only keep the new ones.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">dplyr<span class="op">::</span><span class="kw">transmute</span>(sim.dat, <span class="dt">total_exp =</span> store_exp <span class="op">+</span><span class="st"> </span>online_exp)</code></pre></div>
<p><strong>Merge</strong></p>
<p>Similar to SQL, there are different joins in <code>dplyr</code>. We create two baby data sets to show how the functions work.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">(x &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="kw">cbind</span>(<span class="dt">ID =</span> <span class="kw">c</span>(<span class="st">&quot;A&quot;</span>, <span class="st">&quot;B&quot;</span>, <span class="st">&quot;C&quot;</span>), <span class="dt">x1 =</span> <span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>))))</code></pre></div>
<pre><code>##   ID x1
## 1  A  1
## 2  B  2
## 3  C  3</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">(y &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="kw">cbind</span>(<span class="dt">ID =</span> <span class="kw">c</span>(<span class="st">&quot;B&quot;</span>, <span class="st">&quot;C&quot;</span>, <span class="st">&quot;D&quot;</span>), <span class="dt">y1 =</span> <span class="kw">c</span>(T, T, F))))</code></pre></div>
<pre><code>##   ID    y1
## 1  B  TRUE
## 2  C  TRUE
## 3  D FALSE</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># join to the left</span>
<span class="co"># keep all rows in x</span>
<span class="kw">left_join</span>(x, y, <span class="dt">by =</span> <span class="st">&quot;ID&quot;</span>)</code></pre></div>
<pre><code>## Warning: Column `ID` joining factors with different
## levels, coercing to character vector</code></pre>
<pre><code>##   ID x1   y1
## 1  A  1 &lt;NA&gt;
## 2  B  2 TRUE
## 3  C  3 TRUE</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># get rows matched in both data sets</span>
<span class="kw">inner_join</span>(x, y, <span class="dt">by =</span> <span class="st">&quot;ID&quot;</span>)</code></pre></div>
<pre><code>## Warning: Column `ID` joining factors with different
## levels, coercing to character vector</code></pre>
<pre><code>##   ID x1   y1
## 1  B  2 TRUE
## 2  C  3 TRUE</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># get rows in either data set</span>
<span class="kw">full_join</span>(x, y, <span class="dt">by =</span> <span class="st">&quot;ID&quot;</span>)</code></pre></div>
<pre><code>## Warning: Column `ID` joining factors with different
## levels, coercing to character vector</code></pre>
<pre><code>##   ID   x1    y1
## 1  A    1  &lt;NA&gt;
## 2  B    2  TRUE
## 3  C    3  TRUE
## 4  D &lt;NA&gt; FALSE</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># filter out rows in x that can be matched in y </span>
<span class="co"># it doesn&#39;t bring in any values from y </span>
<span class="kw">semi_join</span>(x, y, <span class="dt">by =</span> <span class="st">&quot;ID&quot;</span>)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># the opposite of  semi_join()</span>
<span class="co"># it gets rows in x that cannot be matched in y</span>
<span class="co"># it doesn&#39;t bring in any values from y</span>
<span class="kw">anti_join</span>(x, y, <span class="dt">by =</span> <span class="st">&quot;ID&quot;</span>)</code></pre></div>
<p>There are other functions(<code>intersect()</code>, <code>union()</code> and <code>setdiff()</code>). Also the data frame version of <code>rbind</code> and <code>cbind</code> which are <code>bind_rows()</code> and <code>bind_col()</code>. We are not going to go through them all. You can try them yourself. If you understand the functions we introduced so far. It should be easy for you to figure out the rest.</p>
</div>
</div>
<div id="tidy-and-reshape-data" class="section level2">
<h2><span class="header-section-number">5.3</span> Tidy and Reshape Data</h2>
<p>“Tidy data” represent the information from a dataset as data frames where each row is an observation, and each column contains the values of a variable (i.e., an attribute of what we are observing). Depending on the situation, the requirements on what to present as rows and columns may change. To make data easy to work with for the problem at hand, in practice, we often need to convert data between the “wide” and the “long” format. The process feels like kneading the dough.</p>
<p>There are two commonly used packages for this kind of manipulations: <code>tidyr</code> and <code>reshape2</code>. We will show how to tidy and reshape data using the two packages. By comparing the functions to show how they overlap and where they differ.</p>
<div id="reshape2-package" class="section level3">
<h3><span class="header-section-number">5.3.1</span> <code>reshape2</code> package</h3>
<p>It is a reboot of the previous package <code>reshape</code>. Take a baby subset of our exemplary clothes consumers data to illustrate:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">sdat&lt;-sim.dat[<span class="dv">1</span><span class="op">:</span><span class="dv">5</span>,<span class="dv">1</span><span class="op">:</span><span class="dv">6</span>]</code></pre></div>
<p>For the above data <code>sdat</code>, what if we want to have a variable indicating the purchasing channel (i.e. online or in-store) and another column with the corresponding expense amount? Assume we want to keep the rest of the columns the same. It is a task to change data from “wide” to “long”. There are two general ways to shape data:</p>
<ul>
<li>Use <code>melt()</code> to convert an object into a molten data frame, i.e., from wide to long</li>
<li>Use <code>dcast()</code> to cast a molten data frame into the shape you want, i.e., from long to wide</li>
</ul>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">(mdat &lt;-<span class="st"> </span><span class="kw">melt</span>(sdat, <span class="dt">measure.vars =</span> <span class="kw">c</span>(<span class="st">&quot;store_exp&quot;</span>, <span class="st">&quot;online_exp&quot;</span>),
              <span class="dt">variable.name =</span> <span class="st">&quot;Channel&quot;</span>, 
              <span class="dt">value.name =</span> <span class="st">&quot;Expense&quot;</span>))</code></pre></div>
<pre><code>##    age gender income house    Channel Expense
## 1   57 Female 120963   Yes  store_exp   529.1
## 2   63 Female 122008   Yes  store_exp   478.0
## 3   59   Male 114202   Yes  store_exp   490.8
## 4   60   Male 113616   Yes  store_exp   347.8
## 5   51   Male 124253   Yes  store_exp   379.6
## 6   57 Female 120963   Yes online_exp   303.5
## 7   63 Female 122008   Yes online_exp   109.5
## 8   59   Male 114202   Yes online_exp   279.2
## 9   60   Male 113616   Yes online_exp   141.7
## 10  51   Male 124253   Yes online_exp   112.2</code></pre>
<p>You melted the data frame <code>sdat</code> by two variables: <code>store_exp</code> and <code>online_exp</code> (<code>measure.vars=c(&quot;store_exp&quot;,&quot;online_exp&quot;)</code>). The new variable name is <code>Channel</code> set by command <code>variable.name = &quot;Channel&quot;</code>. The value name is <code>Expense</code> set by command <code>value.name = &quot;Expense&quot;</code>.</p>
<p>You can run a regression to study the effect of purchasing channel as follows:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Here we use all observations from sim.dat</span>
<span class="co"># Don&#39;t show result here</span>
mdat &lt;-<span class="st"> </span><span class="kw">melt</span>(sim.dat[, <span class="dv">1</span><span class="op">:</span><span class="dv">6</span>], <span class="dt">measure.vars =</span> <span class="kw">c</span>(<span class="st">&quot;store_exp&quot;</span>, <span class="st">&quot;online_exp&quot;</span>), 
    <span class="dt">variable.name =</span> <span class="st">&quot;Channel&quot;</span>, <span class="dt">value.name =</span> <span class="st">&quot;Expense&quot;</span>)
fit &lt;-<span class="st"> </span><span class="kw">lm</span>(Expense <span class="op">~</span><span class="st"> </span>gender <span class="op">+</span><span class="st"> </span>house <span class="op">+</span><span class="st"> </span>income <span class="op">+</span><span class="st"> </span>Channel <span class="op">+</span><span class="st"> </span>age, <span class="dt">data =</span> mdat)
<span class="kw">summary</span>(fit)</code></pre></div>
<p>You can <code>melt()</code> list, matrix, table too. The syntax is similar, and we won’t go through every situation. Sometimes we want to convert the data from “long” to “wide”. For example, <strong>you want to compare the online and in-store expense between male and female based on the house ownership. </strong></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">dcast</span>(mdat, house <span class="op">+</span><span class="st"> </span>gender <span class="op">~</span><span class="st"> </span>Channel, sum)</code></pre></div>
<pre><code>## Using Expense as value column: use value.var to override.</code></pre>
<pre><code>##   house gender store_exp online_exp
## 1   Yes Female      1007      413.0
## 2   Yes   Male      1218      533.2</code></pre>
<p>In the above code, what is the left side of <code>~</code> are variables that you want to group by. The right side is the variable you want to spread as columns. It will use the column indicating value from <code>melt()</code> before. Here is “<code>Expense</code>” .</p>
</div>
<div id="tidyr-package" class="section level3">
<h3><span class="header-section-number">5.3.2</span> <code>tidyr</code> package</h3>
<p>The other package that will do similar manipulations is <code>tidyr</code>. Let’s get a subset to illustrate the usage.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># practice functions we learnt before</span>
sdat &lt;-<span class="st"> </span>sim.dat[<span class="dv">1</span><span class="op">:</span><span class="dv">5</span>, ] <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span>dplyr<span class="op">::</span><span class="kw">select</span>(age, gender, store_exp, store_trans)
sdat <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">tbl_df</span>()</code></pre></div>
<pre><code>## # A tibble: 5 x 4
##     age gender store_exp store_trans
## * &lt;int&gt; &lt;fct&gt;      &lt;dbl&gt;       &lt;int&gt;
## 1    57 Female      529.           2
## 2    63 Female      478.           4
## 3    59 Male        491.           7
## 4    60 Male        348.          10
## 5    51 Male        380.           4</code></pre>
<p><code>gather()</code> function in <code>tidyr</code> is analogous to <code>melt()</code> in <code>reshape2</code>. The following code will do the same thing as we did before using <code>melt()</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">msdat &lt;-<span class="st"> </span>tidyr<span class="op">::</span><span class="kw">gather</span>(sdat, <span class="st">&quot;variable&quot;</span>,<span class="st">&quot;value&quot;</span>, store_exp, store_trans)
msdat <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">tbl_df</span>()</code></pre></div>
<pre><code>## # A tibble: 10 x 4
##      age gender variable     value
##    &lt;int&gt; &lt;fct&gt;  &lt;chr&gt;        &lt;dbl&gt;
##  1    57 Female store_exp   529.  
##  2    63 Female store_exp   478.  
##  3    59 Male   store_exp   491.  
##  4    60 Male   store_exp   348.  
##  5    51 Male   store_exp   380.  
##  6    57 Female store_trans   2.00
##  7    63 Female store_trans   4.00
##  8    59 Male   store_trans   7.00
##  9    60 Male   store_trans  10.0 
## 10    51 Male   store_trans   4.00</code></pre>
<p>Or if we use the pipe operation, we can write the above code as:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">sdat <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">gather</span>(<span class="st">&quot;variable&quot;</span>, <span class="st">&quot;value&quot;</span>, store_exp, store_trans)</code></pre></div>
<p>It is identical with the following code using <code>melt()</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">melt</span>(sdat, <span class="dt">measure.vars =</span> <span class="kw">c</span>(<span class="st">&quot;store_exp&quot;</span>, <span class="st">&quot;store_trans&quot;</span>), 
     <span class="dt">variable.name =</span> <span class="st">&quot;variable&quot;</span>, 
     <span class="dt">value.name =</span> <span class="st">&quot;value&quot;</span>)</code></pre></div>
<p>The opposite operation to <code>gather()</code> is <code>spread()</code>. The previous one stacks columns and the latter one spread the columns.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">msdat <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">spread</span>(variable, value)</code></pre></div>
<pre><code>##   age gender store_exp store_trans
## 1  51   Male     379.6           4
## 2  57 Female     529.1           2
## 3  59   Male     490.8           7
## 4  60   Male     347.8          10
## 5  63 Female     478.0           4</code></pre>
<p>Another pair of functions that do opposite manipulations are <code>separate()</code> and <code>unite()</code>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">sepdat&lt;-<span class="st"> </span>msdat <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">separate</span>(variable,<span class="kw">c</span>(<span class="st">&quot;Source&quot;</span>,<span class="st">&quot;Type&quot;</span>))
sepdat <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">tbl_df</span>()</code></pre></div>
<pre><code>## # A tibble: 10 x 5
##      age gender Source Type   value
##    &lt;int&gt; &lt;fct&gt;  &lt;chr&gt;  &lt;chr&gt;  &lt;dbl&gt;
##  1    57 Female store  exp   529.  
##  2    63 Female store  exp   478.  
##  3    59 Male   store  exp   491.  
##  4    60 Male   store  exp   348.  
##  5    51 Male   store  exp   380.  
##  6    57 Female store  trans   2.00
##  7    63 Female store  trans   4.00
##  8    59 Male   store  trans   7.00
##  9    60 Male   store  trans  10.0 
## 10    51 Male   store  trans   4.00</code></pre>
<p>You can see that the function separates the original column “<code>variable</code>” to two new columns “<code>Source</code>” and “<code>Type</code>”. You can use <code>sep=</code> to set the string or regular expression to separate the column. By default, it is “<code>_</code>”.</p>
<p>The <code>unite()</code> function will do the opposite: combining two columns. It is the generalization of <code>paste()</code> to a data frame.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">sepdat <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">unite</span>(<span class="st">&quot;variable&quot;</span>, Source, Type, <span class="dt">sep =</span> <span class="st">&quot;_&quot;</span>)</code></pre></div>
<pre><code>##    age gender    variable value
## 1   57 Female   store_exp 529.1
## 2   63 Female   store_exp 478.0
## 3   59   Male   store_exp 490.8
## 4   60   Male   store_exp 347.8
## 5   51   Male   store_exp 379.6
## 6   57 Female store_trans   2.0
## 7   63 Female store_trans   4.0
## 8   59   Male store_trans   7.0
## 9   60   Male store_trans  10.0
## 10  51   Male store_trans   4.0</code></pre>
<p>The reshaping manipulations may be the trickiest part. You have to practice a lot to get familiar with those functions. Unfortunately, there is no shortcut.</p>
<!--chapter:end:05-DataWrangling.Rmd-->
</div>
</div>
</div>
<div id="model-tuning-strategy" class="section level1">
<h1><span class="header-section-number">6</span> Model Tuning Strategy</h1>
<p>When training a machine learning model, there are many decisions to make. For example, when training a random forest, you need to decide the number of trees and the number of variables at each node. For lasso method, you need to determine the penalty parameter. There may be standard settings for some of the parameters, but it’s unlikely to guess the right values for all of these correctly. Other than that, making good choices on how you split the data into training and testing sets can make a huge difference in helping you find a high-performance model efficiently.</p>
<p>This chapter will illustrate the practical aspects of model tuning. We will talk about different types of model error, sources of model error, hyperparameter tuning, how to set up your data and how to make sure your model implementation is correct. In practice applying machine learning is a highly iterative process.</p>
<div id="systematic-error-and-random-error" class="section level2">
<h2><span class="header-section-number">6.1</span> Systematic Error and Random Error</h2>
<p>Assume <span class="math inline">\(\mathbf{X}\)</span> is <span class="math inline">\(n \times p\)</span> observation matrix and <span class="math inline">\(\mathbf{y}\)</span> is response variable, we have:</p>
<p><span class="math display">\[\mathbf{y}=f(\mathbf{X})+\mathbf{\epsilon}\]</span></p>
<p>where <span class="math inline">\(\mathbf{\epsilon}\)</span> is the random error with a mean of zero. The function <span class="math inline">\(f(\cdot)\)</span> is our modeling target, which represents the information in the response variable that predictors can explain. The main goal of estimating <span class="math inline">\(f(\cdot)\)</span> is inference or prediction, or sometimes both. In general, there is a trade-off between flexibility and interpretability of the model. So data scientists need to comprehend the delicate balance between these two.</p>
<p>Depending on the modeling purposes, the requirement for interpretability varies. If the prediction is the only goal, then as long as the prediction is accurate enough, the interpretability is not under consideration. In this case, people can use “black box” model, such as random forest, boosting tree, neural network and so on. These models are very flexible but nearly impossible to explain. Their accuracy is usually higher on the training set, but not necessary when it predicts. It is not surprising since those models have a huge number of parameters and high flexibility that they can “memorize” the entire training data. A paper by Chiyuan Zhang et al. in 2017 pointed out that “Deep neural networks (even just two-layer net) easily fit random labels” <span class="citation">(Zhang et al. <a href="#ref-rethinkDL">2017</a>)</span>. The traditional forms of regularization, such as weight decay, dropout, and data augmentation, fail to control generalization error. It poses a conceptual challenge to statistical theory and also calls our attention when we use such black-box models.</p>
<p>There are two kinds of application problems: complete information problem and incomplete information problem. The complete information problem has all the information you need to know the correct response. Take the famous cat recognition, for example, all the information you need to identify a cat is in the picture. In this situation, the algorithm that penetrates the data the most wins. There are some other similar problems such as the self-driving car, chess game, facial recognition and speech recognition. But in most of the data science applications, the information is incomplete. If you want to know whether a customer is going to purchase again or not, it is unlikely to have 360-degree of the customer’s information. You may have their historical purchasing record, discounts and service received. But you don’t know if the customer sees your advertisement, or has a friend recommends competitor’s product, or encounters some unhappy purchasing experience somewhere. There could be a myriad of factors that will influence the customer’s purchase decision while what you have as data is only a small part. To make things worse, in many cases, you don’t even know what you don’t know. Deep learning doesn’t have any advantage in solving those problems. Instead, some parametric models often work better in this situation. You will comprehend this more after learning the different types of model error. Assume we have <span class="math inline">\(\hat{f}\)</span> which is an estimator of <span class="math inline">\(f\)</span>. Then we can further get <span class="math inline">\(\mathbf{\hat{y}}=\hat{f}(\mathbf{X})\)</span>. The predicted error is divided into two parts, systematic error, and random error:</p>
<p><span class="math display">\[E(\mathbf{y}-\hat{\mathbf{y}})^{2}=E[f(\mathbf{X})+\mathbf{\epsilon}-\hat{f}(\mathbf{X})]^{2}=\underset{\text{(1)}}{\underbrace{E[f(\mathbf{X})-\hat{f}(\mathbf{X})]^{2}}}+\underset{\text{(2)}}{\underbrace{Var(\mathbf{\epsilon})}}
\label{eq:error}\]</span></p>
<p>It is also called Mean Square Error (MSE) where (1) is the systematic error. It exists because <span class="math inline">\(\hat{f}\)</span> usually does not entirely describe the “systematic relation” between X and y which refers to the stable relationship that exists across different samples or time. Model improvement can help reduce this kind of error; (2) is the random error which represents the part of y that cannot be explained by X. A more complex model does not reduce the error. There are three reasons for random error:</p>
<ol style="list-style-type: decimal">
<li>the current sample is not representative, so the pattern in one sample set does not generalize to a broader scale.</li>
<li>The information is incomplete. In other words, you don’t have all variables needed to explain the response.</li>
<li>Measurement error in the variables.</li>
</ol>
<p>Deep learning has significant success solving problems with complete information and usually low measurement error. As mentioned before, in a task like image recognition, all you need are the pixels in the pictures. So in deep learning applications, increasing the sample size can improve the model performance significantly. But it may not perform well in problems with incomplete information. The biggest problem with the black-box model is that it fits random error, i.e., over-fitting. The notable feature of random error is that it varies over different samples. So one way to determine whether overfitting happens is to reserve a part of the data as the test set and then check the performance of the trained model on the test data. Note that overfitting is a general problem from which any model could suffer. However, since black-box models usually have a large number of parameters, it is much more suspectable to over-fitting.</p>
<div class="figure">
<img src="images/ModelError.png" alt="Types of Model Error" />
<p class="caption">Types of Model Error</p>
</div>
<p>The systematic error can be further decomposed as:</p>
<p><span class="math display">\[
\begin{array}{ccc}
E[f(\mathbf{X})-\hat{f}(\mathbf{X})]^{2} &amp; = &amp; E\left(f(\mathbf{X})-E[\hat{f}(\mathbf{X})]+E[\hat{f}(\mathbf{X})]-\hat{f}(\mathbf{X})\right)^{2}\\
 &amp; = &amp; E\left(E[\hat{f}(\mathbf{X})]-f(\mathbf{X})\right)^{2}+E\left(\hat{f}(\mathbf{X})-E[\hat{f}(\mathbf{X})]\right)^{2}\\
 &amp; = &amp; [Bias(\hat{f}(\mathbf{X}))]^{2}+Var(\hat{f}(\mathbf{X}))
\end{array}
\]</span></p>
<p>The systematic error consists of two parts, <span class="math inline">\(Bias(\hat{f}(\mathbf{X}))\)</span> and <span class="math inline">\(Var (\hat{f}(\mathbf{X}))\)</span>. To minimize the systematic error, we need to minimize both. The bias represents the error caused by the model’s approximation of the reality, i.e., systematic relation, which may be very complex. For example, linear regression assumes a linear relationship between the predictors and the response, but rarely is there a perfect linear relationship in real life. So linear regression is more likely to have a high bias.</p>
<p>To explore bias and variance, let’s begin with a simple simulation. We will simulate a data with a non-linear relationship and fit different models on it. An intuitive way to show these is to compare the plots of various models.</p>
<p>The code below simulates one predictor (<code>x</code>) and one response variable (<code>fx</code>). The relationship between <code>x</code> and <code>fx</code> is non-linear.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">source</span>(<span class="kw">ids_url</span>(<span class="st">&#39;R/multiplot.r&#39;</span>))
<span class="co"># randomly simulate some non-linear samples</span>
x =<span class="st"> </span><span class="kw">seq</span>(<span class="dv">1</span>, <span class="dv">10</span>, <span class="fl">0.01</span>) <span class="op">*</span><span class="st"> </span>pi
e =<span class="st"> </span><span class="kw">rnorm</span>(<span class="kw">length</span>(x), <span class="dt">mean =</span> <span class="dv">0</span>, <span class="dt">sd =</span> <span class="fl">0.2</span>)
fx &lt;-<span class="st"> </span><span class="kw">sin</span>(x) <span class="op">+</span><span class="st"> </span>e <span class="op">+</span><span class="st"> </span><span class="kw">sqrt</span>(x)
dat =<span class="st"> </span><span class="kw">data.frame</span>(x, fx)</code></pre></div>
<p>Then fit a simple linear regression on these data:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># plot fitting result</span>
<span class="kw">library</span>(ggplot2)
<span class="kw">ggplot</span>(dat, <span class="kw">aes</span>(x, fx)) <span class="op">+</span><span class="st"> </span><span class="kw">geom_point</span>() <span class="op">+</span><span class="st"> </span><span class="kw">geom_smooth</span>(<span class="dt">method =</span> <span class="st">&quot;lm&quot;</span>, <span class="dt">se =</span> <span class="ot">FALSE</span>)</code></pre></div>
<div class="figure" style="text-align: center">
<img src="IDS_files/figure-html/linearbias-1.svg" alt="High bias model" width="80%" />
<p class="caption">
(#fig:linearbias)High bias model
</p>
</div>
<p>Despite a large sample size, trained linear regression cannot describe the relationship very well. In other words, in this case, the model has a high bias (Fig. @ref(fig:linearbias)). People also call it underfitting.</p>
<p>Since the estimated parameters will be somewhat different for different samples, there is the variance of estimates. Intuitively, it gives you some sense that if we fit the same model with different samples (presumably, they are from the same population), how much will the estimates change. Ideally, the change is trivial. For high variance models, small changes in the training data result in very different estimates. In general, a model with high flexibility also has high variance., such as the CART tree, and the initial boosting method. To overcome that problem, the Random Forest and Gradient Boosting Model aim to reduce the variance by summarizing the results obtained from different samples.</p>
<p>Let’s fit the above data using a smoothing method which is highly flexible and can fit the current data tightly:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">ggplot</span>(dat, <span class="kw">aes</span>(x, fx)) <span class="op">+</span><span class="st"> </span><span class="kw">geom_smooth</span>(<span class="dt">span =</span> <span class="fl">0.03</span>)</code></pre></div>
<div class="figure" style="text-align: center">
<img src="IDS_files/figure-html/linearvar-1.svg" alt="High variance model" width="80%" />
<p class="caption">
(#fig:linearvar)High variance model
</p>
</div>
<p>The resulting plot (Fig. @ref(fig:linearvar)) indicates the smoothing method fit the data much better so it has a much smaller bias. However, this method has a high variance. If we simulate different subsets of the sample, the result curve will change significantly:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># set random seed</span>
<span class="kw">set.seed</span>(<span class="dv">2016</span>)
<span class="co"># sample part of the data to fit model sample 1</span>
idx1 =<span class="st"> </span><span class="kw">sample</span>(<span class="dv">1</span><span class="op">:</span><span class="kw">length</span>(x), <span class="dv">100</span>)
dat1 =<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">x1 =</span> x[idx1], <span class="dt">fx1 =</span> fx[idx1])
p1 =<span class="st"> </span><span class="kw">ggplot</span>(dat1, <span class="kw">aes</span>(x1, fx1)) <span class="op">+</span><span class="st"> </span><span class="kw">geom_smooth</span>(<span class="dt">span =</span> <span class="fl">0.03</span>)
<span class="co"># sample 2</span>
idx2 =<span class="st"> </span><span class="kw">sample</span>(<span class="dv">1</span><span class="op">:</span><span class="kw">length</span>(x), <span class="dv">100</span>)
dat2 =<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">x2 =</span> x[idx2], <span class="dt">fx2 =</span> fx[idx2])
p2 =<span class="st"> </span><span class="kw">ggplot</span>(dat2, <span class="kw">aes</span>(x2, fx2)) <span class="op">+</span><span class="st"> </span><span class="kw">geom_smooth</span>(<span class="dt">span =</span> <span class="fl">0.03</span>)
<span class="co"># sample 3</span>
idx3 =<span class="st"> </span><span class="kw">sample</span>(<span class="dv">1</span><span class="op">:</span><span class="kw">length</span>(x), <span class="dv">100</span>)
dat3 =<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">x3 =</span> x[idx3], <span class="dt">fx3 =</span> fx[idx3])
p3 =<span class="st"> </span><span class="kw">ggplot</span>(dat3, <span class="kw">aes</span>(x3, fx3)) <span class="op">+</span><span class="st"> </span><span class="kw">geom_smooth</span>(<span class="dt">span =</span> <span class="fl">0.03</span>)
<span class="co"># sample 4</span>
idx4 =<span class="st"> </span><span class="kw">sample</span>(<span class="dv">1</span><span class="op">:</span><span class="kw">length</span>(x), <span class="dv">100</span>)
dat4 =<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">x4 =</span> x[idx4], <span class="dt">fx4 =</span> fx[idx4])
p4 =<span class="st"> </span><span class="kw">ggplot</span>(dat4, <span class="kw">aes</span>(x4, fx4)) <span class="op">+</span><span class="st"> </span><span class="kw">geom_smooth</span>(<span class="dt">span =</span> <span class="fl">0.03</span>)
<span class="kw">multiplot</span>(p1, p2, p3, p4, <span class="dt">cols =</span> <span class="dv">2</span>)</code></pre></div>
<p><img src="IDS_files/figure-html/unnamed-chunk-73-1.svg" width="672" /></p>
<p>The fitted lines (blue) change over different samples which means it has high variance. People also call it overfitting. Fitting the linear model using the same four subsets, the result barely changes:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">p1 =<span class="st"> </span><span class="kw">ggplot</span>(dat1, <span class="kw">aes</span>(x1, fx1)) <span class="op">+</span><span class="st"> </span><span class="kw">geom_point</span>() <span class="op">+</span><span class="st"> </span><span class="kw">geom_smooth</span>(<span class="dt">method =</span> <span class="st">&quot;lm&quot;</span>, 
    <span class="dt">se =</span> <span class="ot">FALSE</span>)
p2 =<span class="st"> </span><span class="kw">ggplot</span>(dat2, <span class="kw">aes</span>(x2, fx2)) <span class="op">+</span><span class="st"> </span><span class="kw">geom_point</span>() <span class="op">+</span><span class="st"> </span><span class="kw">geom_smooth</span>(<span class="dt">method =</span> <span class="st">&quot;lm&quot;</span>, 
    <span class="dt">se =</span> <span class="ot">FALSE</span>)
p3 =<span class="st"> </span><span class="kw">ggplot</span>(dat3, <span class="kw">aes</span>(x3, fx3)) <span class="op">+</span><span class="st"> </span><span class="kw">geom_point</span>() <span class="op">+</span><span class="st"> </span><span class="kw">geom_smooth</span>(<span class="dt">method =</span> <span class="st">&quot;lm&quot;</span>, 
    <span class="dt">se =</span> <span class="ot">FALSE</span>)
p4 =<span class="st"> </span><span class="kw">ggplot</span>(dat4, <span class="kw">aes</span>(x4, fx4)) <span class="op">+</span><span class="st"> </span><span class="kw">geom_point</span>() <span class="op">+</span><span class="st"> </span><span class="kw">geom_smooth</span>(<span class="dt">method =</span> <span class="st">&quot;lm&quot;</span>, 
    <span class="dt">se =</span> <span class="ot">FALSE</span>)
<span class="kw">multiplot</span>(p1, p2, p3, p4, <span class="dt">cols =</span> <span class="dv">2</span>)</code></pre></div>
<p><img src="IDS_files/figure-html/unnamed-chunk-74-1.svg" width="672" /></p>
<p>In general, the variance (<span class="math inline">\(Var(\hat{f}(\mathbf{X}))\)</span>) <strong>increases</strong> and the bias (<span class="math inline">\(Bias(\hat{f}(\mathbf{X}))\)</span>) <strong>decreases</strong> as the model flexibility increases. Variance and bias together determine the systematic error. As we increase the flexibility of the model, at first the rate at which <span class="math inline">\(Bias(\hat{f}(\mathbf{X}))\)</span> decreases is faster than <span class="math inline">\(Var (\hat{f} (\mathbf{X}))\)</span>, so the MSE decreases. However, to some degree, higher flexibility has little effect on <span class="math inline">\(Bias(\hat{f}(\mathbf{X}))\)</span> but <span class="math inline">\(Var(\hat{f} (\mathbf{X}))\)</span> increases significantly, so the MSE increases.</p>
<div id="measurement-error-in-the-response" class="section level3">
<h3><span class="header-section-number">6.1.1</span> Measurement Error in the Response</h3>
<p>The measurement error in the response contributes to the random error (<span class="math inline">\(\mathbf{\epsilon}\)</span>). This part of the error is irreducible if you change the data collection mechanism, and so it makes the root mean square error (RMSE) and <span class="math inline">\(R^2\)</span> have the corresponding upper and lower limits. RMSE and <span class="math inline">\(R^2\)</span> are commonly used performance measures for the regression model which we will talk in more detail later. Therefore, the random error term not only represents the part of fluctuations the model cannot explain but also contains measurement error in the response variables. Section 20.2 of Applied Predictive Modeling <span class="citation">(Kuhn and Johnston <a href="#ref-APM">2013</a>)</span> has an example that shows the effect of the measurement error in the response variable on the model performance (RMSE and <span class="math inline">\(R^2\)</span>).</p>
<p>The authors increased the error in the response proportional to a base level error which was gotten using the original data without introducing extra noise. Then fit a set of models repeatedly using the “contaminated” data sets to study the change of <span class="math inline">\(RMSE\)</span> and <span class="math inline">\(R^2\)</span> as the level of noise. Here we use clothing consumer data for a similar illustration. Suppose many people do not want to disclose their income and so we need to use other variables to establish a model to predict income. We set up the following model:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># load data</span>
sim.dat &lt;-<span class="st"> </span><span class="kw">read.csv</span>(<span class="st">&quot;http://bit.ly/2P5gTw4&quot;</span>)
ymad &lt;-<span class="st"> </span><span class="kw">mad</span>(<span class="kw">na.omit</span>(sim.dat<span class="op">$</span>income))
<span class="co"># calculate z-score</span>
zs &lt;-<span class="st"> </span>(sim.dat<span class="op">$</span>income <span class="op">-</span><span class="st"> </span><span class="kw">mean</span>(<span class="kw">na.omit</span>(sim.dat<span class="op">$</span>income)))<span class="op">/</span>ymad
<span class="co"># which(na.omit(zs&gt;3.5)): identify outliers which(is.na(zs)):</span>
<span class="co"># identify missing values</span>
idex &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="kw">which</span>(<span class="kw">na.omit</span>(zs <span class="op">&gt;</span><span class="st"> </span><span class="fl">3.5</span>)), <span class="kw">which</span>(<span class="kw">is.na</span>(zs)))
<span class="co"># delete rows with outliers and missing values</span>
sim.dat &lt;-<span class="st"> </span>sim.dat[<span class="op">-</span>idex, ]
fit &lt;-<span class="st"> </span><span class="kw">lm</span>(income <span class="op">~</span><span class="st"> </span>store_exp <span class="op">+</span><span class="st"> </span>online_exp <span class="op">+</span><span class="st"> </span>store_trans <span class="op">+</span><span class="st"> </span>online_trans, 
    <span class="dt">data =</span> sim.dat)</code></pre></div>
<p>The output shows that without additional noise, the root mean square error (RMSE) of the model is 29567, <span class="math inline">\(R^2\)</span> is 0.6.</p>
<p>Let’s add various degrees of noise (0 to 3 times the RMSE) to the variable <code>income</code>:</p>
<p><span class="math display">\[ RMSE \times (0.0, 0.5, 1.0, 1.5, 2.0, 2.5, 3.0) \]</span></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">noise &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="kw">rep</span>(<span class="ot">NA</span>, <span class="dv">7</span> <span class="op">*</span><span class="st"> </span><span class="kw">nrow</span>(sim.dat)), <span class="dt">nrow =</span> <span class="kw">nrow</span>(sim.dat), 
    <span class="dt">ncol =</span> <span class="dv">7</span>)
<span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span><span class="kw">nrow</span>(sim.dat)) {
    noise[i, ] &lt;-<span class="st"> </span><span class="kw">rnorm</span>(<span class="dv">7</span>, <span class="kw">rep</span>(<span class="dv">0</span>, <span class="dv">7</span>), <span class="kw">summary</span>(fit)<span class="op">$</span>sigma <span class="op">*</span><span class="st"> </span><span class="kw">seq</span>(<span class="dv">0</span>, 
        <span class="dv">3</span>, <span class="dt">by =</span> <span class="fl">0.5</span>))
}</code></pre></div>
<p>We then examine the effect of noise intensity on <span class="math inline">\(R^2\)</span> for models with different complexity. The models with complexity from low to high are: ordinary linear regression, partial least square regression(PLS), multivariate adaptive regression spline (MARS), support vector machine (SVM, the kernel function is radial basis function), and random forest.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># fit ordinary linear regression</span>
rsq_linear &lt;-<span class="st"> </span><span class="kw">rep</span>(<span class="dv">0</span>, <span class="kw">ncol</span>(noise))
<span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span><span class="dv">7</span>) {
    withnoise &lt;-<span class="st"> </span>sim.dat<span class="op">$</span>income <span class="op">+</span><span class="st"> </span>noise[, i]
    fit0 &lt;-<span class="st"> </span><span class="kw">lm</span>(withnoise <span class="op">~</span><span class="st"> </span>store_exp <span class="op">+</span><span class="st"> </span>online_exp <span class="op">+</span><span class="st"> </span>store_trans <span class="op">+</span><span class="st"> </span>
<span class="st">        </span>online_trans, <span class="dt">data =</span> sim.dat)
    rsq_linear[i] &lt;-<span class="st"> </span><span class="kw">summary</span>(fit0)<span class="op">$</span>adj.r.squared
}</code></pre></div>
<p>PLS is a method of linearizing nonlinear relationships through hidden layers. It is similar to the principal component regression (PCR), except that PCR does not take into account the information of the dependent variable when selecting the components, and its purpose is to find the linear combinations (i.e., unsupervised) that capture the most variance of the independent variables. When the independent variables and response variables are related, PCR can well identify the systematic relationship between them. However, when there exist independent variables not associated with response variable, it will undermine PCR’s performance. And PLS maximizes the linear combination of dependencies with the response variable. In the current case, the more complicated PLS does not perform better than simple linear regression.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># pls: conduct PLS and PCR</span>
<span class="kw">library</span>(pls)
rsq_pls &lt;-<span class="st"> </span><span class="kw">rep</span>(<span class="dv">0</span>, <span class="kw">ncol</span>(noise))
<span class="co"># fit PLS</span>
<span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span><span class="dv">7</span>) {
    withnoise &lt;-<span class="st"> </span>sim.dat<span class="op">$</span>income <span class="op">+</span><span class="st"> </span>noise[, i]
    fit0 &lt;-<span class="st"> </span><span class="kw">plsr</span>(withnoise <span class="op">~</span><span class="st"> </span>store_exp <span class="op">+</span><span class="st"> </span>online_exp <span class="op">+</span><span class="st"> </span>store_trans <span class="op">+</span><span class="st"> </span>
<span class="st">        </span>online_trans, <span class="dt">data =</span> sim.dat)
    rsq_pls[i] &lt;-<span class="st"> </span><span class="kw">max</span>(<span class="kw">drop</span>(<span class="kw">R2</span>(fit0, <span class="dt">estimate =</span> <span class="st">&quot;train&quot;</span>, <span class="dt">intercept =</span> <span class="ot">FALSE</span>)<span class="op">$</span>val))
}</code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># earth: fit mars</span>
<span class="kw">library</span>(earth)
rsq_mars &lt;-<span class="st"> </span><span class="kw">rep</span>(<span class="dv">0</span>, <span class="kw">ncol</span>(noise))
<span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span><span class="dv">7</span>) {
    withnoise &lt;-<span class="st"> </span>sim.dat<span class="op">$</span>income <span class="op">+</span><span class="st"> </span>noise[, i]
    fit0 &lt;-<span class="st"> </span><span class="kw">earth</span>(withnoise <span class="op">~</span><span class="st"> </span>store_exp <span class="op">+</span><span class="st"> </span>online_exp <span class="op">+</span><span class="st"> </span>store_trans <span class="op">+</span><span class="st"> </span>
<span class="st">        </span>online_trans, <span class="dt">data =</span> sim.dat)
    rsq_mars[i] &lt;-<span class="st"> </span>fit0<span class="op">$</span>rsq
}</code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># caret: awesome package for tuning predictive model</span>
<span class="kw">library</span>(caret)
rsq_svm &lt;-<span class="st"> </span><span class="kw">rep</span>(<span class="dv">0</span>, <span class="kw">ncol</span>(noise))
<span class="co"># Need some time to run</span>
<span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span><span class="dv">7</span>) {
    idex &lt;-<span class="st"> </span><span class="kw">which</span>(<span class="kw">is.na</span>(sim.dat<span class="op">$</span>income))
    withnoise &lt;-<span class="st"> </span>sim.dat<span class="op">$</span>income <span class="op">+</span><span class="st"> </span>noise[, i]
    trainX &lt;-<span class="st"> </span>sim.dat[, <span class="kw">c</span>(<span class="st">&quot;store_exp&quot;</span>, <span class="st">&quot;online_exp&quot;</span>, <span class="st">&quot;store_trans&quot;</span>, 
        <span class="st">&quot;online_trans&quot;</span>)]
    trainY &lt;-<span class="st"> </span>withnoise
    fit0 &lt;-<span class="st"> </span><span class="kw">train</span>(trainX, trainY, <span class="dt">method =</span> <span class="st">&quot;svmRadial&quot;</span>, <span class="dt">tuneLength =</span> <span class="dv">15</span>, 
        <span class="dt">trControl =</span> <span class="kw">trainControl</span>(<span class="dt">method =</span> <span class="st">&quot;cv&quot;</span>))
    rsq_svm[i] &lt;-<span class="st"> </span><span class="kw">max</span>(fit0<span class="op">$</span>results<span class="op">$</span>Rsquared)
}</code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># randomForest: random forest model</span>
<span class="kw">library</span>(randomForest)
rsq_rf &lt;-<span class="st"> </span><span class="kw">rep</span>(<span class="dv">0</span>, <span class="kw">ncol</span>(noise))
<span class="co"># ntree=500 number of trees na.action = na.omit ignore</span>
<span class="co"># missing value</span>
<span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span><span class="dv">7</span>) {
    withnoise &lt;-<span class="st"> </span>sim.dat<span class="op">$</span>income <span class="op">+</span><span class="st"> </span>noise[, i]
    fit0 &lt;-<span class="st"> </span><span class="kw">randomForest</span>(withnoise <span class="op">~</span><span class="st"> </span>store_exp <span class="op">+</span><span class="st"> </span>online_exp <span class="op">+</span><span class="st"> </span>
<span class="st">        </span>store_trans <span class="op">+</span><span class="st"> </span>online_trans, <span class="dt">data =</span> sim.dat, <span class="dt">ntree =</span> <span class="dv">500</span>, 
        <span class="dt">na.action =</span> na.omit)
    rsq_rf[i] &lt;-<span class="st"> </span><span class="kw">tail</span>(fit0<span class="op">$</span>rsq, <span class="dv">1</span>)
}
<span class="kw">library</span>(reshape2)
rsq &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="kw">cbind</span>(<span class="dt">Noise =</span> <span class="kw">c</span>(<span class="dv">0</span>, <span class="fl">0.5</span>, <span class="dv">1</span>, <span class="fl">1.5</span>, <span class="dv">2</span>, <span class="fl">2.5</span>, <span class="dv">3</span>), 
    rsq_linear, rsq_pls, rsq_mars, rsq_svm, rsq_rf))
rsq &lt;-<span class="st"> </span><span class="kw">melt</span>(rsq, <span class="dt">id.vars =</span> <span class="st">&quot;Noise&quot;</span>, <span class="dt">measure.vars =</span> <span class="kw">c</span>(<span class="st">&quot;rsq_linear&quot;</span>, 
    <span class="st">&quot;rsq_pls&quot;</span>, <span class="st">&quot;rsq_mars&quot;</span>, <span class="st">&quot;rsq_svm&quot;</span>, <span class="st">&quot;rsq_rf&quot;</span>))</code></pre></div>
<p>(ref:error-cap) Test set <span class="math inline">\(R^2\)</span> profiles for income models when measurement system noise increases. <code>rsq_linear</code>: linear regression, <code>rsq_pls</code>: Partial Least Square, <code>rsq_mars</code>: Multiple Adaptive Regression Spline Regression, <code>rsq_svm</code>: Support Vector Machine，<code>rsq_rf</code>: Random Forest</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(ggplot2)
<span class="kw">ggplot</span>(<span class="dt">data =</span> rsq, <span class="kw">aes</span>(<span class="dt">x =</span> Noise, <span class="dt">y =</span> value, <span class="dt">group =</span> variable, 
    <span class="dt">colour =</span> variable)) <span class="op">+</span><span class="st"> </span><span class="kw">geom_line</span>() <span class="op">+</span><span class="st"> </span><span class="kw">geom_point</span>() <span class="op">+</span><span class="st"> </span><span class="kw">ylab</span>(<span class="st">&quot;R2&quot;</span>)</code></pre></div>
<div class="figure" style="text-align: center">
<img src="IDS_files/figure-html/error-1.svg" alt="(ref:error-cap)" width="80%" />
<p class="caption">
(#fig:error)(ref:error-cap)
</p>
</div>
<p>Fig. @ref(fig:error) shows that:</p>
<p>All model performance decreases sharply with increasing noise intensity. To better anticipate model performance, it helps to understand the way variable is measured. It is something need to make clear at the beginning of an analytical project. A data scientist should be aware of the quality of the data in the database. For data from the clients, it is an important to understand the quality of the data by communication.</p>
<p>More complex model is not necessarily better. The best model in this situation is MARS, not random forests or SVM. Simple linear regression and PLS perform the worst when noise is low. MARS is more complicated than the linear regression and PLS, but it is simpler and easier to explain than random forest and SVM.</p>
<p>When noise increases to a certain extent, the potential structure becomes vaguer, and complex random forest model starts to fail. When the systematic measurement error is significant, a more straightforward but not naive model may be a better choice. It is always a good practice to try different models, and select the simplest model in the case of similar performance. Model evaluation and selection represent the career “maturity” of a data scientist.</p>
</div>
<div id="measurement-error-in-the-independent-variables" class="section level3">
<h3><span class="header-section-number">6.1.2</span> Measurement Error in the Independent Variables</h3>
<p>The traditional statistical model usually assumes that the measurement of the independent variable has no error which is not possible in practice. Considering the error in the independent variables is necessary. The impact of the error depends on the following factors: (1) the magnitude of the randomness; (2) the importance of the corresponding variable in the model, and (3) the type of model used. Use variable <code>online_exp</code> as an example. The approach is similar to the previous section. Add varying degrees of noise and see its impact on the model performance. We add the following different levels of noise (0 to 3 times the standard deviation) to<code>online_exp</code>:</p>
<p><span class="math display">\[\sigma_{0} \times (0.0, 0.5, 1.0, 1.5, 2.0, 2.5, 3.0)\]</span></p>
<p>where <span class="math inline">\(\sigma_{0}\)</span> is the standard error of <code>online_exp</code>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">noise&lt;-<span class="kw">matrix</span>(<span class="kw">rep</span>(<span class="ot">NA</span>,<span class="dv">7</span><span class="op">*</span><span class="kw">nrow</span>(sim.dat)),<span class="dt">nrow=</span><span class="kw">nrow</span>(sim.dat),<span class="dt">ncol=</span><span class="dv">7</span>)
<span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span><span class="kw">nrow</span>(sim.dat)){
noise[i,]&lt;-<span class="kw">rnorm</span>(<span class="dv">7</span>,<span class="kw">rep</span>(<span class="dv">0</span>,<span class="dv">7</span>),<span class="kw">sd</span>(sim.dat<span class="op">$</span>online_exp)<span class="op">*</span><span class="kw">seq</span>(<span class="dv">0</span>,<span class="dv">3</span>,<span class="dt">by=</span><span class="fl">0.5</span>))
}</code></pre></div>
<p>Likewise, we examine the effect of noise intensity on different models (<span class="math inline">\(R^2\)</span>). The models with complexity from low to high are: ordinary linear regression, partial least square regression(PLS), multivariate adaptive regression spline (MARS), support vector machine (SVM, the Kernel function is radial basis function), and random forest. The code is similar as before so not shown here.</p>
<p>(ref:errorvariable-cap) Test set <span class="math inline">\(R^2\)</span> profiles for income models when noise in <code>online_exp</code> increases. <code>rsq_linear</code> : linear regression, <code>rsq_pls</code> : Partial Least Square, <code>rsq_mars</code>: Multiple Adaptive Regression Spline Regression, <code>rsq_svm</code>: Support Vector Machine，<code>rsq_rf</code>: Random Forest</p>
<div class="figure" style="text-align: center">
<img src="IDS_files/figure-html/errorvariable-1.svg" alt="(ref:errorvariable-cap)" width="80%" />
<p class="caption">
(#fig:errorvariable)(ref:errorvariable-cap)
</p>
</div>
<p>Comparing Fig. @ref(fig:errorvariable) and Fig. @ref(fig:error), the influence of the two types of error is very different. The error in response cannot be overcome for any model, but it is not the case for the independent variables. Imagine an extreme case, if <code>online_exp</code> is completely random, that is, no information in it, the impact on the performance of random forest and support vector machine is marginal. Linear regression and PLS still perform similarly. With the increase of noise, the performance starts to decline faster. To a certain extent, it becomes steady. In general, if an independent variable contains error, other variables associated with it can compensate to some extent.</p>
</div>
</div>
<div id="data-splitting-and-resampling" class="section level2">
<h2><span class="header-section-number">6.2</span> Data Splitting and Resampling</h2>
<p>Those highly adaptable models can model complex relationships. However, they tend to overfit which leads to the poor prediction by learning too much from the data. It means that the model is susceptible to the specific sample used to fit it. When future data is not exactly like the past data, the model prediction may have big mistakes. A simple model like ordinary linear regression tends instead to underfit which leads to a bad prediction by learning too little from the data. It systematically over-predicts or under-predicts the data regardless of how well future data resemble past data. Without evaluating models, the modeler will not know about the problem before the future samples. Data splitting and resampling are fundamental techniques to build sound models for prediction.</p>
<div id="data-splitting" class="section level3">
<h3><span class="header-section-number">6.2.1</span> Data Splitting</h3>
<p><em>Data splitting</em> is to put part of the data aside as testing set (or Hold-outs, out of bag samples) and use the rest for model training. Training samples are also called in-sample. Model performance metrics evaluated using in-sample are retrodictive, not predictive.</p>
<p>The traditional business intelligence usually handles data description. Answer simple questions by querying and summarizing the data, such as:</p>
<ul>
<li>What is the monthly sales of a product in 2015?</li>
<li>What is the number of visits to our site in the past month?<br />
</li>
<li>What is the sales difference in 2015 for two different product designs?</li>
</ul>
<p>There is no need to go through the tedious process of splitting the data, tuning and testing model to answer questions of this kind. Instead, people usually use as complete data as possible and then sum or average the parts of interest.</p>
<p>Many models have parameters which cannot be directly estimated from the data, such as <span class="math inline">\(\lambda\)</span> in the lasso (penalty parameter), the number of trees in the random forest. This type of model parameter is called tuning parameter, and there is no analytical formula available to calculate the optimized value. Tuning parameters often control the complexity of the model. A poor choice can result in over-fitting or under-fitting. A standard approach to estimate tuning parameters is through cross-validation which is a data resampling approach.</p>
<p>To get a reasonable precision of the performance based on a single test set, the size of the test set may need to be large. So a conventional approach is to use a subset of samples to fit the model and use the rest to evaluate model performance. This process will repeat multiple times to get a performance profile. In that sense, resampling is based on splitting. The general steps are:</p>
<ul>
<li>Define a set of candidate values for tuning parameter(s)
<ul>
<li>For each candidate value in the set
<ul>
<li>Resample data</li>
<li>Fit model</li>
<li>Predict hold-out</li>
<li>Calculate performance</li>
</ul></li>
</ul></li>
<li>Aggregate the results</li>
<li>Determine the final tuning parameter</li>
<li>Refit the model with the entire data set</li>
</ul>
<div class="figure">
<img src="images/ParameterTuningProcess.png" alt="Parameter Tuning Process" style="width:80.0%" />
<p class="caption">Parameter Tuning Process</p>
</div>
<p>The above is an outline of the general procedure to tune parameters. Now let’s focus on the critical part of the process: data splitting. Ideally, we should evaluate model using samples that were not used to build or fine-tune the model. So it provides an unbiased sense of model effectiveness. When the sample size is large, it is a good practice to set aside part of the samples to evaluate the final model. People use “training” data to indicate samples used to fit or fine-tune the model and “test” or “validation” data set is used to validate performance.</p>
<p>The first decision to make for data splitting is to decide the proportion of data in the test set. There are two factors to consider here: (1) sample size; (2) computation intensity. If the sample size is large enough which is the most common situation according to my experience, you can try to use 20%, 30% and 40% of the data as the test set, and see which one works the best. If the model is computationally intense, then you may consider starting from a smaller sample of data to train the model hence will have a higher portion of data in the test set. Depending on how it performs, you may need to increase the training set. If the sample size is small, you can use cross-validation or bootstrap which is the topic in the next section.</p>
<p>The next decision is to decide which samples are in the test set. There is a desire to make the training and test sets as similar as possible. A simple way is to split data by random sampling which, however, does not control for any of the data attributes, such as the percentage of the retained customer in the data. So it is possible that the distribution of outcomes is substantially different between the training and test sets. There are three main ways to split the data that account for the similarity of resulted data sets. We will describe the three approaches using the clothing company customer data as examples.</p>
<ol style="list-style-type: decimal">
<li>Split data according to the outcome variable</li>
</ol>
<p>Assume the outcome variable is customer segment (column <code>segment</code>) and we decide to use 80% as training and 20% test. The goal is to make the proportions of the categories in the two sets as similar as possible. The <code>createDataPartition()</code> function in <code>caret</code> will return a balanced splitting based on assigned variable.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># load data</span>
sim.dat &lt;-<span class="st"> </span><span class="kw">read.csv</span>(<span class="st">&quot;https://raw.githubusercontent.com/happyrabbit/DataScientistR/master/Data/SegData.csv&quot;</span>)
<span class="kw">library</span>(caret)
<span class="co"># set random seed to make sure reproducibility</span>
<span class="kw">set.seed</span>(<span class="dv">3456</span>)
trainIndex &lt;-<span class="st"> </span><span class="kw">createDataPartition</span>(sim.dat<span class="op">$</span>segment, <span class="dt">p =</span> <span class="fl">0.8</span>, <span class="dt">list =</span> <span class="ot">FALSE</span>, 
    <span class="dt">times =</span> <span class="dv">1</span>)
<span class="kw">head</span>(trainIndex)</code></pre></div>
<pre><code>##      Resample1
## [1,]         1
## [2,]         2
## [3,]         3
## [4,]         4
## [5,]         6
## [6,]         7</code></pre>
<p>The <code>list = FALSE</code> in the call to <code>createDataPartition</code> is to return a data frame. The <code>times = 1</code> tells R how many times you want to split the data. Here we only do it once, but you can repeat the splitting multiple times. In that case, the function will return multiple vectors indicating the rows to training/test. You can set <code>times＝2</code> and rerun the above code to see the result. Then we can use the returned indicator vector <code>trainIndex</code> to get training and test sets:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># get training set</span>
datTrain &lt;-<span class="st"> </span>sim.dat[trainIndex, ]
<span class="co"># get test set</span>
datTest &lt;-<span class="st"> </span>sim.dat[<span class="op">-</span>trainIndex, ]</code></pre></div>
<p>According to the setting, there are 800 samples in the training set and 200 in test set. Let’s check the distribution of the two sets:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(plyr)
<span class="kw">ddply</span>(datTrain, <span class="st">&quot;segment&quot;</span>, summarise, <span class="dt">count =</span> <span class="kw">length</span>(segment), 
    <span class="dt">percentage =</span> <span class="kw">round</span>(<span class="kw">length</span>(segment)<span class="op">/</span><span class="kw">nrow</span>(datTrain), <span class="dv">2</span>))</code></pre></div>
<pre><code>##       segment count percentage
## 1 Conspicuous   160       0.20
## 2       Price   200       0.25
## 3     Quality   160       0.20
## 4       Style   280       0.35</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">ddply</span>(datTest, <span class="st">&quot;segment&quot;</span>, summarise, <span class="dt">count =</span> <span class="kw">length</span>(segment), 
    <span class="dt">percentage =</span> <span class="kw">round</span>(<span class="kw">length</span>(segment)<span class="op">/</span><span class="kw">nrow</span>(datTest), <span class="dv">2</span>))</code></pre></div>
<pre><code>##       segment count percentage
## 1 Conspicuous    40       0.20
## 2       Price    50       0.25
## 3     Quality    40       0.20
## 4       Style    70       0.35</code></pre>
<p>The percentages are the same for these two sets. In practice, it is possible that the distributions are not exactly identical but should be close.</p>
<ol start="2" style="list-style-type: decimal">
<li>Divide data according to predictors</li>
</ol>
<p>An alternative way is to split data based on the predictors. The goal is to get a diverse subset from a dataset so that the sample is representative. In other words, we need an algorithm to identify the <span class="math inline">\(n\)</span> most diverse samples from a dataset with size <span class="math inline">\(N\)</span>. However, the task is generally infeasible for non-trivial values of <span class="math inline">\(n\)</span> and <span class="math inline">\(N\)</span> <span class="citation">(Willett <a href="#ref-willett">2004</a>)</span>. And hence practicable approaches to dissimilarity-based selection involve approximate methods that are sub-optimal. A major class of algorithms split the data on <em>maximum dissimilarity sampling</em>. The process starts from:</p>
<ul>
<li>Initialize a single sample as starting test set</li>
<li>Calculate the dissimilarity between this initial sample and each remaining samples in the dataset</li>
<li>Add the most dissimilar unallocated sample to the test set</li>
</ul>
<p>To move forward, we need to define the dissimilarity between groups. Each definition results in a different version of the algorithm and hence a different subset. It is the same problem as in hierarchical clustering where you need to define a way to measure the distance between clusters. The possible approaches are to use minimum, maximum, sum of all distances, the average of all distances, etc. Unfortunately, there is not a single best choice, and you may have to try multiple methods and check the resulted sample sets. R users can implement the algorithm using <code>maxDissim()</code> function from <code>caret</code> package. The <code>obj</code> argument is to set the definition of dissimilarity. Refer to the help documentation for more details (<code>?maxDissim</code>).</p>
<p>Let’s use two variables (<code>age</code> and <code>income</code>) from the customer data as an example to illustrate how it works in R and compare maximum dissimilarity sampling with random sampling.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(lattice)
<span class="co"># select variables</span>
testing &lt;-<span class="st"> </span><span class="kw">subset</span>(sim.dat, <span class="dt">select =</span> <span class="kw">c</span>(<span class="st">&quot;age&quot;</span>, <span class="st">&quot;income&quot;</span>))</code></pre></div>
<p>Random select 5 samples as initial subset (<code>start</code>) , the rest will be in <code>samplePool</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">set.seed</span>(<span class="dv">5</span>)
<span class="co"># select 5 random samples</span>
startSet &lt;-<span class="st"> </span><span class="kw">sample</span>(<span class="dv">1</span><span class="op">:</span><span class="kw">dim</span>(testing)[<span class="dv">1</span>], <span class="dv">5</span>)
start &lt;-<span class="st"> </span>testing[startSet, ]
<span class="co"># save the rest in data frame &#39;samplePool&#39;</span>
samplePool &lt;-<span class="st"> </span>testing[<span class="op">-</span>startSet, ]</code></pre></div>
<p>Use <code>maxDissim()</code> to select another 5 samples from <code>samplePool</code> that are as different as possible with the initical set <code>start</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">selectId &lt;-<span class="st"> </span><span class="kw">maxDissim</span>(start, samplePool, <span class="dt">obj =</span> minDiss, <span class="dt">n =</span> <span class="dv">5</span>)
minDissSet &lt;-<span class="st"> </span>samplePool[selectId, ]</code></pre></div>
<p>The <code>obj = minDiss</code> in the above code tells R to use minimum dissimilarity to define the distance between groups. Next, random select 5 samples from <code>samplePool</code> in data frame <code>RandomSet</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">selectId &lt;-<span class="st"> </span><span class="kw">sample</span>(<span class="dv">1</span><span class="op">:</span><span class="kw">dim</span>(samplePool)[<span class="dv">1</span>], <span class="dv">5</span>)
RandomSet &lt;-<span class="st"> </span>samplePool[selectId, ]</code></pre></div>
<p>Plot the resulted set to compare different sampling methods:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">start<span class="op">$</span>group &lt;-<span class="st"> </span><span class="kw">rep</span>(<span class="st">&quot;Initial Set&quot;</span>, <span class="kw">nrow</span>(start))
minDissSet<span class="op">$</span>group &lt;-<span class="st"> </span><span class="kw">rep</span>(<span class="st">&quot;Maximum Dissimilarity Sampling&quot;</span>, <span class="kw">nrow</span>(minDissSet))
RandomSet<span class="op">$</span>group &lt;-<span class="st"> </span><span class="kw">rep</span>(<span class="st">&quot;Random Sampling&quot;</span>, <span class="kw">nrow</span>(RandomSet))
<span class="kw">xyplot</span>(age <span class="op">~</span><span class="st"> </span>income, <span class="dt">data =</span> <span class="kw">rbind</span>(start, minDissSet, RandomSet), <span class="dt">grid =</span> <span class="ot">TRUE</span>, 
    <span class="dt">group =</span> group, <span class="dt">auto.key =</span> <span class="ot">TRUE</span>)</code></pre></div>
<div class="figure" style="text-align: center">
<img src="IDS_files/figure-html/maxdis-1.svg" alt="Compare Maximum Dissimilarity Sampling with  Random Sampling" width="80%" />
<p class="caption">
(#fig:maxdis)Compare Maximum Dissimilarity Sampling with Random Sampling
</p>
</div>
<p>The points from maximum dissimilarity sampling are far away from the initial samples ( Fig. @ref(fig:maxdis), while the random samples are much closer to the initial ones. Why do we need a diverse subset? Because we hope the test set to be representative. If all test set samples are from respondents younger than 30, model performance on the test set has a high risk to fail to tell you how the model will perform on more general population.</p>
<ul>
<li>Divide data according to time</li>
</ul>
<p>For time series data, random sampling is usually not the best way. There is an approach to divide data according to time-series. Since time series is beyond the scope of this book, there is not much discussion here. For more detail of this method, see <span class="citation">(Hyndman and Athanasopoulos <a href="#ref-Hyndman">2013</a>)</span>. We will use a simulated first-order autoregressive model [AR (1)] time-series data with 100 observations to show how to implement using the function <code>createTimeSlices ()</code> in the <code>caret</code> package.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># simulte AR(1) time series samples</span>
timedata =<span class="st"> </span><span class="kw">arima.sim</span>(<span class="kw">list</span>(<span class="dt">order=</span><span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">0</span>), <span class="dt">ar=</span><span class="op">-</span>.<span class="dv">9</span>), <span class="dt">n=</span><span class="dv">100</span>)
<span class="co"># plot time series</span>
<span class="kw">plot</span>(timedata, <span class="dt">main=</span>(<span class="kw">expression</span>(<span class="kw">AR</span>(<span class="dv">1</span>)<span class="op">~</span><span class="er">~~</span>phi<span class="op">==-</span>.<span class="dv">9</span>)))     </code></pre></div>
<div class="figure" style="text-align: center">
<img src="IDS_files/figure-html/times-1.svg" alt="Divide data according to time" width="80%" />
<p class="caption">
(#fig:times)Divide data according to time
</p>
</div>
<p>Fig. @ref(fig:times) shows 100 simulated time series observation. The goal is to make sure both training and test set to cover the whole period.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">timeSlices &lt;-<span class="st"> </span><span class="kw">createTimeSlices</span>(<span class="dv">1</span><span class="op">:</span><span class="kw">length</span>(timedata), 
                   <span class="dt">initialWindow =</span> <span class="dv">36</span>, <span class="dt">horizon =</span> <span class="dv">12</span>, <span class="dt">fixedWindow =</span> T)
<span class="kw">str</span>(timeSlices,<span class="dt">max.level =</span> <span class="dv">1</span>)</code></pre></div>
<pre><code>## List of 2
##  $ train:List of 53
##  $ test :List of 53</code></pre>
<p>There are three arguments in the above <code>createTimeSlices()</code>.</p>
<ul>
<li><code>initialWindow</code>: The initial number of consecutive values in each training set sample</li>
<li><code>horizon</code>: the number of consecutive values in test set sample</li>
<li><code>fixedWindow</code>: if FALSE, all training samples start at 1</li>
</ul>
<p>The function returns two lists, one for the training set, the other for the test set. Let’s look at the first training sample:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># get result for the 1st training set</span>
trainSlices &lt;-<span class="st"> </span>timeSlices[[<span class="dv">1</span>]]
<span class="co"># get result for the 1st test set</span>
testSlices &lt;-<span class="st"> </span>timeSlices[[<span class="dv">2</span>]]
<span class="co"># check the index for the 1st training and test set</span>
trainSlices[[<span class="dv">1</span>]]</code></pre></div>
<pre><code>##  [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17
## [18] 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34
## [35] 35 36</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">testSlices[[<span class="dv">1</span>]]</code></pre></div>
<pre><code>##  [1] 37 38 39 40 41 42 43 44 45 46 47 48</code></pre>
<p>The first training set is consist of sample 1-36 in the dataset (<code>initialWindow = 36</code>). Then sample 37-48 are in the first test set ( <code>horizon = 12</code>). Type <code>head(trainSlices)</code> or <code>head(testSlices)</code> to check the later samples. If you are not clear about the argument <code>fixedWindow</code>, try to change the setting to be <code>F</code> and check the change in <code>trainSlices</code> and <code>testSlices</code>.</p>
<p>Understand and implement data splitting is not difficult. But there are two things to note:</p>
<ol style="list-style-type: decimal">
<li>The randomness in the splitting process will lead to uncertainty in performance measurement.</li>
<li>When the dataset is small, it can be too expensive to leave out test set. In this situation, if collecting more data is just not possible, the best shot is to use leave-one-out cross-validation which is in the next section.</li>
</ol>
</div>
<div id="resampling" class="section level3">
<h3><span class="header-section-number">6.2.2</span> Resampling</h3>
<p>You can consider resampling as repeated splitting. The basic idea is: use part of the data to fit model and then use the rest of data to calculate model performance. Repeat the process multiple times and aggregate the results. The differences in resampling techniques usually center around the ways to choose subsamples. There are two main reasons that we may need resampling:</p>
<ol style="list-style-type: decimal">
<li><p>Estimate tuning parameters through resampling. Some examples of models with such parameters are Support Vector Machine (SVM), models including the penalty (LASSO) and random forest.</p></li>
<li><p>For models without tuning parameter, such as ordinary linear regression and partial least square regression, the model fitting doesn’t require resampling. But you can study the model stability through resampling.</p></li>
</ol>
<p>We will introduce three most common resampling techniques: k-fold cross-validation, repeated training/test splitting, and bootstrap.</p>
<div id="k-fold-cross-validation" class="section level4">
<h4><span class="header-section-number">6.2.2.1</span> k-fold cross-validation</h4>
<p>k-fold cross-validation is to partition the original sample into <span class="math inline">\(k\)</span> equal size subsamples (folds). Use one of the <span class="math inline">\(k\)</span> folds to validate the model and the rest <span class="math inline">\(k-1\)</span> to train model. Then repeat the process <span class="math inline">\(k\)</span> times with each of the <span class="math inline">\(k\)</span> folds as the test set. Aggregate the results into a performance profile.</p>
<p>Denote by <span class="math inline">\(\hat{f}^{-\kappa}(X)\)</span> the fitted function, computed with the <span class="math inline">\(\kappa^{th}\)</span> fold removed and <span class="math inline">\(x_i^\kappa\)</span> the predictors for samples in left-out fold. The process of k-fold cross-validation is as follows:</p>
<blockquote>
<ol style="list-style-type: decimal">
<li>Partition the original sample into <span class="math inline">\(k\)</span> equal size folds</li>
<li>for <span class="math inline">\(\kappa=1…k\)</span></li>
</ol>
<ul>
<li>Use data other than fold <span class="math inline">\(\kappa\)</span> to train the model <span class="math inline">\(\hat{f}^{-\kappa}(X)\)</span></li>
<li>Apply <span class="math inline">\(\hat{f}^{-\kappa}(X)\)</span> to predict fold <span class="math inline">\(\kappa\)</span> to get <span class="math inline">\(\hat{f}^{-\kappa}(x_i^\kappa)\)</span></li>
</ul>
<ol start="3" style="list-style-type: decimal">
<li>Aggregate the results <span class="math display">\[\hat{Error} = \frac{1}{N}\Sigma_{\kappa=1}^k\Sigma_{x_i^{\kappa}}L(y_i^{\kappa},\hat{f}^{-\kappa}(x_i^\kappa))\]</span></li>
</ol>
</blockquote>
<p>It is a standard way to find the value of tuning parameter that gives you the best performance. It is also a way to study the variability of model performance.</p>
<p>The following figure represents a 5-fold cross-validation example.</p>
<div class="figure">
<img src="images/cv5fold.png" alt="5-fold cross-validation" />
<p class="caption">5-fold cross-validation</p>
</div>
<p>A special case of k-fold cross-validation is Leave One Out Cross Validation (LOOCV) where <span class="math inline">\(k=1\)</span>. When sample size is small, it is desired to use as many data to train the model. Most of the functions have default setting <span class="math inline">\(k=10\)</span>. The choice is usually 5-10 in practice, but there is no standard rule. The more folds to use, the more samples are used to fit model, and then the performance estimate is closer to the theoretical performance. Meanwhile, the variance of the performance is larger since the samples to fit model in different iterations are more similar. However, LOOCV has high computational cost since the number of interactions is the same as the sample size and each model fit uses a subset that is nearly the same size of the training set. On the other hand, when k is small (such as 2 or 3), the computation is more efficient, but the bias will increase. When the sample size is large, the impact of <span class="math inline">\(k\)</span> becomes marginal.</p>
<p>Chapter 7 of <span class="citation">(Hastie T <a href="#ref-Hastie2008">2008</a>)</span> presents a more in-depth and more detailed discussion about the bias-variance trade-off in k-fold cross-validation.</p>
<p>You can implement k-fold cross-validation using <code>createFolds()</code> in <code>caret</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(caret)
class&lt;-sim.dat<span class="op">$</span>segment
<span class="co"># creat k-folds</span>
<span class="kw">set.seed</span>(<span class="dv">1</span>)
cv&lt;-<span class="kw">createFolds</span>(class,<span class="dt">k=</span><span class="dv">10</span>,<span class="dt">returnTrain=</span>T)
<span class="kw">str</span>(cv)</code></pre></div>
<pre><code>## List of 10
##  $ Fold01: int [1:900] 1 2 3 4 5 6 7 8 9 10 ...
##  $ Fold02: int [1:900] 1 2 3 4 5 6 7 9 10 11 ...
##  $ Fold03: int [1:900] 1 2 3 4 5 6 7 8 10 11 ...
##  $ Fold04: int [1:900] 1 2 3 4 5 6 7 8 9 11 ...
##  $ Fold05: int [1:900] 1 3 4 6 7 8 9 10 11 12 ...
##  $ Fold06: int [1:900] 1 2 3 4 5 6 7 8 9 10 ...
##  $ Fold07: int [1:900] 2 3 4 5 6 7 8 9 10 11 ...
##  $ Fold08: int [1:900] 1 2 3 4 5 8 9 10 11 12 ...
##  $ Fold09: int [1:900] 1 2 4 5 6 7 8 9 10 11 ...
##  $ Fold10: int [1:900] 1 2 3 5 6 7 8 9 10 11 ...</code></pre>
<p>The above code creates ten folds (<code>k=10</code>) according to the customer segments (we set <code>class</code> to be the categorical variable <code>segment</code>). The function returns a list of 10 with the index of rows in training set.</p>
</div>
<div id="repeated-trainingtest-splits" class="section level4">
<h4><span class="header-section-number">6.2.2.2</span> Repeated Training/Test Splits</h4>
<p>In fact, this method is nothing but repeating the training/test set division on the original data. Fit the model with the training set, and evaluate the model with the test set. Unlike k-fold cross-validation, the test set generated by this procedure may have duplicate samples. A sample usually shows up in more than one test sets. There is no standard rule for split ratio and number of repetitions. The most common choice in practice is to use 75% to 80% of the total sample for training. The remaining samples are for validation. The more sample in the training set, the less biased the model performance estimate is. Increasing the repetitions can reduce the uncertainty in the performance estimates. Of course, it is at the cost of computational time when the model is complex. The number of repetitions is also related to the sample size of the test set. If the size is small, the performance estimate is more volatile. In this case, the number of repetitions needs to be higher to deal with the uncertainty of the evaluation results.</p>
<p>We can use the same function (<code>createDataPartition ()</code>) as before. If you look back, you will see <code>times = 1</code>. The only thing to change is to set it to the number of repetitions.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">trainIndex &lt;-<span class="st"> </span><span class="kw">createDataPartition</span>(sim.dat<span class="op">$</span>segment, <span class="dt">p =</span> .<span class="dv">8</span>, <span class="dt">list =</span> <span class="ot">FALSE</span>, <span class="dt">times =</span> <span class="dv">5</span>)
dplyr<span class="op">::</span><span class="kw">glimpse</span>(trainIndex)</code></pre></div>
<pre><code>##  int [1:800, 1:5] 1 3 4 5 6 7 8 9 10 11 ...
##  - attr(*, &quot;dimnames&quot;)=List of 2
##   ..$ : NULL
##   ..$ : chr [1:5] &quot;Resample1&quot; &quot;Resample2&quot; &quot;Resample3&quot; &quot;Resample4&quot; ...</code></pre>
<p>Once know how to split the data, the repetition comes naturally.</p>
</div>
<div id="bootstrap-methods" class="section level4">
<h4><span class="header-section-number">6.2.2.3</span> Bootstrap Methods</h4>
<p>Bootstrap is a powerful statistical tool (a little magic too). It can be used to analyze the uncertainty of parameter estimates <span class="citation">(Efron and Tibshirani <a href="#ref-bootstrap1986">1986</a>)</span> quantitatively. For example, estimate the standard deviation of linear regression coefficients. The power of this method is that the concept is so simple that it can be easily applied to any model as long as the computation allows. However, you can hardly obtain the standard deviation for some models by using the traditional statistical inference.</p>
<p>Since it is with replacement, a sample can be selected multiple times, and the bootstrap sample size is the same as the original data. So for every bootstrap set, there are some left-out samples, which is also called “out-of-bag samples.” The out-of-bag sample is used to evaluate the model. Efron points out that under normal circumstances <span class="citation">(Efron <a href="#ref-efron1983">1983</a>)</span>, bootstrap estimates the error rate of the model with more certainty.The probability of an observation <span class="math inline">\(i\)</span> in bootstrap sample B is:</p>
<p><span class="math inline">\(\begin{array}{ccc} Pr{i\in B} &amp; = &amp; 1-\left(1-\frac{1}{N}\right)^{N}\\  &amp; \approx &amp; 1-e^{-1}\\  &amp; = &amp; 0.632 \end{array}\)</span></p>
<p>On average, 63.2% of the observations appeared at least once in a bootstrap sample, so the estimation bias is similar to 2-fold cross-validation. As mentioned earlier, the smaller the number of folds, the larger the bias. Increasing the sample size will ease the problem. In general, bootstrap has larger bias and smaller uncertainty than cross-validation. Efron came up the following “.632 estimator” to alleviate this bias:</p>
<p><span class="math display">\[(0.632 × original\ bootstrap\ estimate) + (0.368 × apparent\ error\ rate)\]</span></p>
<p>The apparent error rate is the error rate when the data is used twice, both to fit the model and to check its accuracy and it is apparently over-optimistic. The modified bootstrap estimate reduces the bias but can be unstable with small samples size. This estimate can also be unduly optimistic when the model severely over-fits since the apparent error rate will be close to zero. Efron and Tibshirani <span class="citation">(Efron and Tibshirani <a href="#ref-b632plus">1997</a>)</span> discuss another technique, called the “632+ method,” for adjusting the bootstrap estimates.</p>
<!--chapter:end:06-ModelTuning.Rmd-->
</div>
</div>
</div>
</div>
<div id="measuring-performance" class="section level1">
<h1><span class="header-section-number">7</span> Measuring Performance</h1>
<p>In order to compare different models, we need a way to measure model performance. There are different metrics to use. Sometimes, it is better to look at models through multiple lens. In this chapter, we will introduce some of the most common measurement metrics.</p>
<div id="regression-model-performance" class="section level2">
<h2><span class="header-section-number">7.1</span> Regression Model Performance</h2>
</div>
<div id="classification-model-performance" class="section level2">
<h2><span class="header-section-number">7.2</span> Classification Model Performance</h2>
<!--chapter:end:07-MeasurePerformance.Rmd-->
</div>
</div>
<div id="feature-engineering" class="section level1">
<h1><span class="header-section-number">8</span> Feature Engineering</h1>
<div id="feature-construction" class="section level2">
<h2><span class="header-section-number">8.1</span> Feature Construction</h2>
</div>
<div id="feature-extraction" class="section level2">
<h2><span class="header-section-number">8.2</span> Feature Extraction</h2>
</div>
<div id="feature-selection" class="section level2">
<h2><span class="header-section-number">8.3</span> Feature Selection</h2>
<div id="filter-method" class="section level3">
<h3><span class="header-section-number">8.3.1</span> Filter Method</h3>
</div>
<div id="wrapper-method" class="section level3">
<h3><span class="header-section-number">8.3.2</span> Wrapper Method</h3>
<!--chapter:end:08-FeatureEngineering.Rmd-->
</div>
</div>
</div>
<div id="regression-models" class="section level1">
<h1><span class="header-section-number">9</span> Regression Models</h1>
<div id="ordinary-least-squares" class="section level2">
<h2><span class="header-section-number">9.1</span> Ordinary Least Squares</h2>
</div>
<div id="multivariate-adaptive-regression-splines" class="section level2">
<h2><span class="header-section-number">9.2</span> Multivariate Adaptive Regression Splines</h2>
</div>
<div id="generalized-linear-model" class="section level2">
<h2><span class="header-section-number">9.3</span> Generalized Linear Model</h2>
</div>
<div id="pcr-and-pls" class="section level2">
<h2><span class="header-section-number">9.4</span> PCR and PLS</h2>
<!--chapter:end:09-Regression.Rmd-->
</div>
</div>
<div id="regularization-methods" class="section level1">
<h1><span class="header-section-number">10</span> Regularization Methods</h1>
<div id="ridge-regression" class="section level2">
<h2><span class="header-section-number">10.1</span> Ridge Regression</h2>
</div>
<div id="lasso" class="section level2">
<h2><span class="header-section-number">10.2</span> LASSO</h2>
</div>
<div id="elastic-net" class="section level2">
<h2><span class="header-section-number">10.3</span> Elastic Net</h2>
</div>
<div id="lasso-generalized-linear-model" class="section level2">
<h2><span class="header-section-number">10.4</span> LASSO Generalized Linear Model</h2>
<!--chapter:end:10-Regularization.Rmd-->
</div>
</div>
<div id="tree-based-methods" class="section level1">
<h1><span class="header-section-number">11</span> Tree-Based Methods</h1>
<p>The tree-based models can be used for regression and classification. They are conceptually simple yet powerful. This type of model is often referred to as Classification And Regression Trees (CART). They are popular tools for many reasons:</p>
<ol style="list-style-type: decimal">
<li>Do not require user to specify the form of the relationship between predictors and response</li>
<li>Do not require (or if they do, very limited) data preprocessing and can handle different types of predictors (sparse, skewed, continuous, categorical, etc.)</li>
<li>Robust to co-linearity</li>
<li>Can handle missing data</li>
<li>Many pre-built packages make implementation as easy as a button push</li>
</ol>
<p>CART can refer to the tree model in general, but most of the time, it represents the algorithm initially proposed by Breiman <span class="citation">(al <a href="#ref-Breiman1984">1984</a>)</span>. After Breiman, there are many new algorithms, such as ID3, C4.5, and C5.0. C5.0 is an improved version of C4.5, but since C5.0 is not open source, the C4.5 algorithm is more popular. C4.5 was a major competitor of CART. But now, all those seem outdated. The most popular tree models are Random Forest (RF) and Gradient Boosting Machine (GBM). Despite being out of favor in application, it is important to understand the mechanism of the basic tree algorithm. Because the later models are based on the same foundation.</p>
<p>The original CART algorithm targets binary classification, and the later algorithms can handle multi-category classification. A single tree is easy to explain but has poor accuracy. More complicated tree models, such as RF and GBM, can provide much better prediction at the cost of explainability. As the model becoming more complicated, it is more like a black-box which makes it very difficult to explain the relationship among predictors. There is always a trade-off between explainability and predictability.</p>
<center>
<img src="../linhui.org/book/Figure/treeEN.png" />
</center>
<p>The reason why it is called “tree” is of course because the structure has similarities. But the direction of the decision tree is opposite to the real tree, the root is on the top, and the leaf is on the bottom. From the root node, a decision tree divides to different branches and generates more nodes. The new nodes are child nodes, and the previous node is the parent node. At each child node, the algorithm will decide whether to continue dividing. If it stops, the node is called a leaf node. If it continues, then the node becomes the new parent node and splits to produce the next layer of child nodes. At each non-leaf node, the algorithm needs to decide split into branches. The leaf node contains the final “decision,” final class the sample belongs to or the sample’s value has. Here are the important definitions in the tree model:</p>
<ul>
<li><strong>Classification tree</strong>: the outcome is discrete</li>
<li><strong>Regression tree</strong>: the outcome is continuous (e.g. the price of a house, or a patient’s length of stay in a hospital)</li>
<li><strong>Non-leaf node (or split node)</strong>: the algorithm needs to decide a split at each non-leaf node (eg: <span class="math inline">\(age \leq 25\)</span>, <span class="math inline">\(25 &lt; age \leq 35\)</span>, <span class="math inline">\(age &gt; 35\)</span>)</li>
<li><strong>Root node</strong>：the beginning node where the tree starts</li>
<li><strong>Leaf node (or Terminal node)</strong>: the node stops splitting. It has the final decision of the model</li>
<li><strong>Degree of the node</strong>: the number of subtrees of a node</li>
<li><strong>Degree of the tree</strong>: the maximum degree of a node in the tree</li>
<li><strong>Pruning</strong>: remove parts of the tree that do not provide power to classify instances</li>
<li><strong>Branch (or Subtree)</strong>: the whole part under a non-leaf node</li>
<li><strong>Child</strong>: the node directly after and connected to another node</li>
<li><strong>Parent</strong>: the converse notion of a child</li>
</ul>
<p>Single tree is easy to explain but has high variance and low accuracy, and hence is very limited. Minor changes in the training data can lead to large changes in the fitted tree. A series of rectangular decision regions defined by a single tree is often too naive to represent the relationship between the dependent variable and the predictors. To overcome these shortcomings, researchers have proposed ensemble methods which combine many trees. Ensemble tree models typically have much better predictive performance than a single tree. We will introduce those models in later sections.</p>
<div id="splitting-criteria" class="section level2">
<h2><span class="header-section-number">11.1</span> Splitting Criteria</h2>
<p>The splitting criteria used by the regression tree and the classification tree are different. Like the regression tree, the goal of the classification tree is to divide the data into smaller, more homogeneous groups. Homogeneity means that most of the samples at each node are from one class. The original CART algorithm uses Gini impurity as the splitting criterion; The later ID3, C4.5, and C5.0 use entropy. We will look at three most common splitting criteria.</p>
<p><strong>Gini impurity</strong></p>
<p>Gini impurity<span class="citation">(al <a href="#ref-Breiman1984">1984</a>)</span> is a measure of non-homogeneity. It is widely used in classification tree. For a two-class problem, the Gini impurity for a given node is defined as:</p>
<p><span class="math display">\[p_{1}(1-p_{1})+p_{2}(1-p_{2})\]</span></p>
<p>where <span class="math inline">\(p_{1}\)</span> and <span class="math inline">\(p_{2}\)</span> are probabilities for the two classes respectively. It is easy to see that when the sample set is pure, one of the probability is 0 and the Gini score is the smallest. Conversely, when <span class="math inline">\(p_{1}=p_{2}=0.5\)</span>, the Gini score is the largest, in which case the purity of the node is the smallest. Let’s look at an example. Suppose we want to determine which students are computer science (CS) majors. Here is the simple hypothetical classification tree result obtained with the gender variable.</p>
<center>
<img src="../linhui.org/book/Figure/giniEN.PNG" />
</center>
<p>Let’s calculate the Gini impurity for splitting node “Gender”:</p>
<ol style="list-style-type: decimal">
<li>Gini impurity for “Female” = <span class="math inline">\(\frac{1}{6}\times\frac{5}{6}+\frac{5}{6}\times\frac{1}{6}=\frac{5}{18}\)</span></li>
<li>Gini impurity for “Male” = <span class="math inline">\(0\times1+1\times 0=0\)</span></li>
</ol>
<p>The Gini impurity for the node “Gender” is the following weighted average of the above two scores:</p>
<p><span class="math display">\[\frac{3}{5}\times\frac{5}{18}+\frac{2}{5}\times 0=\frac{1}{6}\]</span></p>
<p>The Gini impurity for the 50 samples in the parent node is <span class="math inline">\(\frac{1}{2}\)</span>. It is easy to calculate the Gini impurity drop from <span class="math inline">\(\frac{1}{2}\)</span> to <span class="math inline">\(\frac{1}{6}\)</span> after splitting. The split using “gender” causes a Gini impurity decrease of <span class="math inline">\(\frac{1}{3}\)</span>. The algorithm will use different variables to split the data and choose the one that causes the most substantial Gini impurity decrease.</p>
<p><strong>Information gain</strong></p>
<p>Looking at the samples in the following three nodes, which one is the easiest to describe? It is obviously C. Because all the samples in C are of the same type, so the description requires the least amount of information. On the contrary, B needs more information, and A needs the most information. In other words, C has the highest purity, B is the second, and A has the lowest purity. We need less information to describe nodes with lower purity.</p>
<center>
<img src="../linhui.org/book/Figure/InfoGainEN.PNG" />
</center>
<p>A measure of the degree of disorder is entropy which is defined as:</p>
<p><span class="math display">\[Entropy=-plog_{2}p-(1-p)log_{2}(1-p)\]</span></p>
<p>where p is the percentage of one type of samples. If all the samples in one node are of one type (such as C), the entropy is 0. If the proportion of each type in a node is 50%－50%, the entropy is 1. We can use entropy as splitting criteria. The goal is to decrease entropy as the tree grows.</p>
<p>Similarly, the entropy of a splitting node is the weighted average of the entropy of each child. In the above tree for the students, the entropy of the root node with all 50 students is <span class="math inline">\(-\frac{25}{50}log_{2}\frac{25}{50}-\frac{25}{50}log_{2}\frac{25}{50}=1\)</span>. Here an entropy of 1 indicates that the purity of the node is the lowest, that is, each type takes up half of the samples.</p>
<p>The entropy of the split using variable “gender” can be calculated in three steps:</p>
<ol style="list-style-type: decimal">
<li>Entropy for “Female” = <span class="math inline">\(-\frac{5}{30}log_{2}\frac{5}{30}-\frac{25}{30}log_{2}\frac{25}{30}=0.65\)</span></li>
<li>Entropy for “Male” = <span class="math inline">\(0\times1+1\times 0=0\)</span></li>
<li>Entropy for the node “Gender” is the weighted average of the above two entropy numbers: <span class="math inline">\(\frac{3}{5}\times 0.65+\frac{2}{5}\times 0=0.39\)</span></li>
</ol>
<p>So entropy decreases from 1 to 0.39 after the split.</p>
<p><strong>Sum of Square Error (SSE)</strong></p>
<p>The previous two metrics are for classification tree. The SSE is the most widely used splitting metric for regression. Suppose you want to divide the data set <span class="math inline">\(S\)</span> into two groups of <span class="math inline">\(S_{1}\)</span> and <span class="math inline">\(S_{2}\)</span>, where the selection of <span class="math inline">\(S_{1}\)</span> and <span class="math inline">\(S_{2}\)</span> needs to minimize the sum of squared errors:</p>
<span class="math display">\[\begin{equation}
SSE=\Sigma_{i\in S_{1}}(y_{i}-\bar{y}_{1})^{2}+\Sigma_{i\in S_{2}}(y_{i}-\bar{y}_{2})^{2}
(\#eq:treesse)
\end{equation}\]</span>
<p>In equation @ref(eq:treesse), <span class="math inline">\(\bar{y}_{1}\)</span> and <span class="math inline">\(\bar{y}_{1}\)</span> are the average of the sample in <span class="math inline">\(S_{1}\)</span> and <span class="math inline">\(S_{2}\)</span>. The way regression tree grows is to automatically decide on the splitting variables and split points that can maximize <strong>SSE reduction</strong>. Since this process is essentially a recursive segmentation, this approach is also called recursive partitioning.</p>
<p>Take a look at this simple regression tree for the height of 10 students:</p>
<center>
<img src="images/varEN.png" />
</center>
<p>You can calculate the SSE using the following code:</p>
<ol style="list-style-type: decimal">
<li>SSE for “Female” is 136</li>
<li>SSE for “Male” is 32</li>
<li>SSE for splitting node “Gender” is the sum of the above two numbers which is 168</li>
</ol>
<p>SSE for the 10 students in root node is 522.9. After the split, SSE decreases from 522.9 to 168.</p>
<p>If there is another possible way of splitting, divide it by major, as follows:</p>
<center>
<img src="images/varEN2.png" />
</center>
<p>In this situation:</p>
<ol style="list-style-type: decimal">
<li>SSE for “Math” is 184</li>
<li>SSE for “English” is 302.8</li>
<li>SSE for splitting node “Major” is the sum of the above two numbers which is 486.8</li>
</ol>
<p>Splitting data using variable “gender” reduced SSE from 522.9 to 168; using variable “major” reduced SSE from 522.9 to 486.8. Based on SSE reduction, you should use gender to split the data.</p>
<p>The three splitting criteria mentioned above are the basis for building a tree model.</p>
</div>
<div id="tree-pruning" class="section level2">
<h2><span class="header-section-number">11.2</span> Tree Pruning</h2>
<p>Pruning is the process that reduces the size of decision trees. It reduces the risk of overfitting by limiting the size of the tree or removing sections of the tree that provide little power.</p>
<p><strong>Limit the size</strong></p>
<p>You can limit the tree size by setting some parameters.</p>
<ul>
<li><p>Minimum sample size at each node: Defining the minimum sample size at the node helps to prevent the leaf nodes having only one sample. The sample size can be a tuning parameter. If it is too large, the model tends to under-fit. If it is too small, the model tends to over-fit. In the case of severe class imbalance, the minimum sample size may need to be smaller because the number of samples in a particular class is small.</p></li>
<li><p>Maximum depth of the tree: If the tree grows too deep, the model tends to over-fit. It can be a tuning parameter.</p></li>
<li><p>Maximum number of terminal nodes: Limit on the terminal nodes works the same as the limit on the depth of the tree. They are proportional.</p></li>
<li><p>The number of variables considered for each split: the algorithm randomly selects variables used in finding the optimal split point at each level. In general, the square root of the number of all variables works best, which is also the default setting for many functions. However, people often treat it as a tuning parameter.</p></li>
</ul>
</div>
<div id="regression-and-decision-tree-basic" class="section level2">
<h2><span class="header-section-number">11.3</span> Regression and Decision Tree Basic</h2>
</div>
<div id="bagging-tree-1" class="section level2">
<h2><span class="header-section-number">11.4</span> Bagging Tree</h2>
</div>
<div id="random-forest" class="section level2">
<h2><span class="header-section-number">11.5</span> Random Forest</h2>
</div>
<div id="gradient-boosted-machine" class="section level2">
<h2><span class="header-section-number">11.6</span> Gradient Boosted Machine</h2>
<!--chapter:end:11-tree.Rmd-->
</div>
</div>
<div id="neural-network" class="section level1">
<h1><span class="header-section-number">12</span> Neural Network</h1>
<div id="projection-pursuit-regression" class="section level2">
<h2><span class="header-section-number">12.1</span> Projection Pursuit Regression</h2>
<p>Before moving onto neural networks, let us start with a broader framework, Projection Pursuit Regression (PPR). It has a form of <strong>additive model</strong> of the derived features rather than the inputs themselves. Another widely used algorithm, AdaBoost, also fits an additive model in a base learner.</p>
<p>Assume <span class="math inline">\(\mathbf{X^{T}}=(X_1,X_2,\dots,X_p)\)</span> is a vector with <span class="math inline">\(p\)</span> variables. <span class="math inline">\(Y\)</span> is the corresponding response variable. <span class="math inline">\(\mathbf{\omega_{m}},m=1,2,\dots,M\)</span> is parameter vector with <span class="math inline">\(p\)</span> elements.</p>
<p><span class="math display">\[f(\mathbf{X})=\sum_{m=1}^{M}g_{m}(\mathbf{\omega_{m}^{T}X})\]</span></p>
<p>The new feature <span class="math inline">\(\mathbf{V_{m}}=\mathbf{\omega_{m}^{T}X}\)</span> is a linear combination of input variables <span class="math inline">\(\mathbf{X}\)</span>. The additive model is based on the new features. Here <span class="math inline">\(\mathbf{\omega_{m}}\)</span> is a unit vector, and the new feature <span class="math inline">\(\mathbf{v_m}\)</span> is actually the projection of <span class="math inline">\(\mathbf{X}\)</span> on <span class="math inline">\(\mathbf{\omega_{m}}\)</span>. It projects the p-dimensional independent variable space onto the new M-dimensional feature space. This is similar to the principal component analysis except that the principal component is orthogonal projection but it is not necessarily orthogonal here.</p>
<p>I know it is very abstract. Let’s look at some examples. Assume <span class="math inline">\(p=2\)</span>, i.e. there are two variables <span class="math inline">\(x_1\)</span> and <span class="math inline">\(x_2\)</span>. If <span class="math inline">\(M=1\)</span>, <span class="math inline">\(\mathbf{\omega^{T}}=(\frac{1}{2},\frac{\sqrt{3}}{2})\)</span>, then the corresponding <span class="math inline">\(v=\frac{1}{2}x_{1}+\frac{\sqrt{3}}{2}x_{2}\)</span>. Let’s try different setings and compare the results:</p>
<ol style="list-style-type: decimal">
<li><p><span class="math inline">\(\mathbf{\omega^{T}}=(\frac{1}{2},\frac{\sqrt{3}}{2})\)</span>, <span class="math inline">\(v=\frac{1}{2}x_{1}+\frac{\sqrt{3}}{2}x_{2}\)</span> , <span class="math inline">\(g(v)=\frac{1}{1+e^{-v}}\)</span></p></li>
<li><p><span class="math inline">\(\mathbf{\omega^{T}}=(1,0)\)</span>, <span class="math inline">\(v = x_1\)</span>, <span class="math inline">\(g(v)=(v+5)sin(\frac{1}{\frac{v}{3}+0.1})\)</span></p></li>
<li><p><span class="math inline">\(\mathbf{\omega^{T}}=(0,1)\)</span>, <span class="math inline">\(v = x_2\)</span>, <span class="math inline">\(g(v)=e^{\frac{v^2}{5}}\)</span></p></li>
<li><p><span class="math inline">\(\mathbf{\omega^{T}}=(1,0)\)</span>, <span class="math inline">\(v = x_1\)</span>, <span class="math inline">\(g(v)=(v+0.1)sin(\frac{1}{\frac{v}{3}+0.1})\)</span></p></li>
</ol>
<p>Here is how you can simulate the data and plot it using R:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># use plot3D package to generate 3D plot</span>
<span class="kw">library</span>(plot3D)
<span class="co"># get x1 and x2 note here x1 and x2 need to be matrix if you check the</span>
<span class="co"># two objects, you will find: columns in x1 are identical rows in x2</span>
<span class="co"># are identical mesh() is funciton from plot3D package you may need to</span>
<span class="co"># think a little here</span>
M &lt;-<span class="st"> </span><span class="kw">mesh</span>(<span class="kw">seq</span>(<span class="op">-</span><span class="fl">13.2</span>, <span class="fl">13.2</span>, <span class="dt">length.out =</span> <span class="dv">50</span>), <span class="kw">seq</span>(<span class="op">-</span><span class="fl">37.4</span>, <span class="fl">37.4</span>, <span class="dt">length.out =</span> <span class="dv">50</span>))
x1 &lt;-<span class="st"> </span>M<span class="op">$</span>x
x2 &lt;-<span class="st"> </span>M<span class="op">$</span>y
## setting 1 map X using w to get v
v &lt;-<span class="st"> </span>(<span class="dv">1</span><span class="op">/</span><span class="dv">2</span>) <span class="op">*</span><span class="st"> </span>x1 <span class="op">+</span><span class="st"> </span>(<span class="kw">sqrt</span>(<span class="dv">3</span>)<span class="op">/</span><span class="dv">2</span>) <span class="op">*</span><span class="st"> </span>x2
<span class="co"># apply g() on v</span>
g1 &lt;-<span class="st"> </span><span class="dv">1</span><span class="op">/</span>(<span class="dv">1</span> <span class="op">+</span><span class="st"> </span><span class="kw">exp</span>(<span class="op">-</span>v))
<span class="kw">par</span>(<span class="dt">mfrow =</span> <span class="kw">c</span>(<span class="dv">2</span>, <span class="dv">2</span>), <span class="dt">mar =</span> <span class="kw">c</span>(<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">0</span>))
<span class="kw">surf3D</span>(x1, x2, g1, <span class="dt">colvar =</span> g1, <span class="dt">border =</span> <span class="st">&quot;black&quot;</span>, <span class="dt">colkey =</span> <span class="ot">FALSE</span>, <span class="dt">box =</span> <span class="ot">FALSE</span>, 
    <span class="dt">main =</span> <span class="st">&quot;Setting 1&quot;</span>)
## setting 2
v &lt;-<span class="st"> </span>x1
g2 &lt;-<span class="st"> </span>(v <span class="op">+</span><span class="st"> </span><span class="dv">5</span>) <span class="op">*</span><span class="st"> </span><span class="kw">sin</span>(<span class="dv">1</span><span class="op">/</span>(v<span class="op">/</span><span class="dv">3</span> <span class="op">+</span><span class="st"> </span><span class="fl">0.1</span>))
<span class="kw">surf3D</span>(x1, x2, g2, <span class="dt">colvar =</span> g2, <span class="dt">border =</span> <span class="st">&quot;black&quot;</span>, <span class="dt">colkey =</span> <span class="ot">FALSE</span>, <span class="dt">box =</span> <span class="ot">FALSE</span>, 
    <span class="dt">main =</span> <span class="st">&quot;Setting 2&quot;</span>)
## setting 3
v &lt;-<span class="st"> </span>x2
g3 &lt;-<span class="st"> </span><span class="kw">exp</span>(v<span class="op">^</span><span class="dv">2</span><span class="op">/</span><span class="dv">5</span>)
<span class="kw">surf3D</span>(x1, x2, g3, <span class="dt">colvar =</span> g3, <span class="dt">border =</span> <span class="st">&quot;black&quot;</span>, <span class="dt">colkey =</span> <span class="ot">FALSE</span>, <span class="dt">box =</span> <span class="ot">FALSE</span>, 
    <span class="dt">main =</span> <span class="st">&quot;Setting 3&quot;</span>)
## setting 4
v &lt;-<span class="st"> </span>x1
g4 &lt;-<span class="st"> </span>(v <span class="op">+</span><span class="st"> </span><span class="fl">0.1</span>) <span class="op">*</span><span class="st"> </span><span class="kw">sin</span>(<span class="dv">1</span><span class="op">/</span>(v<span class="op">/</span><span class="dv">3</span> <span class="op">+</span><span class="st"> </span><span class="fl">0.1</span>))
<span class="kw">surf3D</span>(x1, x2, g4, <span class="dt">colvar =</span> g4, <span class="dt">border =</span> <span class="st">&quot;black&quot;</span>, <span class="dt">colkey =</span> <span class="ot">FALSE</span>, <span class="dt">box =</span> <span class="ot">FALSE</span>, 
    <span class="dt">main =</span> <span class="st">&quot;Setting 4&quot;</span>)</code></pre></div>
<p><img src="IDS_files/figure-html/nnet_simulate_data-1.svg" width="672" /></p>
<p>You can see that this framework is very flexible. In essence, it is to do a non-linear transformation of the linear combination. You can use this way to capture varies of relationships. For example,<span class="math inline">\(x_{1}x_{2}\)</span> can be written as <span class="math inline">\(\frac{(x_{1}+x_{2})^{2}-(x_{1}-x_{2})^{2}}{4}\)</span>, where <span class="math inline">\(M=2\)</span>. All the higher order factors of <span class="math inline">\(x_1\)</span> and <span class="math inline">\(x_2\)</span> can be represented similarly. If <span class="math inline">\(M\)</span> is large enough, this framework can approximate any continuous function on <span class="math inline">\(\mathbb{R}^{p}\)</span>. So the model family covers a board area, but with a price. That is the interpretability. Because the number of parameters increases with M and the mode is nested.</p>
<p>PPR in 1981 was a new idea then which lead to the debut of the neural network model. The basic technical idea behind deep learning has been around for decades. However, why did they take off in recent years? Here are some main drivers behind the rise.</p>
<p>First, thanks to the digitalization where lots of human activities are now in the digital realm and captured as data. So in the last 10 year, for many problems, we went from having a relatively small amount of data to accumulating a large amount of data. The traditional learning algorithms, like Logistic Regression, Support Vector Machine, Random Forest cannot effectively take advantage of such big data. Second, the increasing computation power enables us to train a large neural network either on a CPU or GPU using big data. The scale of data and computation ability lead to much progress, but tremendous algorithmic innovation is also an important driver. Many of the innovations are about speeding up the optimization of neural network. One of the examples is to use ReLU as intermediate layer activation function instead of the previous sigmoid function. The change has made the optimization process much faster because the previous sigmoid function suffers from vanishing gradient. We will talk more about that in the following sections. Here we just want to show an example of the impact of algorithmic innovation.</p>
</div>
<div id="standard-neural-network" class="section level2">
<h2><span class="header-section-number">12.2</span> Standard Neural Network</h2>
<div id="logistic_reg_as_neural_network" class="section level3">
<h3><span class="header-section-number">12.2.1</span> Logistic Regression as Neural Network</h3>
<p>Let’s look at logistic regression from the lens of neural network. For a binary classification problem, for example spam classifier, given <span class="math inline">\(m\)</span> samples <span class="math inline">\(\{(x^{(1)}, y^{(1)}),(x^{(2)}, y^{(2)}),...,(x^{(m)}, y^{(m)})\}\)</span>, we need to use the input feature <span class="math inline">\(x^{(i)}\)</span> (they may be the frequency of various words such as “money”, special characters like dollar signs, and the use of capital letters in the message etc.) to predict the output <span class="math inline">\(y^{(i)}\)</span> (if it is a spam email). Assume that for each sample <span class="math inline">\(i\)</span>, there are <span class="math inline">\(n_{x}\)</span> input features. Then we have:</p>
<span class="math display">\[\begin{equation}
X=\left[\begin{array}{cccc}
x_{1}^{(1)} &amp; x_{1}^{(2)} &amp; \dotsb &amp; x_{1}^{(m)}\\
x_{2}^{(1)} &amp; x_{2}^{(2)} &amp; \dotsb &amp; x_{2}^{(m)}\\
\vdots &amp; \vdots &amp; \vdots &amp; \vdots\\
x_{n_{x}}^{(1)} &amp; x_{n_{x}}^{(2)} &amp; \dots &amp; x_{n_{x}}^{(m)}
\end{array}\right]\in\mathbb{R}^{n_{x}\times m}
(\#eq:input)
\end{equation}\]</span>
<p><span class="math display">\[y=[y^{(1)},y^{(2)},\dots,y^{(m)}] \in \mathbb{R}^{1 \times m}\]</span></p>
<p>To predict if sample <span class="math inline">\(i\)</span> is a spam email, we first get the inactivated <strong>neuro</strong> <span class="math inline">\(z^{(i)}\)</span> by a linear transformation of the input <span class="math inline">\(x^{(i)}\)</span>, which is <span class="math inline">\(z^{(i)}=w^Tx^{(i)} + b\)</span>. Then we apply a function to “activate” the neuro <span class="math inline">\(z^{(i)}\)</span> and we call it “activation function”. In logistic regression, the activation function is sigmoid function and the “activated” <span class="math inline">\(z^{(i)}\)</span> is the prediction:</p>
<p><span class="math display">\[\hat{y}^{(i)} = \sigma(w^Tx^{(i)} + b)\]</span></p>
<p>where <span class="math inline">\(\sigma(z) = \frac{1}{1+e^{-z}}\)</span>. The following figure summarizes the process:</p>
<center>
<img src="images/dnn0.png" style="width:30.0%" />
</center>
<p>There are two types of layers. The last layer connects directly to the output. All the rest are <em>intermediate layers</em>. Depending on your definition, we call it “0-layer neural network” where the layer count only considers <em>intermediate layers</em>. To train the model, you need a cost function which is defined as equation @ref(eq:costlogistic).</p>
<span class="math display">\[\begin{equation}
J(w,b)=\frac{1}{m} \Sigma_{i=1}^m L(\hat{y}^{(i)}, y^{(i)}) = \frac{1}{m} \Sigma_{i=1}^{m} \{\ -y^{(i)}log(\hat{y}^{(i)})-(1-y^{(i)})log(1-\hat{y}^{(i)}) \}
(\#eq:costlogistic)
\end{equation}\]</span>
<p>The general approach to minimize <span class="math inline">\(J(w,b)\)</span> is by gradient descent, also known as <em>back-propagation</em>. In logistic regression, it is easy to calculate the gradient w.r.t the parameters <span class="math inline">\((w, b)\)</span> using the chain rule for differentiation. The optimization process is a forward and backward sweep over the network. Let’s look at the gradient descent for logistic regression across m sample. The non-vectorized process is as follows.</p>
<center>
<img src="images/GradientDescent.png" style="width:100.0%" />
</center>
<p>First initialize <span class="math inline">\(w_1\)</span>, <span class="math inline">\(w_2\)</span>, … , <span class="math inline">\(w_{n_x}\)</span>, and <span class="math inline">\(b\)</span>. Then plug in the initialized value to the forward and backward propagation. The forward propagation takes the current weights and calculates the prediction <span class="math inline">\(\hat{h}^{(i)}\)</span> and cost <span class="math inline">\(J^{(i)}\)</span>. The backward propagation calculates the gradient descent for the parameters. After iterating through all <span class="math inline">\(m\)</span> samples, you can calculate gradient descent for the parameters. Then update the parameter by: <span class="math display">\[w := w - \gamma \frac{\partial J}{\partial w}\]</span> <span class="math display">\[b := b - \gamma \frac{\partial J}{\partial b}\]</span></p>
<p>Repeat the progapation process using the updated parameter until the cost <span class="math inline">\(J\)</span> stabilizes.</p>
</div>
<div id="deep-neural-network" class="section level3">
<h3><span class="header-section-number">12.2.2</span> Deep Neural Network</h3>
<p>Before people coined the term <em>deep learning</em>, a neural network refers to <em>single hidden layer network</em>. Neural networks with more than one layers are called <em>deep learning</em>.</p>
<center>
<img src="images/dnn_str.png" />
</center>
</div>
<div id="activation-function" class="section level3">
<h3><span class="header-section-number">12.2.3</span> Activation Function</h3>
<p>You need to choose activation function in the hidden layers. Logistic regression only uses sigmoid activation function. But there are other choices. Intermediate layers usually use different activation function than the last layer. Let’s first look at some of the common options other than sigmoid.</p>
</div>
</div>
<div id="convolutional-neural-network" class="section level2">
<h2><span class="header-section-number">12.3</span> Convolutional Neural Network</h2>
</div>
<div id="recurrent-neural-network" class="section level2">
<h2><span class="header-section-number">12.4</span> Recurrent Neural Network</h2>
<!--chapter:end:12-DeepLearning.Rmd-->
</div>
</div>
<div id="appendix-appendix" class="section level1 unnumbered">
<h1>(APPENDIX) Appendix</h1>
</div>
<div id="big-data-cloud-platform" class="section level1">
<h1><span class="header-section-number">13</span> Big Data Cloud Platform</h1>
<div id="how-data-becomes-science" class="section level2">
<h2><span class="header-section-number">13.1</span> How Data becomes Science?</h2>
<p>Data has been statistician’s friend for hundreds of years. Tabulated data are the most familiar format that we use daily. People used to store data on papers, tapes, diskettes, or hard drives. Only recently, with the development of the computer, hardware, software, and algorithms, the volume, variety, and speed of the data suddenly beyond the capacity of a traditional statistician. And data becomes a special science with the very first focus on a fundamental question: with a huge amount of data, how can we store the data and quick access and process the data. In the past a few years, by utilizing commodity hardware and open source software, a big data ecosystem was created for data storage, data retrieval, and parallel computation. Hadoop and Spark have become a popular platform that enables data scientist, statistician, and business analyst to access the data and to build models. Programming skills in the big data platform have been the largest gap for a statistician to become a successful data scientist. However, with the recent wave of cloud computing, this gap is significantly reduced. Many of the technical details have been pushed to the background, and the user interface becomes much easier to learn. Cloud systems also enable quick implementation to the production environment. Now data science is emphasis more on the data itself as well as models and algorithms on top of the data instead of platform and infrastructure.</p>
</div>
<div id="power-of-cluster-of-computers" class="section level2">
<h2><span class="header-section-number">13.2</span> Power of Cluster of Computers</h2>
<p>We are all familiar with our laptop/desktop computers which contain mainly three components to finish computation with data: (1) Hard disk, (2) Memory, and (3) CPU as shown in Figure 41 left. The data and codes are stored in the hard disk which has certain features such as relatively slow for reading and writes and relatively large capacity of around a few TB in today’s market. Memory is relatively fast for reading and writing but relatively small in capacity in the order of a few dozens of GB in today’s market. CPU is where all the computation is done.</p>
<center>
<img src="images/cluster.png" alt="Single computer (left) and a cluster of computers (right)" />
</center>
<p>For statistical software such as R, the amount of data that it can process is limited by the computer’s memory. For a typical computer before the year 2000, the memory is less than 1 GB. The memory capacity grows far slower than the availability of the data to analyze. Now it is quite often that we need to analyze data far beyond the capacity of a single computer’s memory, especially in an enterprise environment. Meanwhile, the computation time is growing faster than linear to solve the same problem (such as regressions) as the data size increases. Using a cluster of computers become a common way to solve big data problem. In Figure 41 (right), a cluster of computers can be viewed as one powerful machine with total memory, hard disk and CPU equivale to the sum of individual computers. It is common to have thousands of nodes for a cluster.</p>
<p>In the past, to use a cluster of computers, users must write code (such as MPI) to take care of how data is distributed and how the computation is done in a parallel fashion. Luckily with the recent new development, the cloud environment for big data analysis is more user-friendly. As data is typically beyond the size of one hard disk, the dataset itself is stored across different nodes’ hard disk (i.e. the Hadoop system mentioned below). When we perform analysis, we can assume the needed data is already distributed across many node’s memories in the cluster and algorithm are parallel in nature to leverage corresponding nodes’ CPUs to compute (i.e. the Spark system mentioned below).</p>
<div id="evolution-of-clustering-computing" class="section level3">
<h3><span class="header-section-number">13.2.1</span> Evolution of Clustering Computing</h3>
<p>Using computer clusters to solve general purpose data and analytics problems needs a lot of efforts if we have to specifically control every element and steps such as data storage, memory allocation, and parallel computation. Fortunately, high tech IT companies and open source communities have developed the entire ecosystem based on Hadoop and Spark. Users need only to know high-level scripting language such as Python and R to leverage computer clusters’ storage, memory and computation power.</p>
</div>
<div id="hadoop" class="section level3">
<h3><span class="header-section-number">13.2.2</span> Hadoop</h3>
<p>The very first problem internet companies face is that a lot of data has been collected and how to better store these data for future analysis. Google developed its own file system to provide efficient, reliable access to data using large clusters of commodity hardware. The open source version is known as Hadoop Distributed File System (HDFS). Both systems use Map-Reduce to allocate computation across computation nodes on top of the file system. Hadoop in written in Java and writing map-reduce job using Java is a direct way to interact with Hadoop which is not familiar to many in the data and analytics community. To help better use Hadoop system, an SQL-like data warehouse system called Hive, and a scripting language for analytics interface called Pig were introduced for people with analytics background to interact with Hadoop system. Within Hive, we can create user defined function through R or Python to leverage the distributed and parallel computing infrastructure. Map-reduce on top of HDFS is the main concept of the Hadoop ecosystem. Each map-reduce operation requires retrieving data from hard disk, computation time, and then storing the result onto disk again. So, jobs on top of Hadoop require a lot of disk operation which may slow down the computation process.</p>
</div>
<div id="spark" class="section level3">
<h3><span class="header-section-number">13.2.3</span> Spark</h3>
<p>Spark works on top of distributed file system including HDFS with better data and analytics efficiency by leveraging in-memory operations and is more tailored for data processing and analytics. The spark system includes an SQL-like framework called Spark SQL and a parallel machine learning library called MLib. Fortunately for many in the analytics community, Spark also supports R and Python. We can interact with data stored in distributed file system using parallel computing across nodes easily with R and Python through the Spark API and do not need to worry about lower level details of distributed computing. We will introduce how to use R notebook to drive Spark computations.</p>
</div>
</div>
<div id="introduction-of-cloud-environment" class="section level2">
<h2><span class="header-section-number">13.3</span> Introduction of Cloud Environment</h2>
</div>
</div>
<div id="databases-and-sql" class="section level1">
<h1><span class="header-section-number">14</span> Databases and SQL</h1>
</div>
<div id="r-code-for-data-simulation" class="section level1">
<h1><span class="header-section-number">15</span> R code for data simulation</h1>
<div id="customer-data-for-clothing-company-1" class="section level2">
<h2><span class="header-section-number">15.1</span> Customer Data for Clothing Company</h2>
<p>The simulation is not very straightforward and we will break it into three parts:</p>
<ol style="list-style-type: decimal">
<li>Define data structure: variable names, variable distribution, customer segment names, segment size</li>
<li>Variable distribution parameters: mean and variance</li>
<li>Iterate across segments and variables. Simulate data according to specific parameters assigned</li>
</ol>
<p>By organizing code this way, it makes easy for us to change specific parts of the simulation. For example, if we want to change the distribution of one variable, we can just change the corresponding part of the code.</p>
<p>Here is code to define data structure:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># set a random number seed to make the process repeatable</span>
<span class="kw">set.seed</span>(<span class="dv">12345</span>)
<span class="co"># define the number of observations</span>
ncust&lt;-<span class="dv">1000</span>
<span class="co"># create a data frmae for simulated data</span>
seg_dat&lt;-<span class="kw">data.frame</span>(<span class="dt">id=</span><span class="kw">as.factor</span>(<span class="kw">c</span>(<span class="dv">1</span><span class="op">:</span>ncust)))
<span class="co"># assign the variable names</span>
vars&lt;-<span class="kw">c</span>(<span class="st">&quot;age&quot;</span>,<span class="st">&quot;gender&quot;</span>,<span class="st">&quot;income&quot;</span>,<span class="st">&quot;house&quot;</span>,<span class="st">&quot;store_exp&quot;</span>,<span class="st">&quot;online_exp&quot;</span>,<span class="st">&quot;store_trans&quot;</span>,<span class="st">&quot;online_trans&quot;</span>)
<span class="co"># assign distribution for each variable</span>
vartype&lt;-<span class="kw">c</span>(<span class="st">&quot;norm&quot;</span>,<span class="st">&quot;binom&quot;</span>,<span class="st">&quot;norm&quot;</span>,<span class="st">&quot;binom&quot;</span>,<span class="st">&quot;norm&quot;</span>,<span class="st">&quot;norm&quot;</span>,<span class="st">&quot;pois&quot;</span>,<span class="st">&quot;pois&quot;</span>)
<span class="co"># names of 4 segments</span>
group_name&lt;-<span class="kw">c</span>(<span class="st">&quot;Price&quot;</span>,<span class="st">&quot;Conspicuous&quot;</span>,<span class="st">&quot;Quality&quot;</span>,<span class="st">&quot;Style&quot;</span>)
<span class="co"># size of each segments</span>
group_size&lt;-<span class="kw">c</span>(<span class="dv">250</span>,<span class="dv">200</span>,<span class="dv">200</span>,<span class="dv">350</span>)</code></pre></div>
<p>The next step is to define variable distribution parameters. There are 4 segments of customers and 8 parameters. Different segments correspond to different parameters. Let’s store the parameters in a 4×8 matrix:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># matrix for mean</span>
mus &lt;-<span class="st"> </span><span class="kw">matrix</span>( <span class="kw">c</span>(
  <span class="co"># Price</span>
  <span class="dv">60</span>, <span class="fl">0.5</span>, <span class="dv">120000</span>,<span class="fl">0.9</span>, <span class="dv">500</span>,<span class="dv">200</span>,<span class="dv">5</span>,<span class="dv">2</span>,
  <span class="co"># Conspicuous</span>
  <span class="dv">40</span>, <span class="fl">0.7</span>, <span class="dv">200000</span>,<span class="fl">0.9</span>, <span class="dv">5000</span>,<span class="dv">5000</span>,<span class="dv">10</span>,<span class="dv">10</span>,
  <span class="co"># Quality</span>
  <span class="dv">36</span>, <span class="fl">0.5</span>, <span class="dv">70000</span>, <span class="fl">0.4</span>, <span class="dv">300</span>, <span class="dv">2000</span>,<span class="dv">2</span>,<span class="dv">15</span>,
  <span class="co"># Style</span>
  <span class="dv">25</span>, <span class="fl">0.2</span>, <span class="dv">90000</span>, <span class="fl">0.2</span>, <span class="dv">200</span>, <span class="dv">2000</span>,<span class="dv">2</span>,<span class="dv">20</span>), <span class="dt">ncol=</span><span class="kw">length</span>(vars), <span class="dt">byrow=</span><span class="ot">TRUE</span>)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># matrix for variance</span>
sds&lt;-<span class="st"> </span><span class="kw">matrix</span>( <span class="kw">c</span>(
  <span class="co"># Price</span>
  <span class="dv">3</span>,<span class="ot">NA</span>,<span class="dv">8000</span>,<span class="ot">NA</span>,<span class="dv">100</span>,<span class="dv">50</span>,<span class="ot">NA</span>,<span class="ot">NA</span>,
  <span class="co"># Conspicuous</span>
  <span class="dv">5</span>,<span class="ot">NA</span>,<span class="dv">50000</span>,<span class="ot">NA</span>,<span class="dv">1000</span>,<span class="dv">1500</span>,<span class="ot">NA</span>,<span class="ot">NA</span>,
  <span class="co"># Quality</span>
  <span class="dv">7</span>,<span class="ot">NA</span>,<span class="dv">10000</span>,<span class="ot">NA</span>,<span class="dv">50</span>,<span class="dv">200</span>,<span class="ot">NA</span>,<span class="ot">NA</span>,
  <span class="co"># Style</span>
  <span class="dv">2</span>,<span class="ot">NA</span>,<span class="dv">5000</span>,<span class="ot">NA</span>,<span class="dv">10</span>,<span class="dv">500</span>,<span class="ot">NA</span>,<span class="ot">NA</span>), <span class="dt">ncol=</span><span class="kw">length</span>(vars), <span class="dt">byrow=</span><span class="ot">TRUE</span>)</code></pre></div>
<p>Now we are ready to simulate data using the parameters defined above:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># simulate non-survey data</span>
sim.dat&lt;-<span class="ot">NULL</span>
<span class="kw">set.seed</span>(<span class="dv">2016</span>)
<span class="co"># loop on customer segment (i)</span>
 <span class="cf">for</span> (i <span class="cf">in</span> <span class="kw">seq_along</span>(group_name)){
 
   <span class="co"># add this line in order to moniter the process</span>
   <span class="kw">cat</span> (i, group_name[i],<span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>)
 
  <span class="co"># create an empty matrix to store relevent data</span>
  seg&lt;-<span class="kw">data.frame</span>(<span class="kw">matrix</span>(<span class="ot">NA</span>,<span class="dt">nrow=</span>group_size[i], <span class="dt">ncol=</span><span class="kw">length</span>(vars)))  
 
  <span class="co"># Simulate data within segment i</span>
  <span class="cf">for</span> (j <span class="cf">in</span> <span class="kw">seq_along</span>(vars)){
 
    <span class="co"># loop on every variable (j)</span>
    <span class="cf">if</span> (vartype[j]<span class="op">==</span><span class="st">&quot;norm&quot;</span>){
      <span class="co"># simulate normal distribution</span>
      seg[,j]&lt;-<span class="kw">rnorm</span>(group_size[i], <span class="dt">mean=</span>mus[i,j], <span class="dt">sd=</span>sds[i,j])
    } <span class="cf">else</span> <span class="cf">if</span> (vartype[j]<span class="op">==</span><span class="st">&quot;pois&quot;</span>) {
      <span class="co"># simulate poisson distribution</span>
      seg[,j]&lt;-<span class="kw">rpois</span>(group_size[i], <span class="dt">lambda=</span>mus[i,j])
    } <span class="cf">else</span> <span class="cf">if</span> (vartype[j]<span class="op">==</span><span class="st">&quot;binom&quot;</span>){
      <span class="co"># simulate binomial distribution</span>
      seg[,j]&lt;-<span class="kw">rbinom</span>(group_size[i],<span class="dt">size=</span><span class="dv">1</span>,<span class="dt">prob=</span>mus[i,j])
    } <span class="cf">else</span>{
      <span class="co"># if the distribution name is not one of the above, stop and return a message</span>
      <span class="kw">stop</span> (<span class="st">&quot;Don&#39;t have type:&quot;</span>,vartype[j])
    }        
  }
  sim.dat&lt;-<span class="kw">rbind</span>(sim.dat,seg)
 }</code></pre></div>
<p>Now let’s edit the data we just simulated a little by adding tags to 0/1 binomial variables:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># assign variable names</span>
<span class="kw">names</span>(sim.dat)&lt;-vars
<span class="co"># assign factor levels to segment variable</span>
sim.dat<span class="op">$</span>segment&lt;-<span class="kw">factor</span>(<span class="kw">rep</span>(group_name,<span class="dt">times=</span>group_size))
<span class="co"># recode gender and house variable</span>
sim.dat<span class="op">$</span>gender&lt;-<span class="kw">factor</span>(sim.dat<span class="op">$</span>gender, <span class="dt">labels=</span><span class="kw">c</span>(<span class="st">&quot;Female&quot;</span>,<span class="st">&quot;Male&quot;</span>))
sim.dat<span class="op">$</span>house&lt;-<span class="kw">factor</span>(sim.dat<span class="op">$</span>house, <span class="dt">labels=</span><span class="kw">c</span>(<span class="st">&quot;No&quot;</span>,<span class="st">&quot;Yes&quot;</span>))
<span class="co"># store_trans and online_trans are at least 1</span>
sim.dat<span class="op">$</span>store_trans&lt;-sim.dat<span class="op">$</span>store_trans<span class="op">+</span><span class="dv">1</span>
sim.dat<span class="op">$</span>online_trans&lt;-sim.dat<span class="op">$</span>online_trans<span class="op">+</span><span class="dv">1</span>
<span class="co"># age is integer</span>
sim.dat<span class="op">$</span>age&lt;-<span class="kw">floor</span>(sim.dat<span class="op">$</span>age)</code></pre></div>
<p>In the real world, the data always includes some noise such as missing, wrong imputation. So we will add some noise to the data:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># add missing values</span>
idxm &lt;-<span class="st"> </span><span class="kw">as.logical</span>(<span class="kw">rbinom</span>(ncust, <span class="dt">size=</span><span class="dv">1</span>, <span class="dt">prob=</span>sim.dat<span class="op">$</span>age<span class="op">/</span><span class="dv">200</span>))
sim.dat<span class="op">$</span>income[idxm]&lt;-<span class="ot">NA</span>
<span class="co"># add wrong imputations and outliers</span>
<span class="kw">set.seed</span>(<span class="dv">123</span>)
idx&lt;-<span class="kw">sample</span>(<span class="dv">1</span><span class="op">:</span>ncust,<span class="dv">5</span>)
sim.dat<span class="op">$</span>age[idx[<span class="dv">1</span>]]&lt;-<span class="dv">300</span>
sim.dat<span class="op">$</span>store_exp[idx[<span class="dv">2</span>]]&lt;-<span class="st"> </span><span class="op">-</span><span class="dv">500</span>
sim.dat<span class="op">$</span>store_exp[idx[<span class="dv">3</span><span class="op">:</span><span class="dv">5</span>]]&lt;-<span class="kw">c</span>(<span class="dv">50000</span>,<span class="dv">30000</span>,<span class="dv">30000</span>)</code></pre></div>
<p>So far we have created part of the data. You can check it using <code>summary(sim.dat)</code>. Next, we will move on to simulate survey data.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># number of survey questions</span>
nq&lt;-<span class="dv">10</span>
<span class="co"># mean matrix for different segments </span>
mus2 &lt;-<span class="st"> </span><span class="kw">matrix</span>( <span class="kw">c</span>(
  <span class="co"># Price</span>
 <span class="dv">5</span>,<span class="dv">2</span>,<span class="dv">1</span>,<span class="dv">3</span>,<span class="dv">1</span>,<span class="dv">4</span>,<span class="dv">1</span>,<span class="dv">4</span>,<span class="dv">2</span>,<span class="dv">4</span>,
  <span class="co"># Conspicuous</span>
 <span class="dv">1</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">4</span>,<span class="dv">4</span>,<span class="dv">4</span>,<span class="dv">4</span>,<span class="dv">1</span>,<span class="dv">4</span>,<span class="dv">2</span>,
  <span class="co"># Quality</span>
 <span class="dv">5</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">3</span>,<span class="dv">2</span>,<span class="dv">4</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">3</span>,
  <span class="co"># Style</span>
 <span class="dv">3</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">4</span>,<span class="dv">1</span>,<span class="dv">5</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">2</span>), <span class="dt">ncol=</span>nq, <span class="dt">byrow=</span><span class="ot">TRUE</span>)

<span class="co"># assume the variance is 0.2 for all</span>
sd2&lt;-<span class="fl">0.2</span>
sim.dat2&lt;-<span class="ot">NULL</span>
<span class="kw">set.seed</span>(<span class="dv">1000</span>)
<span class="co"># loop for customer segment (i)</span>
<span class="cf">for</span> (i <span class="cf">in</span> <span class="kw">seq_along</span>(group_name)){
  <span class="co"># the following line is used for checking the progress</span>
  <span class="co"># cat (i, group_name[i],&quot;\n&quot;)</span>
  <span class="co"># create an empty data frame to store data</span>
  seg&lt;-<span class="kw">data.frame</span>(<span class="kw">matrix</span>(<span class="ot">NA</span>,<span class="dt">nrow=</span>group_size[i], <span class="dt">ncol=</span>nq))  
  <span class="co"># simulate data within segment</span>
  <span class="cf">for</span> (j <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>nq){
    <span class="co"># simulate normal distribution</span>
    res&lt;-<span class="kw">rnorm</span>(group_size[i], <span class="dt">mean=</span>mus2[i,j], <span class="dt">sd=</span>sd2)
    <span class="co"># set upper and lower limit</span>
    res[res<span class="op">&gt;</span><span class="dv">5</span>]&lt;-<span class="dv">5</span>
    res[res<span class="op">&lt;</span><span class="dv">1</span>]&lt;-<span class="dv">1</span>
    <span class="co"># convert continuous values to discrete integers</span>
    seg[,j]&lt;-<span class="kw">floor</span>(res)
  }
  sim.dat2&lt;-<span class="kw">rbind</span>(sim.dat2,seg)
}

<span class="kw">names</span>(sim.dat2)&lt;-<span class="kw">paste</span>(<span class="st">&quot;Q&quot;</span>,<span class="dv">1</span><span class="op">:</span><span class="dv">10</span>,<span class="dt">sep=</span><span class="st">&quot;&quot;</span>)
sim.dat&lt;-<span class="kw">cbind</span>(sim.dat,sim.dat2)
sim.dat<span class="op">$</span>segment&lt;-<span class="kw">factor</span>(<span class="kw">rep</span>(group_name,<span class="dt">times=</span>group_size))</code></pre></div>
</div>
<div id="customer-satisfaction-survey-data-from-airline-company-1" class="section level2">
<h2><span class="header-section-number">15.2</span> Customer Satisfaction Survey Data from Airline Company</h2>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Create a matrix of factor loadings</span>
<span class="co"># This pattern is called bifactor because it has a general factor for separate components.</span>
<span class="co"># For example, &quot;Ease of making reservation&quot; has general factor loading 0.33, specific factor loading 0.58</span>
<span class="co"># The outcome variables are formed as combinations of these general and specific factors</span>
loadings &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="kw">c</span> (
  <span class="co"># Ticketing</span>
  .<span class="dv">33</span>, .<span class="dv">58</span>, .<span class="dv">00</span>, .<span class="dv">00</span>,  <span class="co"># Ease of making reservation </span>
  .<span class="dv">35</span>, .<span class="dv">55</span>, .<span class="dv">00</span>, .<span class="dv">00</span>,  <span class="co"># Availability of preferred seats</span>
  .<span class="dv">30</span>, .<span class="dv">52</span>, .<span class="dv">00</span>, .<span class="dv">00</span>,  <span class="co"># Variety of flight options</span>
  .<span class="dv">40</span>, .<span class="dv">50</span>, .<span class="dv">00</span>, .<span class="dv">00</span>,  <span class="co"># Ticket prices</span>
  <span class="co"># Aircraft</span>
  .<span class="dv">50</span>, .<span class="dv">00</span>, .<span class="dv">55</span>, .<span class="dv">00</span>,  <span class="co"># Seat comfort</span>
  .<span class="dv">41</span>, .<span class="dv">00</span>, .<span class="dv">51</span>, .<span class="dv">00</span>,  <span class="co"># Roominess of seat area</span>
  .<span class="dv">45</span>, .<span class="dv">00</span>, .<span class="dv">57</span>, .<span class="dv">00</span>,  <span class="co"># Availability of Overhead</span>
  .<span class="dv">32</span>, .<span class="dv">00</span>, .<span class="dv">54</span>, .<span class="dv">00</span>,  <span class="co"># Cleanliness of aircraft</span>
  <span class="co"># Service</span>
  .<span class="dv">35</span>, .<span class="dv">00</span>, .<span class="dv">00</span>, .<span class="dv">50</span>,  <span class="co"># Courtesy of flight attendant</span>
  .<span class="dv">38</span>, .<span class="dv">00</span>, .<span class="dv">00</span>, .<span class="dv">57</span>,  <span class="co"># Friendliness</span>
  .<span class="dv">60</span>, .<span class="dv">00</span>, .<span class="dv">00</span>, .<span class="dv">50</span>,  <span class="co"># Helpfulness</span>
  .<span class="dv">52</span>, .<span class="dv">00</span>, .<span class="dv">00</span>, .<span class="dv">58</span>,  <span class="co"># Food and drinks</span>
  <span class="co"># General   </span>
  .<span class="dv">43</span>, .<span class="dv">10</span>, .<span class="dv">30</span>, .<span class="dv">30</span>,  <span class="co"># Overall satisfaction</span>
  .<span class="dv">35</span>, .<span class="dv">50</span>, .<span class="dv">40</span>, .<span class="dv">20</span>,  <span class="co"># Purchase again</span>
  .<span class="dv">25</span>, .<span class="dv">50</span>, .<span class="dv">50</span>, .<span class="dv">20</span>), <span class="co"># Willingness to recommend</span>
  <span class="dt">nrow=</span><span class="dv">15</span>,<span class="dt">ncol=</span><span class="dv">4</span>, <span class="dt">byrow=</span><span class="ot">TRUE</span>)
  
<span class="co"># Matrix multiplication produces the correlation matrix except for the diagonal</span>
cor_matrix&lt;-loadings <span class="op">%*%</span><span class="st"> </span><span class="kw">t</span>(loadings)
<span class="co"># Diagonal set to ones</span>
<span class="kw">diag</span>(cor_matrix)&lt;-<span class="dv">1</span>

<span class="co"># use the mvtnorm package to randomly generate a data set with a given correlation pattern</span>

<span class="kw">library</span>(mvtnorm)
<span class="co"># mean vectors of the 3 airline companies</span>
mu1=<span class="kw">c</span>(<span class="dv">5</span>,<span class="dv">6</span>,<span class="dv">5</span>,<span class="dv">6</span>, <span class="dv">7</span>,<span class="dv">8</span>,<span class="dv">6</span>,<span class="dv">7</span>, <span class="dv">5</span>,<span class="dv">5</span>,<span class="dv">5</span>,<span class="dv">5</span>, <span class="dv">6</span>,<span class="dv">6</span>,<span class="dv">6</span>)
mu2=<span class="kw">c</span>(<span class="dv">3</span>,<span class="dv">3</span>,<span class="dv">2</span>,<span class="dv">3</span>, <span class="dv">5</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>, <span class="dv">8</span>,<span class="dv">8</span>,<span class="dv">8</span>,<span class="dv">8</span>, <span class="dv">3</span>,<span class="dv">3</span>,<span class="dv">3</span>)
mu3=<span class="kw">c</span>(<span class="dv">2</span>,<span class="dv">2</span>,<span class="dv">2</span>,<span class="dv">2</span>, <span class="dv">8</span>,<span class="dv">8</span>,<span class="dv">8</span>,<span class="dv">8</span>, <span class="dv">8</span>,<span class="dv">8</span>,<span class="dv">8</span>,<span class="dv">8</span>, <span class="dv">8</span>,<span class="dv">8</span>,<span class="dv">8</span>)

<span class="co"># set random seed</span>
<span class="kw">set.seed</span>(<span class="dv">123456</span>) 
<span class="co"># respondent ID</span>
resp.id &lt;-<span class="st"> </span><span class="dv">1</span><span class="op">:</span><span class="dv">1000</span> 

<span class="kw">library</span>(MASS) 
rating1 &lt;-<span class="st"> </span><span class="kw">mvrnorm</span>(<span class="kw">length</span>(resp.id),
                     <span class="dt">mu=</span>mu1,
                     <span class="dt">Sigma=</span>cor_matrix)
rating2 &lt;-<span class="st"> </span><span class="kw">mvrnorm</span>(<span class="kw">length</span>(resp.id),
                   <span class="dt">mu=</span>mu2,
                   <span class="dt">Sigma=</span>cor_matrix)
rating3 &lt;-<span class="st"> </span><span class="kw">mvrnorm</span>(<span class="kw">length</span>(resp.id),
                   <span class="dt">mu=</span>mu3,
                   <span class="dt">Sigma=</span>cor_matrix)


<span class="co"># truncates scale to be between 1 and 9</span>
rating1[rating1<span class="op">&gt;</span><span class="dv">9</span>]&lt;-<span class="dv">9</span>
rating1[rating1<span class="op">&lt;</span><span class="dv">1</span>]&lt;-<span class="dv">1</span>
rating2[rating2<span class="op">&gt;</span><span class="dv">9</span>]&lt;-<span class="dv">9</span>
rating2[rating2<span class="op">&lt;</span><span class="dv">1</span>]&lt;-<span class="dv">1</span>
rating3[rating3<span class="op">&gt;</span><span class="dv">9</span>]&lt;-<span class="dv">9</span>
rating3[rating3<span class="op">&lt;</span><span class="dv">1</span>]&lt;-<span class="dv">1</span>

<span class="co"># Round to single digit</span>
rating1&lt;-<span class="kw">data.frame</span>(<span class="kw">round</span>(rating1,<span class="dv">0</span>))
rating2&lt;-<span class="kw">data.frame</span>(<span class="kw">round</span>(rating2,<span class="dv">0</span>))
rating3&lt;-<span class="kw">data.frame</span>(<span class="kw">round</span>(rating3,<span class="dv">0</span>))
rating1<span class="op">$</span>ID&lt;-resp.id
rating2<span class="op">$</span>ID&lt;-resp.id
rating3<span class="op">$</span>ID&lt;-resp.id
rating1<span class="op">$</span>Airline&lt;-<span class="kw">rep</span>(<span class="st">&quot;AirlineCo.1&quot;</span>,<span class="kw">length</span>(resp.id))
rating2<span class="op">$</span>Airline&lt;-<span class="kw">rep</span>(<span class="st">&quot;AirlineCo.2&quot;</span>,<span class="kw">length</span>(resp.id))
rating3<span class="op">$</span>Airline&lt;-<span class="kw">rep</span>(<span class="st">&quot;AirlineCo.3&quot;</span>,<span class="kw">length</span>(resp.id))
rating&lt;-<span class="kw">rbind</span>(rating1,rating2,rating3)

<span class="co"># assign names to the variables in the data frame</span>
<span class="kw">names</span>(rating)&lt;-<span class="kw">c</span>(
  <span class="st">&quot;Easy_Reservation&quot;</span>,
  <span class="st">&quot;Preferred_Seats&quot;</span>,
  <span class="st">&quot;Flight_Options&quot;</span>,
  <span class="st">&quot;Ticket_Prices&quot;</span>,
  <span class="st">&quot;Seat_Comfort&quot;</span>,
  <span class="st">&quot;Seat_Roominess&quot;</span>,
  <span class="st">&quot;Overhead_Storage&quot;</span>,
  <span class="st">&quot;Clean_Aircraft&quot;</span>,
  <span class="st">&quot;Courtesy&quot;</span>,
  <span class="st">&quot;Friendliness&quot;</span>,
  <span class="st">&quot;Helpfulness&quot;</span>,
  <span class="st">&quot;Service&quot;</span>,
  <span class="st">&quot;Satisfaction&quot;</span>,
  <span class="st">&quot;Fly_Again&quot;</span>,
  <span class="st">&quot;Recommend&quot;</span>,
  <span class="st">&quot;ID&quot;</span>,
  <span class="st">&quot;Airline&quot;</span>)</code></pre></div>
</div>
<div id="swine-disease-breakout-data-1" class="section level2">
<h2><span class="header-section-number">15.3</span> Swine Disease Breakout Data</h2>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># sim1_da1.csv the 1st simulated data similar sim1_da2 and sim1_da3</span>
<span class="co"># sim1.csv simulated data, the first simulation dummy.sim1.csv dummy</span>
<span class="co"># variables for the first simulated data with all the baseline code for</span>
<span class="co"># simulation</span>

<span class="co"># setwd(dirname(file.choose())) library(grplasso)</span>

nf &lt;-<span class="st"> </span><span class="dv">800</span>
<span class="cf">for</span> (j <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span><span class="dv">20</span>) {
    <span class="kw">set.seed</span>(<span class="dv">19870</span> <span class="op">+</span><span class="st"> </span>j)
    x &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;A&quot;</span>, <span class="st">&quot;B&quot;</span>, <span class="st">&quot;C&quot;</span>)
    sim.da1 &lt;-<span class="st"> </span><span class="ot">NULL</span>
    <span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>nf) {
        <span class="co"># sample(x, 120, replace=TRUE)-&gt;sam</span>
        sim.da1 &lt;-<span class="st"> </span><span class="kw">rbind</span>(sim.da1, <span class="kw">sample</span>(x, <span class="dv">120</span>, <span class="dt">replace =</span> <span class="ot">TRUE</span>))
    }
    
    sim.da1 &lt;-<span class="st"> </span><span class="kw">data.frame</span>(sim.da1)
    col &lt;-<span class="st"> </span><span class="kw">paste</span>(<span class="st">&quot;Q&quot;</span>, <span class="dv">1</span><span class="op">:</span><span class="dv">120</span>, <span class="dt">sep =</span> <span class="st">&quot;&quot;</span>)
    row &lt;-<span class="st"> </span><span class="kw">paste</span>(<span class="st">&quot;Farm&quot;</span>, <span class="dv">1</span><span class="op">:</span>nf, <span class="dt">sep =</span> <span class="st">&quot;&quot;</span>)
    <span class="kw">colnames</span>(sim.da1) &lt;-<span class="st"> </span>col
    <span class="kw">rownames</span>(sim.da1) &lt;-<span class="st"> </span>row
    
    <span class="co"># use class.ind() function in nnet package to encode dummy variables</span>
    <span class="kw">library</span>(nnet)
    dummy.sim1 &lt;-<span class="st"> </span><span class="ot">NULL</span>
    <span class="cf">for</span> (k <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span><span class="kw">ncol</span>(sim.da1)) {
        tmp =<span class="st"> </span><span class="kw">class.ind</span>(sim.da1[, k])
        <span class="kw">colnames</span>(tmp) =<span class="st"> </span><span class="kw">paste</span>(col[k], <span class="kw">colnames</span>(tmp))
        dummy.sim1 =<span class="st"> </span><span class="kw">cbind</span>(dummy.sim1, tmp)
    }
    dummy.sim1 &lt;-<span class="st"> </span><span class="kw">data.frame</span>(dummy.sim1)
    
    <span class="co"># set &#39;C&#39; as the baseline delete baseline dummy variable</span>
    
    base.idx &lt;-<span class="st"> </span><span class="dv">3</span> <span class="op">*</span><span class="st"> </span><span class="kw">c</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">120</span>)
    dummy1 &lt;-<span class="st"> </span>dummy.sim1[, <span class="op">-</span>base.idx]
    
    <span class="co"># simulate independent variable for different values of r simulate</span>
    <span class="co"># based on one value of r each time r=0.1, get the link function</span>
    s1 &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="kw">rep</span>(<span class="kw">c</span>(<span class="dv">1</span><span class="op">/</span><span class="dv">10</span>, <span class="dv">0</span>, <span class="op">-</span><span class="dv">1</span><span class="op">/</span><span class="dv">10</span>), <span class="dv">40</span>), <span class="kw">rep</span>(<span class="kw">c</span>(<span class="dv">1</span><span class="op">/</span><span class="dv">10</span>, <span class="dv">0</span>, <span class="dv">0</span>), <span class="dv">40</span>), <span class="kw">rep</span>(<span class="kw">c</span>(<span class="dv">0</span>, 
        <span class="dv">0</span>, <span class="dv">0</span>), <span class="dv">40</span>))
    link1 &lt;-<span class="st"> </span><span class="kw">as.matrix</span>(dummy.sim1) <span class="op">%*%</span><span class="st"> </span>s1 <span class="op">-</span><span class="st"> </span><span class="dv">40</span><span class="op">/</span><span class="dv">3</span><span class="op">/</span><span class="dv">10</span>
    
    <span class="co"># r=0.25</span>
    <span class="co"># c(rep(c(1/4,0,-1/4),40),rep(c(1/4,0,0),40),rep(c(0,0,0),40))-&gt;s1</span>
    <span class="co"># as.matrix(dummy.sim1)%*%s1-40/3/4-&gt;link1</span>
    
    <span class="co"># r=0.5</span>
    <span class="co"># c(rep(c(1/2,0,-1/2),40),rep(c(1/2,0,0),40),rep(c(0,0,0),40))-&gt;s1</span>
    <span class="co"># as.matrix(dummy.sim1)%*%s1-40/3/2-&gt;link1</span>
    
    <span class="co"># r=1 c(rep(c(1,0,-1),40),rep(c(1,0,0),40),rep(c(0,0,0),40))-&gt;s1</span>
    <span class="co"># as.matrix(dummy.sim1)%*%s1-40/3-&gt;link1</span>
    
    <span class="co"># r=2 c(rep(c(2,0,-2),40),rep(c(2,0,0),40),rep(c(0,0,0),40))-&gt;s1</span>
    <span class="co"># as.matrix(dummy.sim1)%*%s1-40/3/0.5-&gt;link1</span>
    
    
    <span class="co"># calculate the outbreak probability</span>
    hp1 &lt;-<span class="st"> </span><span class="kw">exp</span>(link1)<span class="op">/</span>(<span class="kw">exp</span>(link1) <span class="op">+</span><span class="st"> </span><span class="dv">1</span>)
    
    <span class="co"># based on the probability hp1, simulate response variable: res</span>
    res &lt;-<span class="st"> </span><span class="kw">rep</span>(<span class="dv">9</span>, nf)
    <span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>nf) {
        res[i] &lt;-<span class="st"> </span><span class="kw">sample</span>(<span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">0</span>), <span class="dv">1</span>, <span class="dt">prob =</span> <span class="kw">c</span>(hp1[i], <span class="dv">1</span> <span class="op">-</span><span class="st"> </span>hp1[i]))
    }
    
    <span class="co"># da1 with response variable, without group indicator da2 without</span>
    <span class="co"># response variable, with group indicator da3 without response</span>
    <span class="co"># variable, without group indicator</span>
    
    dummy1<span class="op">$</span>y &lt;-<span class="st"> </span>res
    da1 &lt;-<span class="st"> </span>dummy1
    y &lt;-<span class="st"> </span>da1<span class="op">$</span>y
    ind &lt;-<span class="st"> </span><span class="ot">NULL</span>
    <span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span><span class="dv">120</span>) {
        ind &lt;-<span class="st"> </span><span class="kw">c</span>(ind, <span class="kw">rep</span>(i, <span class="dv">2</span>))
    }
    
    da2 &lt;-<span class="st"> </span><span class="kw">rbind</span>(da1[, <span class="dv">1</span><span class="op">:</span><span class="dv">240</span>], ind)
    da3 &lt;-<span class="st"> </span>da1[, <span class="dv">1</span><span class="op">:</span><span class="dv">240</span>]
    
    <span class="co"># save simulated data</span>
    <span class="kw">write.csv</span>(da1, <span class="kw">paste</span>(<span class="st">&quot;sim&quot;</span>, j, <span class="st">&quot;_da&quot;</span>, <span class="dv">1</span>, <span class="st">&quot;.csv&quot;</span>, <span class="dt">sep =</span> <span class="st">&quot;&quot;</span>), <span class="dt">row.names =</span> F)
    <span class="kw">write.csv</span>(da2, <span class="kw">paste</span>(<span class="st">&quot;sim&quot;</span>, j, <span class="st">&quot;_da&quot;</span>, <span class="dv">2</span>, <span class="st">&quot;.csv&quot;</span>, <span class="dt">sep =</span> <span class="st">&quot;&quot;</span>), <span class="dt">row.names =</span> F)
    <span class="kw">write.csv</span>(da3, <span class="kw">paste</span>(<span class="st">&quot;sim&quot;</span>, j, <span class="st">&quot;_da&quot;</span>, <span class="dv">3</span>, <span class="st">&quot;.csv&quot;</span>, <span class="dt">sep =</span> <span class="st">&quot;&quot;</span>), <span class="dt">row.names =</span> F)
    <span class="kw">write.csv</span>(sim.da1, <span class="kw">paste</span>(<span class="st">&quot;sim&quot;</span>, j, <span class="st">&quot;.csv&quot;</span>, <span class="dt">sep =</span> <span class="st">&quot;&quot;</span>), <span class="dt">row.names =</span> F)
    <span class="kw">write.csv</span>(dummy.sim1, <span class="kw">paste</span>(<span class="st">&quot;dummy.sim&quot;</span>, j, <span class="st">&quot;.csv&quot;</span>, <span class="dt">sep =</span> <span class="st">&quot;&quot;</span>), <span class="dt">row.names =</span> F)
}</code></pre></div>
<!--chapter:end:19-Appendix.Rmd-->
</div>
</div>
<div id="references" class="section level1 unnumbered">
<h1>References</h1>
<!--chapter:end:20-Reference.Rmd-->
<div id="refs" class="references">
<div id="ref-Breiman1984">
<p>al, Leo Breiman et. 1984. <em>Classification and Regression Trees</em>. ISBN 978-0412048418. Chapman; Hall/CRC.</p>
</div>
<div id="ref-BOXCOX1">
<p>Box G, Cox D. 1964. “An Analysis of Transformations.” <em>Journal of the Royal Statistical Society</em>, 211–52.</p>
</div>
<div id="ref-Breiman2001">
<p>Breiman, Leo. 2001a. “Random Forests.” <em>Machine Learning</em> 45: 5–32.</p>
</div>
<div id="ref-Breiman2001TwoCulture">
<p>———. 2001b. “Statistical Modeling: The Two Cultures.” <em>Statistical Science</em> 16 (3): 199231.</p>
</div>
<div id="ref-efron1983">
<p>Efron, B. 1983. “Estimating the Error Rate of a Prediction Rule: Improvement on Cross-Validation.” <em>Journal of the American Statistical Association</em>, 316–31.</p>
</div>
<div id="ref-bootstrap1986">
<p>Efron, B, and R Tibshirani. 1986. “Bootstrap Methods for Standard Errors, Confidence Intervals, and Other Measures of Statistical Accuracy.” <em>Statistical Science</em>, 54–75.</p>
</div>
<div id="ref-b632plus">
<p>———. 1997. “Improvements on Cross-Validation: The 632+ Bootstrap Method.” <em>Journal of the American Statistical Association</em> 92 (438): 548–60.</p>
</div>
<div id="ref-PLS1">
<p>Geladi P, Kowalski B. 1986. “Partial Least Squares Regression: A Tutorial.” <em>Analytica Chimica Acta</em>, no. 185: 1–17.</p>
</div>
<div id="ref-Hastie2008">
<p>Hastie T, Friedman J, Tibshirani R. 2008. <em>The Elements of Statistical Learning: Data Mining, Inference and Prediction</em>. 2nd ed. Springer.</p>
</div>
<div id="ref-Hyndman">
<p>Hyndman, R.J., and G. Athanasopoulos. 2013. <em>Forecasting: Principles and Practice</em>. Vol. Section 2/5. OTect: Melbourne, Australia.</p>
</div>
<div id="ref-mad1">
<p>Iglewicz, Boris, and David Hoaglin. 1993. “How to Detect and Handle Outliers.” <em>The ASQC Basic References in Quality Control: Statistical Techniques</em> 16.</p>
</div>
<div id="ref-pca1">
<p>Jolliffe, I.T. 2002. <em>Principla Component Analysis</em>. 2nd ed. Springer.</p>
</div>
<div id="ref-APM">
<p>Kuhn, Max, and Kjell Johnston. 2013. <em>Applied Predictive Modeling</em>. Springer.</p>
</div>
<div id="ref-bag1">
<p>L, Breiman. 1966a. “Bagging Predictors.” <em>Machine Learning</em> 24 (2): 123–40.</p>
</div>
<div id="ref-missing1">
<p>M, Saar Tsechansky, and Provost F. 2007b. “Handling Missing Values When Applying Classification Models.” <em>Journal of Machine Learning Research</em> 8: 1625–57.</p>
</div>
<div id="ref-EFA1">
<p>Mulaik, S.A. 2009. <em>Foundations of Factor Analysis</em>. 2ND ed. Chapman Hall/CRC.</p>
</div>
<div id="ref-ssp">
<p>Serneels S, Espen PV, Nolf ED. 2006. “Spatial Sign Preprocessing: A Simple Way to Impart Moderate Robustness to Multivariate Estimators.” <em>Journal of Chemical Information and Modeling</em> 46 (3): 1402–9.</p>
</div>
<div id="ref-Ton2011">
<p>Waal, Ton de, Jeroen Pannekoek, and Sander Scholtus. 2011. <em>Handbook of Statistical Data Editing and Imputation</em>. John Wiley; Sons.</p>
</div>
<div id="ref-willett">
<p>Willett, Peter. 2004. “Dissimilarity-Based Algorithms for Selecting Structurally Diverse Sets of Compounds.” <em>Journal of Computational Biology</em> 6(3-4) (doi:10.1089/106652799318382): 447–57.</p>
</div>
<div id="ref-rethinkDL">
<p>Zhang, Chiyuan, Samy Bengio, Moritz Hardt, Benjamin Recht, and Oriol Vinyals. 2017. “Understanding Deep Learning Requires Rethinking Generalization.” <em>arXiv :1611.03530</em>.</p>
</div>
</div>
</div>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>This is based on <a href="https://github.com/brohrer/academic_advisory">Industry recommendations for academic data science programs: https://github.com/brohrer/academic_advisory</a> with modifications. It is a collection of thoughts of different data scientist across industries about what a data scientist does, and what differentiates an exceptional data scientist.<a href="#fnref1">↩</a></p></li>
</ol>
</div>
<!--bookdown:body:end-->
            </section>

          </div>
        </div>
      </div>
<!--bookdown:link_prev-->
<!--bookdown:link_next-->
    </div>
  </div>
<!--bookdown:config-->

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    var src = "";
    if (src === "" || src === "true") src = "https://cdn.bootcss.com/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:" && /^https?:/.test(src))
      src = src.replace(/^https?:/, '');
    script.src = src;
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>
</body>

</html>
