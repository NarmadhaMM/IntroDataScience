rocCurve<-roc(response=yTest,predictor=yhatprob[,1])
plot(rocCurve)
yTest = as.factor(yTest) %>% relevel("0")
rocCurve<-roc(response=yTest,predictor=yhatprob[,2])
yTest = as.factor(yTest) %>% relevel("1")
rocCurve<-roc(response=yTest,predictor=yhatprob[,2])
yTest = as.factor(yTest) %>% relevel("0")
rocCurve<-roc(response=yTest,predictor=yhatprob[,2])
plot(rocCurve)
rocCurve<-roc(response=yTest,predictor=yhatprob[,1])
plot(rocCurve)
bookdown::render_book("index.Rmd", "bookdown::gitbook")
rocCurve<-roc(response=yTest,
predictor=yhatprob[,2],
levels = rev(levels(yTest)))
plot(rocCurve)
rocCurve<-roc(response=yTest,
predictor=yhatprob[,2],
levels = levels(yTest))
plot(rocCurve)
bookdown::render_book("index.Rmd", "bookdown::gitbook")
bookdown::render_book("index.Rmd", "bookdown::gitbook")
load("../../../Dropbox/Book_DS/Data/gbmTune.RData")
load("../../../Dropbox/Book_DS/Data/rfTune.RData")
load("../../../Dropbox/Book_DS/Data/rfTune.RData")
load("../../../Dropbox/Book_DS/Data/bagTune.RData")
treebagRoc <- roc(response = bagTune$pred$obs,
predictor = bagTune$pred$Female,
levels = rev(levels(bagTune$pred$obs)))
rfRoc <- roc(response = rfTune$pred$obs,
predictor = rfTune$pred$Female,
levels = rev(levels(rfTune$pred$obs)))
gbmRoc <- roc(response = gbmTune$pred$obs,
predictor = gbmTune$pred$Female,
levels = rev(levels(gbmTune$pred$obs)))
plot(rpartRoc, type = "s", print.thres = c(.5),
print.thres.pch = 16,
print.thres.pattern = "",
print.thres.cex = 1.2,
col = "black", legacy.axes = TRUE,
print.thres.col = "black")
library(caret)
library(pROC)
dat <- read.csv("http://bit.ly/2P5gTw4")
# use the 10 survey questions as predictors
trainx1 <- dat[, grep("Q", names(dat))]
# add a categorical predictor
# use two ways to treat categorical predictor
# trainx1: use approach 1, without encoding
trainx1$segment <- dat$segment
# trainx2: use approach 2, encode it to a set of dummy variables
dumMod<-dummyVars(~.,
data=trainx1,
# Combine the previous variable name and the level name
# as the new dummy variable name
levelsOnly=F)
trainx2 <- predict(dumMod,trainx1)
# the response variable is gender
trainy <- dat$gender
set.seed(100)
rpartTune1 <- caret::train(trainx1, trainy, method = "rpart",
tuneLength = 30,
metric = "ROC",
trControl = trainControl(method = "cv",
summaryFunction = twoClassSummary,
classProbs = TRUE,
savePredictions = TRUE))
rpartTune1
plot(rpartRoc, type = "s", print.thres = c(.5),
print.thres.pch = 16,
print.thres.pattern = "",
print.thres.cex = 1.2,
col = "black", legacy.axes = TRUE,
print.thres.col = "black")
rpartRoc <- roc(response = rpartTune1$pred$obs,
predictor = rpartTune1$pred$Female,
levels = rev(levels(rpartTune1$pred$obs)))
rpartRoc <- roc(response = rpartTune1$pred$obs,
predictor = rpartTune1$pred$Female,
levels = rev(levels(rpartTune1$pred$obs)))
rpartFactorRoc <- roc(response = rpartTune2$pred$obs,
predictor = rpartTune2$pred$Female,
levels = rev(levels(rpartTune1$pred$obs)))
plot(rpartRoc, type = "s", print.thres = c(.5),
print.thres.pch = 3,
print.thres.pattern = "",
print.thres.cex = 1.2,
col = "red", legacy.axes = TRUE,
print.thres.col = "red")
image = magick::image_read("images/edgedet3.jpeg")
image
image = magick::image_read("images/edgedet3.jpeg")
kernel_vertical = matrix(c(1, 1, 1, 0, 0, 0, -1, -1, -1),
nrow = 3, ncol = 3)
kernel_horizontal = matrix(c(1, 1, 1, 0, 0, 0, -1, -1, -1),
nrow = 3, ncol = 3, byrow = T)
image_edge_vertical = magick::image_convolve(image, kernel_vertical)
image_edge_horizontal = magick::image_convolve(image, kernel_horizontal)
par(mfrow = c(1, 3))
plot(image)
plot(image_edge_vertical)
plot(image_edge_horizontal)
plot(image)
image_edge_vertical
image = magick::image_read("images/edgedet3.jpeg")
```r
image = magick::image_read("images/edgedet3")
kernel_vertical = matrix(c(1, 1, 1, 0, 0, 0, -1, -1, -1),
nrow = 3, ncol = 3)
image = magick::image_read("images/edgedet3")
image = magick::image_read("images/edgedet3.jpeg")
image = magick::image_read("images/edgedet3.jpg")
image
image = magick::image_read("images/edgedet3.jpg")
image
kernel_vertical = matrix(c(1, 1, 1, 0, 0, 0, -1, -1, -1),
nrow = 3, ncol = 3)
kernel_horizontal = matrix(c(1, 1, 1, 0, 0, 0, -1, -1, -1),
nrow = 3, ncol = 3, byrow = T)
image_edge_vertical = magick::image_convolve(image, kernel_vertical)
image_edge_horizontal = magick::image_convolve(image, kernel_horizontal)
par(mfrow = c(1, 3))
plot(image)
plot(image)
plot(image_edge_vertical)
plot(image_edge_horizontal)
```
image = magick::image_read("images/edgedet3.jpg")
kernel_vertical = matrix(c(1, 1, 1, 0, 0, 0, -1, -1, -1),
nrow = 3, ncol = 3)
kernel_horizontal = matrix(c(1, 1, 1, 0, 0, 0, -1, -1, -1),
nrow = 3, ncol = 3, byrow = T)
image_edge_vertical = magick::image_convolve(image, kernel_vertical)
image_edge_horizontal = magick::image_convolve(image, kernel_horizontal)
par(mfrow = c(1, 3))
plot(image)
plot(image_edge_vertical)
plot(image_edge_horizontal)
image
plot(image)
plot(image_edge_vertical)
plot(image_edge_horizontal)
138/6
1624 + # mortgage
674.8 + # tax
48.33 + # insurance
230 + # HOA, 2577
50 + # Internet
59 + # ATT
80 + # estimated utility bill
23
230 +
# Dad and Mom
1029 + # iPhone
500 + #bag
# ginseng * 8
209.68 +
1000
eggshell <- readImage("images/eggshell.jpeg") %>%
# make it smaller
resize(560, 420) %>%
# rotate image
rotate(90)
plot(gray_eggshell)
library(EBImage)
library(dplyr)
eggshell <- readImage("images/eggshell.jpeg") %>%
# make it smaller
resize(560, 420) %>%
# rotate image
rotate(90)
plot(gray_eggshell)
plot(eggshell)
gray_eggshell = apply(eggshell, c(1,2), mean)
gray_eggshell = apply(gray_eggshell, 2, rev)
dim(gray_eggshell)
plot(gray_eggshell)
as.Image(gray_eggshell)
plot(as.Image(gray_eggshell))
pooling <- function(type="max",image, filter, stride)
{
f <- filter;
s <- stride
col <- dim(image[,,1])[2]  # get image dimensions
row <- dim(image[,,1])[1]
c <- (col-f)/s+1             # calculate new dimension size
r <- (row-f)/s+1
if (length(dim(image)) == 3){
newImage <- array(0, c(c, r, 3)) # create new image object
for(rgb in 1:3)                  # loops in RGB layers
{
m <- image[,,rgb]
m3 <- matrix(0, ncol = c, nrow = r)
i <- 1
if(type == "mean")
for(ii in 1:r)
{
j <- 1
for(jj in 1:c)
{
m3[ii,jj]<-mean(as.numeric(m[i:(i+(f-1)), j:(j+(f-1))]))
j <- j+s
}
i <- i+s
}
else
for(ii in 1:r)
{
j=1
for(jj in 1:c)
{
m3[ii,jj]<-max(as.numeric(m[i:(i+(f-1)), j:(j+(f-1))]))
j <- j+s
}
i <- i+s
}
newImage[,,rgb] <- m3
}
}
else if (length(dim(image)) == 2){
m3 <- matrix(0, ncol = c, nrow = r)
i <- 1
if(type == "mean")
for(ii in 1:r)
{
j <- 1
for(jj in 1:c)
{
m3[ii,jj]<-mean(as.numeric(m[i:(i+(f-1)), j:(j+(f-1))]))
j <- j+s
}
i <- i+s
}
else
for(ii in 1:r)
{
j=1
for(jj in 1:c)
{
m3[ii,jj]<-max(as.numeric(m[i:(i+(f-1)), j:(j+(f-1))]))
j <- j+s
}
i <- i+s
}
newImage <- m3
}
return(newImage)
}
pooling(gray_eggshell, 2,2)
pooling(gray_eggshell, filter = 2, stride = 2)
pooling(image = gray_eggshell, filter = 2, stride = 2)
dim(gray_eggshell)
pooling <- function(type="max",image, filter, stride)
{
f <- filter;
s <- stride
if (length(dim(image)) == 3){
col <- dim(image[,,1])[2]  # get image dimensions
row <- dim(image[,,1])[1]
c <- (col-f)/s+1             # calculate new dimension size
r <- (row-f)/s+1
newImage <- array(0, c(c, r, 3)) # create new image object
for(rgb in 1:3)                  # loops in RGB layers
{
m <- image[,,rgb]
m3 <- matrix(0, ncol = c, nrow = r)
i <- 1
if(type == "mean")
for(ii in 1:r)
{
j <- 1
for(jj in 1:c)
{
m3[ii,jj]<-mean(as.numeric(m[i:(i+(f-1)), j:(j+(f-1))]))
j <- j+s
}
i <- i+s
}
else
for(ii in 1:r)
{
j=1
for(jj in 1:c)
{
m3[ii,jj]<-max(as.numeric(m[i:(i+(f-1)), j:(j+(f-1))]))
j <- j+s
}
i <- i+s
}
newImage[,,rgb] <- m3
}
}
else if (length(dim(image)) == 2){
col <- dim(image)[2]  # get image dimensions
row <- dim(image)[1]
c <- (col-f)/s+1             # calculate new dimension size
r <- (row-f)/s+1
m3 <- matrix(0, ncol = c, nrow = r)
i <- 1
if(type == "mean")
for(ii in 1:r)
{
j <- 1
for(jj in 1:c)
{
m3[ii,jj]<-mean(as.numeric(m[i:(i+(f-1)), j:(j+(f-1))]))
j <- j+s
}
i <- i+s
}
else
for(ii in 1:r)
{
j=1
for(jj in 1:c)
{
m3[ii,jj]<-max(as.numeric(m[i:(i+(f-1)), j:(j+(f-1))]))
j <- j+s
}
i <- i+s
}
newImage <- m3
}
return(newImage)
}
pooling(image = gray_eggshell, filter = 2, stride = 2)
pooling <- function(type="max",image, filter, stride)
{
f <- filter;
s <- stride
if (length(dim(image)) == 3){
col <- dim(image[,,1])[2]  # get image dimensions
row <- dim(image[,,1])[1]
c <- (col-f)/s+1             # calculate new dimension size
r <- (row-f)/s+1
newImage <- array(0, c(c, r, 3)) # create new image object
for(rgb in 1:3)                  # loops in RGB layers
{
m <- image[,,rgb]
m3 <- matrix(0, ncol = c, nrow = r)
i <- 1
if(type == "mean")
for(ii in 1:r)
{
j <- 1
for(jj in 1:c)
{
m3[ii,jj]<-mean(as.numeric(m[i:(i+(f-1)), j:(j+(f-1))]))
j <- j+s
}
i <- i+s
}
else
for(ii in 1:r)
{
j=1
for(jj in 1:c)
{
m3[ii,jj]<-max(as.numeric(m[i:(i+(f-1)), j:(j+(f-1))]))
j <- j+s
}
i <- i+s
}
newImage[,,rgb] <- m3
}
}
else if (length(dim(image)) == 2){
col <- dim(image)[2]  # get image dimensions
row <- dim(image)[1]
c <- (col-f)/s+1             # calculate new dimension size
r <- (row-f)/s+1
m3 <- matrix(0, ncol = c, nrow = r)
i <- 1
if(type == "mean")
for(ii in 1:r)
{
j <- 1
for(jj in 1:c)
{
m3[ii,jj]<-mean(as.numeric(image[i:(i+(f-1)), j:(j+(f-1))]))
j <- j+s
}
i <- i+s
}
else
for(ii in 1:r)
{
j=1
for(jj in 1:c)
{
m3[ii,jj]<-max(as.numeric(m[i:(i+(f-1)), j:(j+(f-1))]))
j <- j+s
}
i <- i+s
}
newImage <- m3
}
return(newImage)
}
pooling(image = gray_eggshell, filter = 2, stride = 2)
pooling <- function(type="max",image, filter, stride)
{
f <- filter;
s <- stride
if (length(dim(image)) == 3){
col <- dim(image[,,1])[2]  # get image dimensions
row <- dim(image[,,1])[1]
c <- (col-f)/s+1             # calculate new dimension size
r <- (row-f)/s+1
newImage <- array(0, c(c, r, 3)) # create new image object
for(rgb in 1:3)                  # loops in RGB layers
{
m <- image[,,rgb]
m3 <- matrix(0, ncol = c, nrow = r)
i <- 1
if(type == "mean")
for(ii in 1:r)
{
j <- 1
for(jj in 1:c)
{
m3[ii,jj]<-mean(as.numeric(m[i:(i+(f-1)), j:(j+(f-1))]))
j <- j+s
}
i <- i+s
}
else
for(ii in 1:r)
{
j=1
for(jj in 1:c)
{
m3[ii,jj]<-max(as.numeric(m[i:(i+(f-1)), j:(j+(f-1))]))
j <- j+s
}
i <- i+s
}
newImage[,,rgb] <- m3
}
}
else if (length(dim(image)) == 2){
col <- dim(image)[2]  # get image dimensions
row <- dim(image)[1]
c <- (col-f)/s+1             # calculate new dimension size
r <- (row-f)/s+1
m3 <- matrix(0, ncol = c, nrow = r)
i <- 1
if(type == "mean")
for(ii in 1:r)
{
j <- 1
for(jj in 1:c)
{
m3[ii,jj]<-mean(as.numeric(image[i:(i+(f-1)), j:(j+(f-1))]))
j <- j+s
}
i <- i+s
}
else
for(ii in 1:r)
{
j=1
for(jj in 1:c)
{
m3[ii,jj]<-max(as.numeric(image[i:(i+(f-1)), j:(j+(f-1))]))
j <- j+s
}
i <- i+s
}
newImage <- m3
}
return(newImage)
}
pooling(image = gray_eggshell, filter = 2, stride = 2)
gray_eggshell_max = pooling(image = gray_eggshell, filter = 2, stride = 2)
plot(as.Image(gray_eggshell_max))
par(mfrow = c(1,2))
plot(as.Image(gray_eggshell))
plot(as.Image(gray_eggshell_max))
dim(gray_eggshell_max)
gray_eggshell_max = pooling(image = gray_eggshell, filter = 4, stride = 4)
plot(as.Image(gray_eggshell_max))
plot(as.Image(gray_eggshell))
gray_eggshell_max = pooling(image = gray_eggshell, filter = 10, stride = 10)
par(mfrow = c(1,2))
plot(as.Image(gray_eggshell))
plot(as.Image(gray_eggshell_max))
gray_eggshell_mean = pooling(type = "mean",
image = gray_eggshell,
filter = 10, stride = 10)
par(mfrow = c(2,2))
plot(eggshell)
plot(as.Image(gray_eggshell))
plot(as.Image(gray_eggshell_max))
plot(as.Image(gray_eggshell_mean))
# convert to 2D grayscale
gray_eggshell = apply(eggshell, c(1,2), mean)
# gray_eggshell = apply(gray_eggshell, 2, rev)
# convert to image type
plot(as.Image(gray_eggshell))
gray_eggshell_max = pooling(type = "max",
image = gray_eggshell,
filter = 10, stride = 10)
gray_eggshell_mean = pooling(type = "mean",
image = gray_eggshell,
filter = 10, stride = 10)
par(mfrow = c(2,2))
plot(eggshell)
plot(as.Image(gray_eggshell))
plot(as.Image(gray_eggshell_max))
plot(as.Image(gray_eggshell_mean))
bookdown::render_book("index.Rmd", "bookdown::gitbook")
